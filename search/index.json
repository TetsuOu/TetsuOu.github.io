[{"content":"\n时隔9个月，再度打周赛，人少了好多呀\n【模拟】统计对称整数的数目 题目 给你两个正整数 low 和 high 。\n对于一个由 2 * n 位数字组成的整数 x ，如果其前 n 位数字之和与后 n 位数字之和相等，则认为这个数字是一个对称整数。\n返回在 [low, high] 范围内的 对称整数的数目 。\n示例 1：\n1 2 3 输入：low = 1, high = 100 输出：9 解释：在 1 到 100 范围内共有 9 个对称整数：11、22、33、44、55、66、77、88 和 99 。 示例 2：\n1 2 3 输入：low = 1200, high = 1230 输出：4 解释：在 1200 到 1230 范围内共有 4 个对称整数：1203、1212、1221 和 1230 。 提示：\n1 \u0026lt;= low \u0026lt;= high \u0026lt;= 10^4 解题思路 按题意模拟\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Solution { public: bool isok(int num){ string s = to_string(num); int n = s.size(); if(n%2==1) return false; int front = 0; for(int i=0;i\u0026lt;n/2;i++){ front += s[i]-\u0026#39;0\u0026#39;; } int back = 0; for(int i=n/2;i\u0026lt;n;i++){ back += s[i]-\u0026#39;0\u0026#39;; } return front==back; } int countSymmetricIntegers(int low, int high) { int res = 0; for(int i=low;i\u0026lt;=high;i++) if(isok(i)) res++; return res; } }; 【枚举】生成特殊数字的最少操作 题目 给你一个下标从 0 开始的字符串 num ，表示一个非负整数。\n在一次操作中，您可以选择 num 的任意一位数字并将其删除。请注意，如果你删除 num 中的所有数字，则 num 变为 0。\n返回最少需要多少次操作可以使 num 变成特殊数字。\n如果整数 x 能被 25 整除，则该整数 x 被认为是特殊数字。\n示例 1：\n1 2 3 4 输入：num = \u0026#34;2245047\u0026#34; 输出：2 解释：删除数字 num[5] 和 num[6] ，得到数字 \u0026#34;22450\u0026#34; ，可以被 25 整除。 可以证明要使数字变成特殊数字，最少需要删除 2 位数字。 示例 2：\n1 2 3 4 输入：num = \u0026#34;2908305\u0026#34; 输出：3 解释：删除 num[3]、num[4] 和 num[6] ，得到数字 \u0026#34;2900\u0026#34; ，可以被 25 整除。 可以证明要使数字变成特殊数字，最少需要删除 3 位数字。 示例 3：\n1 2 3 4 输入：num = \u0026#34;10\u0026#34; 输出：1 解释：删除 num[0] ，得到数字 \u0026#34;0\u0026#34; ，可以被 25 整除。 可以证明要使数字变成特殊数字，最少需要删除 1 位数字。 提示\n1 \u0026lt;= num.length \u0026lt;= 100 num 仅由数字 '0' 到 '9' 组成 num 不含任何前导零 解题思路 如果一个数能被25整除，那么这个数的末尾一定是00，25，50，或75\n还有一种可能是删成0\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Solution { public: //25 00 50 75 int case4(string num, string tar){ stack\u0026lt;char\u0026gt; stk; for(auto \u0026amp;x: tar) stk.push(x); int res = 0, n = num.size(); for(int i=n-1;i\u0026gt;=0;i--){ if(!stk.empty()){ if(stk.top()==num[i]){//不用删 res ++; stk.pop(); } }else res++; } if(stk.empty()) return n-res; return n; } int case0(string num){ int n = num.size(); int res = 0; for(int i=n-1;i\u0026gt;=0;i--){ if(num[i]==\u0026#39;0\u0026#39;){ return n-1; } } return n; } int minimumOperations(string num) { if(num==\u0026#34;0\u0026#34;) return 0; int res = num.size(); // cout\u0026lt;\u0026lt;case4(num, \u0026#34;0\u0026#34;)\u0026lt;\u0026lt;endl; res = min(res, case4(num, \u0026#34;25\u0026#34;)); res = min(res, case4(num, \u0026#34;00\u0026#34;)); res = min(res, case4(num, \u0026#34;75\u0026#34;)); res = min(res, case4(num, \u0026#34;50\u0026#34;)); res = min(res, case0(num)); return res; } }; 【哈希表+前缀和】统计趣味子数组的数目 题目 给你一个下标从 0 开始的整数数组 nums ，以及整数 modulo 和整数 k 。\n请你找出并统计数组中 趣味子数组 的数目。\n如果 子数组 nums[l..r] 满足下述条件，则称其为 趣味子数组 ：\n在范围 [l, r] 内，设 cnt 为满足 nums[i] % modulo == k 的索引 i 的数量。并且 cnt % modulo == k 。 以整数形式表示并返回趣味子数组的数目。\n**注意：**子数组是数组中的一个连续非空的元素序列。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 输入：nums = [3,2,4], modulo = 2, k = 1 输出：3 解释：在这个示例中，趣味子数组分别是： 子数组 nums[0..0] ，也就是 [3] 。 - 在范围 [0, 0] 内，只存在 1 个下标 i = 0 满足 nums[i] % modulo == k 。 - 因此 cnt = 1 ，且 cnt % modulo == k 。 子数组 nums[0..1] ，也就是 [3,2] 。 - 在范围 [0, 1] 内，只存在 1 个下标 i = 0 满足 nums[i] % modulo == k 。 - 因此 cnt = 1 ，且 cnt % modulo == k 。 子数组 nums[0..2] ，也就是 [3,2,4] 。 - 在范围 [0, 2] 内，只存在 1 个下标 i = 0 满足 nums[i] % modulo == k 。 - 因此 cnt = 1 ，且 cnt % modulo == k 。 可以证明不存在其他趣味子数组。因此，答案为 3 。 示例 2：\n1 2 3 4 5 6 7 8 9 10 输入：nums = [3,1,9,6], modulo = 3, k = 0 输出：2 解释：在这个示例中，趣味子数组分别是： 子数组 nums[0..3] ，也就是 [3,1,9,6] 。 - 在范围 [0, 3] 内，只存在 3 个下标 i = 0, 2, 3 满足 nums[i] % modulo == k 。 - 因此 cnt = 3 ，且 cnt % modulo == k 。 子数组 nums[1..1] ，也就是 [1] 。 - 在范围 [1, 1] 内，不存在下标满足 nums[i] % modulo == k 。 - 因此 cnt = 0 ，且 cnt % modulo == k 。 可以证明不存在其他趣味子数组，因此答案为 2 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^9 1 \u0026lt;= modulo \u0026lt;= 10^9 0 \u0026lt;= k \u0026lt; modulo 解题思路 将满足$nums[i]\\ mod\\ modulo =k $的$nums[i]$视作1，不满足则视作0；\n计算前缀和数组cnt，对于区间[l, r]，有 $$ (s[r]-s[l-1])\\ mod\\ modulo = k $$ 等价于 $$ (s[r]-k)\\ mod\\ modulo = s[l-1]\\ mod\\ modulo $$ 从左到右枚举，利用哈希表维护之前的信息。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long class Solution { public: long long countInterestingSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int modulo, int k) { int n = nums.size(); vector\u0026lt;ll\u0026gt; cnt(n+1,0); unordered_map\u0026lt;ll,ll\u0026gt; tab;//tab[i]=j 前缀数量为i的有j个 tab[0] = 1; ll res = 0; for(int i=1;i\u0026lt;=n;i++){ cnt[i] = cnt[i-1] + (nums[i-1]%modulo==k); // (cnt[i]-x)%modulo==k ll tar = (cnt[i]%modulo-k+modulo)%modulo; res += tab[tar]; tab[cnt[i]%modulo] ++; } return res; } }; 【倍增求LCA+枚举】边权重均等查询 题目 现有一棵由 n 个节点组成的无向树，节点按从 0 到 n - 1 编号。给你一个整数 n 和一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] = [ui, vi, wi] 表示树中存在一条位于节点 ui 和节点 vi 之间、权重为 wi 的边。\n另给你一个长度为 m 的二维整数数组 queries ，其中 queries[i] = [ai, bi] 。对于每条查询，请你找出使从 ai 到 bi 路径上每条边的权重相等所需的 最小操作次数 。在一次操作中，你可以选择树上的任意一条边，并将其权重更改为任意值。\n注意：\n查询之间 相互独立 的，这意味着每条新的查询时，树都会回到 初始状态 。 从 ai 到 bi的路径是一个由 不同 节点组成的序列，从节点 ai 开始，到节点 bi 结束，且序列中相邻的两个节点在树中共享一条边。 返回一个长度为 m 的数组 answer ，其中 answer[i] 是第 i 条查询的答案。\n示例 1：\n1 2 3 4 5 6 7 输入：n = 7, edges = [[0,1,1],[1,2,1],[2,3,1],[3,4,2],[4,5,2],[5,6,2]], queries = [[0,3],[3,6],[2,6],[0,6]] 输出：[0,0,1,3] 解释：第 1 条查询，从节点 0 到节点 3 的路径中的所有边的权重都是 1 。因此，答案为 0 。 第 2 条查询，从节点 3 到节点 6 的路径中的所有边的权重都是 2 。因此，答案为 0 。 第 3 条查询，将边 [2,3] 的权重变更为 2 。在这次操作之后，从节点 2 到节点 6 的路径中的所有边的权重都是 2 。因此，答案为 1 。 第 4 条查询，将边 [0,1]、[1,2]、[2,3] 的权重变更为 2 。在这次操作之后，从节点 0 到节点 6 的路径中的所有边的权重都是 2 。因此，答案为 3 。 对于每条查询 queries[i] ，可以证明 answer[i] 是使从 ai 到 bi 的路径中的所有边的权重相等的最小操作次数。 示例 2：\n1 2 3 4 5 6 7 输入：n = 8, edges = [[1,2,6],[1,3,4],[2,4,6],[2,5,3],[3,6,6],[3,0,8],[7,0,2]], queries = [[4,6],[0,4],[6,5],[7,4]] 输出：[1,2,2,3] 解释：第 1 条查询，将边 [1,3] 的权重变更为 6 。在这次操作之后，从节点 4 到节点 6 的路径中的所有边的权重都是 6 。因此，答案为 1 。 第 2 条查询，将边 [0,3]、[3,1] 的权重变更为 6 。在这次操作之后，从节点 0 到节点 4 的路径中的所有边的权重都是 6 。因此，答案为 2 。 第 3 条查询，将边 [1,3]、[5,2] 的权重变更为 6 。在这次操作之后，从节点 6 到节点 5 的路径中的所有边的权重都是 6 。因此，答案为 2 。 第 4 条查询，将边 [0,7]、[0,3]、[1,3] 的权重变更为 6 。在这次操作之后，从节点 7 到节点 4 的路径中的所有边的权重都是 6 。因此，答案为 3 。 对于每条查询 queries[i] ，可以证明 answer[i] 是使从 ai 到 bi 的路径中的所有边的权重相等的最小操作次数。 提示：\n1 \u0026lt;= n \u0026lt;= 10^4 edges.length == n - 1 edges[i].length == 3 0 \u0026lt;= ui, vi \u0026lt; n 1 \u0026lt;= wi \u0026lt;= 26 生成的输入满足 edges 表示一棵有效的树 1 \u0026lt;= queries.length == m \u0026lt;= 2 * 104 queries[i].length == 2 0 \u0026lt;= ai, bi \u0026lt; n 解题思路 倍增求LCA\n利用倍增算法求LCA，通过LCA算出两节点距离。注意到边权范围为[1,26]，在倍增过程中枚举记录每个边权的数量，求出两节点间每个边权最多的数目，操作使得所有边权都变成这个。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #define P pair\u0026lt;int,int\u0026gt; class Solution { public: vector\u0026lt;int\u0026gt; minOperationsQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;P\u0026gt;\u0026gt; G(n); vector\u0026lt;int\u0026gt; d(n,-1); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pa(n,vector\u0026lt;int\u0026gt;(32,-1)); vector\u0026lt;vector\u0026lt;array\u0026lt;int,27\u0026gt;\u0026gt;\u0026gt; cnt(n,vector\u0026lt;array\u0026lt;int,27\u0026gt;\u0026gt;(32)); //cnt[i][j][k]: 节点i到 其第2^j的祖先节点路径中 k 的个数 //pa[i][j]: 节点i的第2^j个祖先节点 for(auto \u0026amp;edge: edges){ G[edge[0]].emplace_back(edge[1], edge[2]); G[edge[1]].emplace_back(edge[0], edge[2]); } function\u0026lt;void(int,int)\u0026gt; dfs = [\u0026amp;](int u, int fa)-\u0026gt;void{ for(auto \u0026amp;vw: G[u]){ int v = vw.first; int w = vw.second; if(v==fa) continue; cnt[v][0][w] = 1; d[v] = d[u] + 1; pa[v][0] = u; dfs(v, u); } }; d[0] = 0; pa[0][0] = -1; dfs(0, -1); // for(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;d[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;cout\u0026lt;\u0026lt;endl; int m = 32 - __builtin_clz(n); // cout\u0026lt;\u0026lt;\u0026#34;m: \u0026#34;\u0026lt;\u0026lt;m\u0026lt;\u0026lt;endl; for(int j=1;j\u0026lt;m;j++){//层级在外循环 for(int i=0;i\u0026lt;n;i++){ if(pa[i][j-1]!=-1){ pa[i][j] = pa[pa[i][j-1]][j-1]; for(int k=1;k\u0026lt;=26;k++){ cnt[i][j][k] = cnt[i][j-1][k]+cnt[pa[i][j-1]][j-1][k]; } } } } vector\u0026lt;int\u0026gt; res; for(auto \u0026amp;query: queries){ int p = query[0], q = query[1]; int path = d[p]+d[q]; if(d[p]\u0026lt;d[q]) swap(p,q); vector\u0026lt;int\u0026gt; cw(27,0); for(int j=m-1;j\u0026gt;=0;j--){ if(pa[p][j]==-1) continue; if(d[pa[p][j]]\u0026gt;=d[q]){ for(int k=1;k\u0026lt;=26;k++){ cw[k] += cnt[p][j][k]; } p = pa[p][j]; } } if(p!=q){ for(int j=m-1;j\u0026gt;=0;j--){ if(pa[p][j]==-1 || pa[q][j]==-1) continue; if(pa[p][j]!=pa[q][j]){ for(int k=1;k\u0026lt;=26;k++){ cw[k] += cnt[p][j][k]; cw[k] += cnt[q][j][k]; } p = pa[p][j]; q = pa[q][j]; } } for(int k=1;k\u0026lt;=26;k++){ cw[k] += cnt[p][0][k]; cw[k] += cnt[q][0][k]; } p = pa[p][0]; q = pa[q][0]; } int lca = p; path -= 2*d[lca]; int maxv = *max_element(cw.begin(),cw.end()); // cout\u0026lt;\u0026lt;lca\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;path\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;maxv\u0026lt;\u0026lt;endl; res.push_back(path-maxv); } return res; } }; ","date":"2023-09-06T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC361%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/20230906_hu15333137026365167594.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC361%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第361场周赛总结"},{"content":"【枚举】找出中枢整数 题目 给你一个正整数 n ，找出满足下述条件的 中枢整数 x ：\n1 和 x 之间的所有元素之和等于 x 和 n 之间所有元素之和。 返回中枢整数 x 。如果不存在中枢整数，则返回 -1 。题目保证对于给定的输入，至多存在一个中枢整数。\n示例 1：\n1 2 3 输入：n = 8 输出：6 解释：6 是中枢整数，因为 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21 。 示例 2：\n1 2 3 输入：n = 1 输出：1 解释：1 是中枢整数，因为 1 = 1 。 示例 3：\n1 2 3 输入：n = 4 输出：-1 解释：可以证明不存在满足题目要求的整数。 提示：\n1 \u0026lt;= n \u0026lt;= 1000 解题思路 枚举即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int pivotInteger(int n) { vector\u0026lt;int\u0026gt; sum(n+1,0); for(int i=1;i\u0026lt;=n;i++) sum[i] = sum[i-1] + i; for(int i=1;i\u0026lt;=n;i++){ if(sum[i]== sum[n]-sum[i-1]){ return i; } } return -1; } }; 【贪心】追加字符以获得子序列 题目 给你两个仅由小写英文字母组成的字符串 s 和 t 。\n现在需要通过向 s 末尾追加字符的方式使 t 变成 s 的一个 子序列 ，返回需要追加的最少字符数。\n子序列是一个可以由其他字符串删除部分（或不删除）字符但不改变剩下字符顺序得到的字符串。\n示例 1：\n1 2 3 4 5 输入：s = \u0026#34;coaching\u0026#34;, t = \u0026#34;coding\u0026#34; 输出：4 解释：向 s 末尾追加字符串 \u0026#34;ding\u0026#34; ，s = \u0026#34;coachingding\u0026#34; 。 现在，t 是 s (\u0026#34;coachingding\u0026#34;) 的一个子序列。 可以证明向 s 末尾追加任何 3 个字符都无法使 t 成为 s 的一个子序列。 示例 2：\n1 2 3 输入：s = \u0026#34;abcde\u0026#34;, t = \u0026#34;a\u0026#34; 输出：0 解释：t 已经是 s (\u0026#34;abcde\u0026#34;) 的一个子序列。 示例 3：\n1 2 3 4 5 输入：s = \u0026#34;z\u0026#34;, t = \u0026#34;abcde\u0026#34; 输出：5 解释：向 s 末尾追加字符串 \u0026#34;abcde\u0026#34; ，s = \u0026#34;zabcde\u0026#34; 。 现在，t 是 s (\u0026#34;zabcde\u0026#34;) 的一个子序列。 可以证明向 s 末尾追加任何 4 个字符都无法使 t 成为 s 的一个子序列。 提示：\n1 \u0026lt;= s.length, t.length \u0026lt;= 10^5 s 和 t 仅由小写英文字母组成 解题思路 只需要使用s对t进行贪心匹配\n代码 1 2 3 4 5 6 7 8 9 10 class Solution { public: int appendCharacters(string s, string t) { int j=0; for(int i=0;i\u0026lt;s.size();i++){ if(j\u0026lt;t.size() \u0026amp;\u0026amp; s[i] == t[j]) j++; } return t.size()-j; } }; 【单调栈/递归】从链表中移除节点 题目 给你一个链表的头节点 head 。\n对于列表中的每个节点 node ，如果其右侧存在一个具有 严格更大 值的节点，则移除 node 。\n返回修改后链表的头节点 head 。\n示例 1：\n1 2 3 4 5 6 输入：head = [5,2,13,3,8] 输出：[13,8] 解释：需要移除的节点是 5 ，2 和 3 。 - 节点 13 在节点 5 右侧。 - 节点 13 在节点 2 右侧。 - 节点 8 在节点 3 右侧。 示例 2：\n1 2 3 输入：head = [1,1,1,1] 输出：[1,1,1,1] 解释：每个节点的值都是 1 ，所以没有需要移除的节点。 提示：\n给定列表中的节点数目在范围 [1, 10^5] 内 1 \u0026lt;= Node.val \u0026lt;= 105 解题思路 可以将其转换成数组，利用单调栈求解是否有右侧更大值，再变回链表\n或者加个哑结点，直接在链表上用单调栈\n代码 递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: ListNode* remove(ListNode* node) { if(!node-\u0026gt;next) return node; ListNode* tmp = remove(node-\u0026gt;next); if (tmp-\u0026gt;val \u0026gt; node-\u0026gt;val) { return tmp; } node-\u0026gt;next = tmp; return node; } ListNode* removeNodes(ListNode* head) { return remove(head); } }; 单调栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: ListNode* removeNodes(ListNode* head) { ListNode* ans = new ListNode(1e6); stack\u0026lt;ListNode*\u0026gt; st; st.push(ans); while(head) { while(head-\u0026gt;val \u0026gt; st.top()-\u0026gt;val) st.pop(); st.top()-\u0026gt;next = head; st.push(head); head = head-\u0026gt;next; } return ans-\u0026gt;next; } }; 【前缀和+哈希表】统计中位数为 K 的子数组 题目 给你一个长度为 n 的数组 nums ，该数组由从 1 到 n 的 不同 整数组成。另给你一个正整数 k 。\n统计并返回 num 中的 中位数 等于 k 的非空子数组的数目。\n注意：\n数组的中位数是按递增顺序排列后位于中间的那个元素，如果数组长度为偶数，则中位数是位于中间靠左的那个元素。\n例如，[2,3,1,4] 的中位数是 2 ，[8,4,3,5,1] 的中位数是 4 。 子数组是数组中的一个连续部分。\n示例 1：\n1 2 3 输入：nums = [3,2,1,4,5], k = 4 输出：3 解释：中位数等于 4 的子数组有：[4]、[4,5] 和 [1,4,5] 。 示例 2：\n1 2 3 输入：nums = [2,3,1], k = 3 输出：1 解释：[3] 是唯一一个中位数等于 3 的子数组。 提示：\nn == nums.length 1 \u0026lt;= n \u0026lt;= 10^5 1 \u0026lt;= nums[i], k \u0026lt;= n nums 中的整数互不相同 解题思路 注意到k只会出现一次\n将k视作0，将小于k的数视作-1，将大于k的数视作+1\n那么中位数为k则子数组和为0，可能是奇数长度和偶数长度。\n子数组求和利用前缀和相减\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public: int countSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); vector\u0026lt;int\u0026gt; a; a.push_back(-1); for(auto \u0026amp;x: nums){ if(x==k) a.push_back(0); else if(x\u0026lt;k) a.push_back(-1); else a.push_back(1); } unordered_map\u0026lt;int,int\u0026gt; tab1,tab2;//存奇数长度和偶数长度的前缀和 tab2[0] = 1; int u = 0, res = 0; for(int i=1;i\u0026lt;=n;i++){ u += a[i]; int tar_one = u - 0; //奇数长度要为0 int tar_two = u - 1; //偶数长度要为1 if(i\u0026amp;1){ res += tab2[tar_one]; res += tab1[tar_two]; }else{ res += tab1[tar_one]; res += tab2[tar_two]; } if(i\u0026amp;1){ tab1[u] ++; }else{ tab2[u] ++; } } return res; } }; ","date":"2022-12-13T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC321%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20221213_hu17340725943711612554.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC321%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第321场周赛总结"},{"content":"没打\n【找规律】分割圆的最少切割次数 题目 圆内一个 有效切割 ，符合以下二者之一：\n该切割是两个端点在圆上的线段，且该线段经过圆心。 该切割是一端在圆心另一端在圆上的线段。 一些有效和无效的切割如下图所示。\n给你一个整数 n ，请你返回将圆切割成相等的 n 等分的 最少 切割次数。\n示例 1：\n1 2 3 4 输入：n = 4 输出：2 解释： 上图展示了切割圆 2 次，得到四等分。 示例 2：\n1 2 3 4 5 6 输入：n = 3 输出：3 解释： 最少需要切割 3 次，将圆切成三等分。 少于 3 次切割无法将圆切成大小相等面积相同的 3 等分。 同时可以观察到，第一次切割无法将圆切割开。 提示：\n1 \u0026lt;= n \u0026lt;= 100 解题思路 枚举前几个可以发现规律\n代码 1 2 3 4 5 6 7 8 class Solution { public: int numberOfCuts(int n) { if(n==1) return 0; if(n%2==0) return n/2; return n; } }; 【模拟】行和列中一和零的差值 题目 给你一个下标从 0 开始的 m x n 二进制矩阵 grid 。\n我们按照如下过程，定义一个下标从 0 开始的 m x n 差值矩阵 diff ：\n令第 i 行一的数目为 onesRowi 。 令第 j 列一的数目为 onesColj 。 令第 i 行零的数目为 zerosRowi 。 令第 j 列零的数目为 zerosColj 。 diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj 请你返回差值矩阵 diff 。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 输入：grid = [[0,1,1],[1,0,1],[0,0,1]] 输出：[[0,0,4],[0,0,4],[-2,-2,2]] 解释： - diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 2 + 1 - 1 - 2 = 0 - diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 2 + 1 - 1 - 2 = 0 - diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 2 + 3 - 1 - 0 = 4 - diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 2 + 1 - 1 - 2 = 0 - diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 2 + 1 - 1 - 2 = 0 - diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 2 + 3 - 1 - 0 = 4 - diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 1 + 1 - 2 - 2 = -2 - diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 1 + 1 - 2 - 2 = -2 - diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 1 + 3 - 2 - 0 = 2 示例 2：\n1 2 3 4 5 6 7 8 9 输入：grid = [[1,1,1],[1,1,1]] 输出：[[5,5,5],[5,5,5]] 解释： - diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5 - diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5 - diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5 - diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5 - diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5 - diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5 提示：\nm == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 10^5 1 \u0026lt;= m * n \u0026lt;= 10^5 grid[i][j] 要么是 0 ，要么是 1 。 解题思路 按题意模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; onesMinusZeros(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; g) { int n = g.size(), m = g[0].size(); vector\u0026lt;int\u0026gt; onesRow(n,0),onesCol(m,0),zeroRow(n,0),zeroCol(m,0); for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ onesRow[i] += g[i][j]; } zeroRow[i] = m - onesRow[i]; } for(int j=0;j\u0026lt;m;j++){ for(int i=0;i\u0026lt;n;i++){ onesCol[j] += g[i][j]; } zeroCol[j] = n - onesCol[j]; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(n, vector\u0026lt;int\u0026gt;(m,0)); for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ res[i][j] = onesRow[i]+onesCol[j]-zeroRow[i]-zeroCol[j]; } } return res; } }; 【枚举+前缀和】商店的最少代价 题目 给你一个顾客访问商店的日志，用一个下标从 0 开始且只包含字符 'N' 和 'Y' 的字符串 customers 表示：\n如果第 i 个字符是 'Y' ，它表示第 i 小时有顾客到达。 如果第 i 个字符是 'N' ，它表示第 i 小时没有顾客到达。 如果商店在第 j 小时关门（0 \u0026lt;= j \u0026lt;= n），代价按如下方式计算：\n在开门期间，如果某一个小时没有顾客到达，代价增加 1 。 在关门期间，如果某一个小时有顾客到达，代价增加 1 。 请你返回在确保代价 最小 的前提下，商店的 最早 关门时间。\n注意，商店在第 j 小时关门表示在第 j 小时以及之后商店处于关门状态。\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：customers = \u0026#34;YYNY\u0026#34; 输出：2 解释： - 第 0 小时关门，总共 1+1+0+1 = 3 代价。 - 第 1 小时关门，总共 0+1+0+1 = 2 代价。 - 第 2 小时关门，总共 0+0+0+1 = 1 代价。 - 第 3 小时关门，总共 0+0+1+1 = 2 代价。 - 第 4 小时关门，总共 0+0+1+0 = 1 代价。 在第 2 或第 4 小时关门代价都最小。由于第 2 小时更早，所以最优关门时间是 2 。 示例 2：\n1 2 3 输入：customers = \u0026#34;NNNNN\u0026#34; 输出：0 解释：最优关门时间是 0 ，因为自始至终没有顾客到达。 示例 3：\n1 2 3 输入：customers = \u0026#34;YYYY\u0026#34; 输出：4 解释：最优关门时间是 4 ，因为每一小时均有顾客到达。 提示：\n1 \u0026lt;= customers.length \u0026lt;= 10^5 customers 只包含字符 'Y' 和 'N' 。 解题思路 枚举即可，前缀和优化\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int bestClosingTime(string customers) { int n = customers.size(); vector\u0026lt;int\u0026gt; yes(n+1,0),no(n+1,0); for(int i=1;i\u0026lt;=n;i++){ if(customers[i-1]==\u0026#39;Y\u0026#39;) yes[i] = yes[i-1]+1, no[i] = no[i-1]; else yes[i] = yes[i-1], no[i] = no[i-1] + 1; } int minv = yes[n], idx = 0; for(int i=1;i\u0026lt;=n;i++){ int u = no[i] + yes[n] - yes[i]; if(u\u0026lt;minv){ minv = u; idx = i; } } return idx; } }; 【DP+计数】统计回文子序列数目 题目 给你数字字符串 s ，请你返回 s 中长度为 5 的 回文子序列 数目。由于答案可能很大，请你将答案对 109 + 7 取余 后返回。\n提示：\n如果一个字符串从前往后和从后往前读相同，那么它是 回文字符串 。 子序列是一个字符串中删除若干个字符后，不改变字符顺序，剩余字符构成的字符串。 示例 1：\n1 2 3 4 5 输入：s = \u0026#34;103301\u0026#34; 输出：2 解释： 总共有 6 长度为 5 的子序列：\u0026#34;10330\u0026#34; ，\u0026#34;10331\u0026#34; ，\u0026#34;10301\u0026#34; ，\u0026#34;10301\u0026#34; ，\u0026#34;13301\u0026#34; ，\u0026#34;03301\u0026#34; 。 它们中有两个（都是 \u0026#34;10301\u0026#34;）是回文的。 示例 2：\n1 2 3 输入：s = \u0026#34;0000000\u0026#34; 输出：21 解释：所有 21 个长度为 5 的子序列都是 \u0026#34;00000\u0026#34; ，都是回文的。 示例 3：\n1 2 3 输入：s = \u0026#34;9999900000\u0026#34; 输出：2 解释：仅有的两个回文子序列是 \u0026#34;99999\u0026#34; 和 \u0026#34;00000\u0026#34; 。 提示：\n1 \u0026lt;= s.length \u0026lt;= 10^4 s 只包含数字字符。 解题思路 对应低配题：https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/\n枚举中心点，统计前面和后面两种字符的组合即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 const int MOD = 1e9+7; class Solution { public: int countPalindromes(string s) { int n = s.size(); int suf_one[10];// suf_one[i] 表示 当前s[..n]中i的个数 int suf_two[10][10];// suf_two[i][j] 表示 当前s[..n]中i j的个数 memset(suf_one,0,sizeof(suf_one)); memset(suf_two,0,sizeof(suf_two)); suf_one[s[n-1]-\u0026#39;0\u0026#39;] = 1; for(int i=n-2;i\u0026gt;0;i--){ for(int j=0;j\u0026lt;10;j++){ suf_two[s[i]-\u0026#39;0\u0026#39;][j] += suf_one[j]; } suf_one[s[i]-\u0026#39;0\u0026#39;] ++; } int pre_one[10]; int pre_two[10][10]; memset(pre_one,0,sizeof(pre_one)); memset(pre_two,0,sizeof(pre_two)); int res = 0; pre_one[s[0]-\u0026#39;0\u0026#39;] = 1; for(int i=1;i\u0026lt;n;i++){ suf_one[s[i]-\u0026#39;0\u0026#39;] -= 1; for(int j=0;j\u0026lt;10;j++){ suf_two[s[i]-\u0026#39;0\u0026#39;][j] -= suf_one[j]; } for(int j=0;j\u0026lt;10;j++){ for(int k=0;k\u0026lt;10;k++){ if(pre_two[j][k] \u0026amp;\u0026amp; suf_two[k][j]){//j k s[i] k j res = (res + 1ll*pre_two[j][k]*suf_two[k][j]) % MOD; } } } for(int j=0;j\u0026lt;10;j++){ pre_two[j][s[i]-\u0026#39;0\u0026#39;] += pre_one[j]; } pre_one[s[i]-\u0026#39;0\u0026#39;] += 1; } return res; } }; ","date":"2022-12-08T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC92%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20221208_hu13282498055021782048.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC92%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第92场双周赛总结"},{"content":"\n【模拟】数组中不等三元组的数目 题目 给你一个下标从 0 开始的正整数数组 nums 。请你找出并统计满足下述条件的三元组 (i, j, k) 的数目：\n0 \u0026lt;= i \u0026lt; j \u0026lt; k \u0026lt; nums.length nums[i]、nums[j]和nums[k]两两不同。 换句话说：nums[i] != nums[j]、nums[i] != nums[k] 且 nums[j] != nums[k] 。 返回满足上述条件三元组的数目*。*\n示例 1：\n1 2 3 4 5 6 7 8 输入：nums = [4,4,2,4,3] 输出：3 解释：下面列出的三元组均满足题目条件： - (0, 2, 4) 因为 4 != 2 != 3 - (1, 2, 4) 因为 4 != 2 != 3 - (2, 3, 4) 因为 2 != 4 != 3 共计 3 个三元组，返回 3 。 注意 (2, 0, 4) 不是有效的三元组，因为 2 \u0026gt; 0 。 示例 2：\n1 2 3 输入：nums = [1,1,1,1,1] 输出：0 解释：不存在满足条件的三元组，所以返回 0 。 提示：\n3 \u0026lt;= nums.length \u0026lt;= 100 1 \u0026lt;= nums[i] \u0026lt;= 1000 解题思路 简单模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long class Solution { public: int unequalTriplets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int res = 0; for(int i=0;i\u0026lt;n;i++){ for(int j=i+1;j\u0026lt;n;j++){ for(int k=j+1;k\u0026lt;n;k++){ if(nums[i]!=nums[j] \u0026amp;\u0026amp; nums[j]!=nums[k] \u0026amp;\u0026amp; nums[i]!=nums[k]) res++; } } } return res; } }; 【二分】二叉搜索树最近节点查询 题目 给你一个 二叉搜索树 的根节点 root ，和一个由正整数组成、长度为 n 的数组 queries 。\n请你找出一个长度为 n 的 二维 答案数组 answer ，其中 answer[i] = [mini, maxi] ：\nmini 是树中小于等于 queries[i] 的 最大值 。如果不存在这样的值，则使用 -1 代替。 maxi 是树中大于等于 queries[i] 的 最小值 。如果不存在这样的值，则使用 -1 代替。 返回数组 answer 。\n示例 1 ：\n1 2 3 4 5 6 输入：root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16] 输出：[[2,2],[4,6],[15,-1]] 解释：按下面的描述找出并返回查询的答案： - 树中小于等于 2 的最大值是 2 ，且大于等于 2 的最小值也是 2 。所以第一个查询的答案是 [2,2] 。 - 树中小于等于 5 的最大值是 4 ，且大于等于 5 的最小值是 6 。所以第二个查询的答案是 [4,6] 。 - 树中小于等于 16 的最大值是 15 ，且大于等于 16 的最小值不存在。所以第三个查询的答案是 [15,-1] 。 示例 2 ：\n1 2 3 输入：root = [4,null,9], queries = [3] 输出：[[-1,4]] 解释：树中不存在小于等于 3 的最大值，且大于等于 3 的最小值是 4 。所以查询的答案是 [-1,4] 。 提示：\n树中节点的数目在范围 [2, 10^5] 内 1 \u0026lt;= Node.val \u0026lt;= 10^6 n == queries.length 1 \u0026lt;= n \u0026lt;= 10^5 1 \u0026lt;= queries[i] \u0026lt;= 10^6 解题思路 二叉搜索树进行中序遍历得到有序数组，然后进行二分查找即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; a; void dfs(TreeNode* root){ if(root-\u0026gt;left) dfs(root-\u0026gt;left); a.push_back(root-\u0026gt;val); if(root-\u0026gt;right) dfs(root-\u0026gt;right); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; closestNodes(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; queries) { dfs(root); int n = a.size(); // for(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; for(auto \u0026amp;u: queries){ int idx = lower_bound(a.begin(),a.end(),u)-a.begin(); int l=-1,r=-1; if(idx!=n) r = a[idx]; if(idx!=0) l = a[idx-1]; if(idx!=n \u0026amp;\u0026amp; a[idx]==u) l=u; res.push_back({l,r}); } return res; } }; 【树型DP+贪心】到达首都的最少油耗 题目 给你一棵 n 个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从 0 到 n - 1 ，且恰好有 n - 1 条路。0 是首都。给你一个二维整数数组 roads ，其中 roads[i] = [ai, bi] ，表示城市 ai 和 bi 之间有一条 双向路 。\n每个城市里有一个代表，他们都要去首都参加一个会议。\n每座城市里有一辆车。给你一个整数 seats 表示每辆车里面座位的数目。\n城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车。相邻城市之间一辆车的油耗是一升汽油。\n请你返回到达首都最少需要多少升汽油。\n示例 1：\n1 2 3 4 5 6 7 输入：roads = [[0,1],[0,2],[0,3]], seats = 5 输出：3 解释： - 代表 1 直接到达首都，消耗 1 升汽油。 - 代表 2 直接到达首都，消耗 1 升汽油。 - 代表 3 直接到达首都，消耗 1 升汽油。 最少消耗 3 升汽油。 示例 2：\n1 2 3 4 5 6 7 8 9 10 11 输入：roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2 输出：7 解释： - 代表 2 到达城市 3 ，消耗 1 升汽油。 - 代表 2 和代表 3 一起到达城市 1 ，消耗 1 升汽油。 - 代表 2 和代表 3 一起到达首都，消耗 1 升汽油。 - 代表 1 直接到达首都，消耗 1 升汽油。 - 代表 5 直接到达首都，消耗 1 升汽油。 - 代表 6 到达城市 4 ，消耗 1 升汽油。 - 代表 4 和代表 6 一起到达首都，消耗 1 升汽油。 最少消耗 7 升汽油。 示例 3：\n1 2 3 输入：roads = [], seats = 1 输出：0 解释：没有代表需要从别的城市到达首都。 提示：\n1 \u0026lt;= n \u0026lt;= 10^5 roads.length == n - 1 roads[i].length == 2 0 \u0026lt;= ai, bi \u0026lt; n ai != bi roads 表示一棵合法的树。 1 \u0026lt;= seats \u0026lt;= 10^5 解题思路 注意到一个关键结论：所有车只往根节点移动。此时的油耗会最少\n赛时统计了每个子树的大小sz，每个子树的人cnt，以及每个子树所需的油耗dp\n其实可以同时统计\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long class Solution { public: long long minimumFuelCost(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; roads, int seats) { int n = roads.size() + 1; vector\u0026lt;int\u0026gt; G[n+1]; for(auto \u0026amp;x: roads){ G[x[0]].push_back(x[1]); G[x[1]].push_back(x[0]); } vector\u0026lt;int\u0026gt; sz(n+1,0); function\u0026lt;int(int, int)\u0026gt; dfs = [\u0026amp;](int u, int fa)-\u0026gt;int{ sz[u] = 1; for(auto \u0026amp;v: G[u]){ if(v==fa) continue; dfs(v, u); sz[u] += sz[v]; } return sz[u]; }; dfs(0,-1); // for(int i=0;i\u0026lt;n;i++){ // cout\u0026lt;\u0026lt;sz[i]\u0026lt;\u0026lt;endl; // } vector\u0026lt;ll\u0026gt; dp(n, 0); vector\u0026lt;int\u0026gt; cnt(n,0); function\u0026lt;void(int,int)\u0026gt; f=[\u0026amp;](int u, int fa)-\u0026gt;void{ if(sz[u] == 1){ dp[u] = 0; cnt[u] = 1; return; } ll cur = 0; int sum = 1; for(auto \u0026amp;v: G[u]){ if(v == fa) continue; f(v, u); cur += dp[v]; sum += cnt[v]; if(cnt[v]%seats==0) cur+=cnt[v]/seats; else cur+=cnt[v]/seats+1; } dp[u] = cur; cnt[u] = sum; }; f(0,-1); // for(int i=0;i\u0026lt;n;i++){ // cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;sz[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;cnt[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;dp[i]\u0026lt;\u0026lt;endl; // } return dp[0]; } }; 偷学代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: long long minimumFuelCost(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; roads, int seats) { int n = roads.size() + 1; // 建图 vector\u0026lt;int\u0026gt; e[n]; for (auto \u0026amp;road : roads) { e[road[0]].push_back(road[1]); e[road[1]].push_back(road[0]); } long long ans = 0; // DFS 统计子树大小，同时统计答案 function\u0026lt;int(int, int)\u0026gt; dfs = [\u0026amp;](int sn, int fa) { int ret = 1; // 如果是叶子结点的话 子树大小为1 for (int fn : e[sn]) if (fn != fa) { // 计算 sn -\u0026gt; fn 这条边的贡献 int t = dfs(fn, sn); ans += (t + seats - 1) / seats; // 更新子树大小 ret += t; } return ret; }; dfs(0, -1); return ans; } }; 作者：TsReaper 链接：https://leetcode.cn/circle/discuss/bb9NEI/view/c5Ok3w/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n【DP】完美分割的方案数 题目 给你一个字符串 s ，每个字符是数字 '1' 到 '9' ，再给你两个整数 k 和 minLength 。\n如果对 s 的分割满足以下条件，那么我们认为它是一个 完美 分割：\ns 被分成 k 段互不相交的子字符串。 每个子字符串长度都 至少 为 minLength 。 每个子字符串的第一个字符都是一个 质数 数字，最后一个字符都是一个 非质数 数字。质数数字为 '2' ，'3' ，'5' 和 '7' ，剩下的都是非质数数字。 请你返回 s 的 完美 分割数目。由于答案可能很大，请返回答案对 109 + 7 取余 后的结果。\n一个 子字符串 是字符串中一段连续字符串序列。\n示例 1：\n1 2 3 4 5 6 输入：s = \u0026#34;23542185131\u0026#34;, k = 3, minLength = 2 输出：3 解释：存在 3 种完美分割方案： \u0026#34;2354 | 218 | 5131\u0026#34; \u0026#34;2354 | 21851 | 31\u0026#34; \u0026#34;2354218 | 51 | 31\u0026#34; 示例 2：\n1 2 3 输入：s = \u0026#34;23542185131\u0026#34;, k = 3, minLength = 3 输出：1 解释：存在一种完美分割方案：\u0026#34;2354 | 218 | 5131\u0026#34; 。 示例 3：\n1 2 3 输入：s = \u0026#34;3312958\u0026#34;, k = 3, minLength = 1 输出：1 解释：存在一种完美分割方案：\u0026#34;331 | 29 | 58\u0026#34; 。 提示：\n1 \u0026lt;= k, minLength \u0026lt;= s.length \u0026lt;= 1000 s 每个字符都为数字 '1' 到 '9' 之一。 解题思路 令dp[i][j]表示 s[0..i-1]分成j段的方案总数\n考虑s[i-1]成为第j段的结尾时的情况，还需要枚举第j段的开头。\ns[i-1]需要为非质数，s[t-1]需要为质数 $$ dp[i][j] = \\sum_t^{i-minLength}dp[t][j-1] $$ 故可在 $O(n*n*k)$ 时间内考虑所有情况\n考虑优化\n注意到上式t是递增，可由前缀和维护，利用g[i][j]维护相应前缀和即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 const int MOD = 1e9+7; #define ll long long class Solution { public: bool prime(char x){ if(x==\u0026#39;2\u0026#39;||x==\u0026#39;3\u0026#39;||x==\u0026#39;5\u0026#39;||x==\u0026#39;7\u0026#39;) return true; return false; } int beautifulPartitions(string s, int k, int minLength) { int n = s.size(); if(k*minLength\u0026gt;n || !prime(s[0]) || prime(s[n-1])) return 0; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; dp(n+1, vector\u0026lt;ll\u0026gt;(k+1, 0)); //dp[i][j] : s[0..i-1] 分成j 段的方案数 dp[0][0] = 1;//空字符串 vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; g(n+1, vector\u0026lt;ll\u0026gt;(k+1, 0)); //g[i][j] : \\sum_t^{i} dp[t][j-1] g[0][0] = 1; for(int i=1;i\u0026lt;=n;i++) g[i][0] = g[i-1][0] + 0; for(int j=1;j\u0026lt;=k;j++){ for(int i=1;i\u0026lt;=n;i++){//以s[i-1]为第j段的结尾 // if(j*minLength\u0026gt;i) continue; // for(int t=0;t\u0026lt;i;t++){//枚举这一段的开始位置 // if(!prime(s[i-1]) \u0026amp;\u0026amp; prime(s[t]) \u0026amp;\u0026amp; i-t\u0026gt;=minLength){ // dp[i][j] = (dp[i][j] + dp[t][j-1])%MOD; // } // } //s[i-1]为第j段结尾时，s[i-1]需为非质数 //还需要考虑第j段的开始，但是也可以直接考虑第j+1段的开始，即s[i] //s[i]需为质数 或者 字符串结束 if(i\u0026gt;=minLength \u0026amp;\u0026amp; !prime(s[i-1]) \u0026amp;\u0026amp; (i==n || prime(s[i]))){ dp[i][j] = g[i-minLength][j-1]; } } g[0][j] = dp[0][j]; for(int i=1;i\u0026lt;=n;i++){ g[i][j] = (g[i-1][j] + dp[i][j])%MOD; } } return dp[n][k]; } }; ","date":"2022-11-29T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC320%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20221129_hu11475287029871732789.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC320%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第320场周赛总结"},{"content":"没打\n【模拟】温度转换 题目 给你一个四舍五入到两位小数的非负浮点数 celsius 来表示温度，以 摄氏度（Celsius）为单位。\n你需要将摄氏度转换为 开氏度（Kelvin）和 华氏度（Fahrenheit），并以数组 ans = [kelvin, fahrenheit] 的形式返回结果。\n返回数组 ans 。与实际答案误差不超过 10-5 的会视为正确答案**。**\n注意：\n开氏度 = 摄氏度 + 273.15 华氏度 = 摄氏度 * 1.80 + 32.00 示例 1 ：\n1 2 3 输入：celsius = 36.50 输出：[309.65000,97.70000] 解释：36.50 摄氏度：转换为开氏度是 309.65 ，转换为华氏度是 97.70 。 示例 2 ：\n1 2 3 输入：celsius = 122.11 输出：[395.26000,251.79800] 解释：122.11 摄氏度：转换为开氏度是 395.26 ，转换为华氏度是 251.798 。 提示：\n0 \u0026lt;= celsius \u0026lt;= 1000 解题思路 简单模拟即可\n代码 1 2 3 4 5 6 class Solution { public: vector\u0026lt;double\u0026gt; convertTemperature(double celsius) { return {celsius+273.15, celsius*1.80+32.00}; } }; 【枚举】最小公倍数为 K 的子数组数目 题目 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 nums 的 子数组 中满足 元素最小公倍数为 k的子数组数目。\n子数组 是数组中一个连续非空的元素序列。\n数组的最小公倍数 是可被所有数组元素整除的最小正整数。\n示例 1 ：\n1 2 3 4 5 6 7 输入：nums = [3,6,2,7,1], k = 6 输出：4 解释：以 6 为最小公倍数的子数组是： - [3,6,2,7,1] - [3,6,2,7,1] - [3,6,2,7,1] - [3,6,2,7,1] 示例 2 ：\n1 2 3 输入：nums = [3], k = 2 输出：0 解释：不存在以 2 为最小公倍数的子数组。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 1000 1 \u0026lt;= nums[i], k \u0026lt;= 1000 解题思路 枚举\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int lcm(int a, int b){ return a*b/__gcd(a,b); } int subarrayLCM(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(), res = 0; for(int i=0;i\u0026lt;n;i++){ if(nums[i] == k) res++; int mv = nums[i]; for(int j=i+1;j\u0026lt;n;j++){ mv = lcm(mv, nums[j]); if(mv==k) res++; if(mv\u0026gt;k) break; } } return res; } }; 【模拟】逐层排序二叉树所需的最少操作数目 题目 给你一个 值互不相同 的二叉树的根节点 root 。\n在一步操作中，你可以选择 同一层 上任意两个节点，交换这两个节点的值。\n返回每一层按 严格递增顺序 排序所需的最少操作数目。\n节点的 层数 是该节点和根节点之间的路径的边数。\n示例 1 ：\n1 2 3 4 5 6 7 8 输入：root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10] 输出：3 解释： - 交换 4 和 3 。第 2 层变为 [3,4] 。 - 交换 7 和 5 。第 3 层变为 [5,6,8,7] 。 - 交换 8 和 7 。第 3 层变为 [5,6,7,8] 。 共计用了 3 步操作，所以返回 3 。 可以证明 3 是需要的最少操作数目。 示例 2 ：\n1 2 3 4 5 6 7 8 输入：root = [1,3,2,7,6,5,4] 输出：3 解释： - 交换 3 和 2 。第 2 层变为 [2,3] 。 - 交换 7 和 4 。第 3 层变为 [4,6,5,7] 。 - 交换 6 和 5 。第 3 层变为 [4,5,6,7] 。 共计用了 3 步操作，所以返回 3 。 可以证明 3 是需要的最少操作数目。 示例 3 ：\n1 2 3 输入：root = [1,2,3,4,5,6] 输出：0 解释：每一层已经按递增顺序排序，所以返回 0 。 提示：\n树中节点的数目在范围 [1, 10^5] 。 1 \u0026lt;= Node.val \u0026lt;= 10^5 树中的所有值 互不相同 。 解题思路 按层序遍历，取出每一层的数\n转化为子问题：给一个序列，序列两两元素可以任意交换，求最少的交换次数使得序列有序\n一般有两种做法（详见 https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/ ）\n1、从1到n枚举下标i。设当前序列第i个位置的数为ai，目标序列的第i个位置的数为bi。若ai!=bi，则不断将ai交换到目标位置，直到ai=bi。交换次数就是答案。\n2、求整个序列中置换环的数量，答案就是序列长度减去置换环的数量\n作者：TsReaper 链接：https://leetcode.cn/circle/discuss/rYjnBt/view/y0qjkB/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int minimumOperations(TreeNode* root) { queue\u0026lt;TreeNode*\u0026gt; que; que.push(root); int res = 0; while(!que.empty()){ int sz = que.size(); vector\u0026lt;int\u0026gt; row; for(int i=0;i\u0026lt;sz;i++){ TreeNode* top = que.front(); row.push_back(top-\u0026gt;val); if(top-\u0026gt;left) que.push(top-\u0026gt;left); if(top-\u0026gt;right) que.push(top-\u0026gt;right); que.pop(); } vector\u0026lt;int\u0026gt; tar(row.begin(),row.end()); sort(tar.begin(),tar.end()); int n = tar.size(); unordered_map\u0026lt;int,int\u0026gt; tab; for(int i=0;i\u0026lt;n;i++){ tab[tar[i]] = i; } for(int i=0;i\u0026lt;n;i++){ while(row[i]!=tar[i]){ swap(row[i], row[tab[row[i]]]); res ++; } } } return res; } }; 【中心拓展算法+DP】不重叠回文子字符串的最大数目 题目 给你一个字符串 s 和一个 正 整数 k 。\n从字符串 s 中选出一组满足下述条件且 不重叠 的子字符串：\n每个子字符串的长度 至少 为 k 。 每个子字符串是一个 回文串 。 返回最优方案中能选择的子字符串的 最大 数目。\n子字符串 是字符串中一个连续的字符序列。\n示例 1 ：\n1 2 3 4 输入：s = \u0026#34;abaccdbbd\u0026#34;, k = 3 输出：2 解释：可以选择 s = \u0026#34;abaccdbbd\u0026#34; 中斜体加粗的子字符串。\u0026#34;aba\u0026#34; 和 \u0026#34;dbbd\u0026#34; 都是回文，且长度至少为 k = 3 。 可以证明，无法选出两个以上的有效子字符串。 示例 2 ：\n1 2 3 输入：s = \u0026#34;adbcda\u0026#34;, k = 2 输出：0 解释：字符串中不存在长度至少为 2 的回文子字符串。 提示：\n1 \u0026lt;= k \u0026lt;= s.length \u0026lt;= 2000 s 仅由小写英文字母组成 解题思路 由中心拓展算法，枚举中心位点\n令dp[i] 表示s[0..i-1]的合法不重叠回文子字符串最大数目\n考虑s[r]在不在回文子串内\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int maxPalindromes(string s, int k) { int n = s.size(); vector\u0026lt;int\u0026gt; dp(n+1, 0); //dp[i] : s[0..i-1]的合法不重叠回文子字符串最大数目 for(int i=0;i\u0026lt;2*n-1;i++){//2n-1组中心点 int l = i/2, r = l+i%2;// dp[r+1] = max(dp[r+1], dp[r]);//如果s[r]不在回文子串内 while(l\u0026gt;=0 \u0026amp;\u0026amp; r\u0026lt;n \u0026amp;\u0026amp; s[l]==s[r]){ if(r-l+1\u0026gt;=k) { dp[r+1] = max(dp[r+1], 1+dp[l]); break;//可break } l--,r++; } } return dp[n]; } }; ","date":"2022-11-27T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC319%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20221127_hu6910111579816688997.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC319%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第319场周赛总结"},{"content":"【模拟】对数组执行操作 题目 给你一个下标从 0 开始的数组 nums ，数组大小为 n ，且由 非负 整数组成。\n你需要对数组执行 n - 1 步操作，其中第 i 步操作（从 0 开始计数）要求对 nums 中第 i 个元素执行下述指令：\n如果 nums[i] == nums[i + 1] ，则 nums[i] 的值变成原来的 2 倍，nums[i + 1] 的值变成 0 。否则，跳过这步操作。 在执行完 全部 操作后，将所有 0 移动 到数组的 末尾 。\n例如，数组 [1,0,2,0,0,1] 将所有 0 移动到末尾后变为 [1,2,1,0,0,0] 。 返回结果数组。\n注意 操作应当 依次有序 执行，而不是一次性全部执行。\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：nums = [1,2,2,1,1,0] 输出：[1,4,2,0,0,0] 解释：执行以下操作： - i = 0: nums[0] 和 nums[1] 不相等，跳过这步操作。 - i = 1: nums[1] 和 nums[2] 相等，nums[1] 的值变成原来的 2 倍，nums[2] 的值变成 0 。数组变成 [1,4,0,1,1,0] 。 - i = 2: nums[2] 和 nums[3] 不相等，所以跳过这步操作。 - i = 3: nums[3] 和 nums[4] 相等，nums[3] 的值变成原来的 2 倍，nums[4] 的值变成 0 。数组变成 [1,4,0,2,0,0] 。 - i = 4: nums[4] 和 nums[5] 相等，nums[4] 的值变成原来的 2 倍，nums[5] 的值变成 0 。数组变成 [1,4,0,2,0,0] 。 执行完所有操作后，将 0 全部移动到数组末尾，得到结果数组 [1,4,2,0,0,0] 。 示例 2：\n1 2 3 输入：nums = [0,1] 输出：[1,0] 解释：无法执行任何操作，只需要将 0 移动到末尾。 提示：\n2 \u0026lt;= nums.length \u0026lt;= 2000 0 \u0026lt;= nums[i] \u0026lt;= 1000 解题思路 按题意模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: vector\u0026lt;int\u0026gt; applyOperations(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; res; for(int i=0;i\u0026lt;n-1;i++){ if(nums[i]==nums[i+1]) nums[i]*=2,nums[i+1]=0; } for(int i=0;i\u0026lt;n;i++){ if(nums[i]!=0) res.push_back(nums[i]); } for(int i=0;i\u0026lt;n;i++){ if(nums[i]==0) res.push_back(nums[i]); } return res; } }; 【枚举】长度为 K 子数组中的最大和 题目 给你一个整数数组 nums 和一个整数 k 。请你从 nums 中满足下述条件的全部子数组中找出最大子数组和：\n子数组的长度是 k，且 子数组中的所有元素 各不相同 。 返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 0 。\n子数组 是数组中一段连续非空的元素序列。\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：nums = [1,5,4,2,9,9,9], k = 3 输出：15 解释：nums 中长度为 3 的子数组是： - [1,5,4] 满足全部条件，和为 10 。 - [5,4,2] 满足全部条件，和为 11 。 - [4,2,9] 满足全部条件，和为 15 。 - [2,9,9] 不满足全部条件，因为元素 9 出现重复。 - [9,9,9] 不满足全部条件，因为元素 9 出现重复。 因为 15 是满足全部条件的所有子数组中的最大子数组和，所以返回 15 。 示例 2：\n1 2 3 4 5 输入：nums = [4,4,4], k = 3 输出：0 解释：nums 中长度为 3 的子数组是： - [4,4,4] 不满足全部条件，因为元素 4 出现重复。 因为不存在满足全部条件的子数组，所以返回 0 。 提示：\n1 \u0026lt;= k \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^5 解题思路 枚举长度为k的子数组即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #define ll long long class Solution { public: long long maximumSubarraySum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); ll res = 0,cur=0; int l=0,r=0; unordered_map\u0026lt;int,int\u0026gt; tab; for(int i=0;i\u0026lt;k;i++){ tab[nums[i]]++; cur += nums[i]; } if(tab.size() == k) res = max(res, cur); // cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; for(int i=k;i\u0026lt;n;i++){ if(--tab[nums[i-k]]==0) tab.erase(nums[i-k]); tab[nums[i]]++; cur += nums[i]; cur -= nums[i-k]; if(tab.size() == k) res = max(res, cur); } return res; } }; 【模拟】雇佣 K 位工人的总代价 题目 给你一个下标从 0 开始的整数数组 costs ，其中 costs[i] 是雇佣第 i 位工人的代价。\n同时给你两个整数 k 和 candidates 。我们想根据以下规则恰好雇佣 k 位工人：\n总共进行 k 轮雇佣，且每一轮恰好雇佣一位工人。\n在每一轮雇佣中，从最前面\n1 candidates 和最后面\n1 candidates 人中选出代价最小的一位工人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。\n比方说，costs = [3,2,7,7,1,2] 且 candidates = 2 ，第一轮雇佣中，我们选择第 4 位工人，因为他的代价最小 [3,2,7,7,1,2] 。 第二轮雇佣，我们选择第 1 位工人，因为他们的代价与第 4 位工人一样都是最小代价，而且下标更小，[3,2,7,7,2] 。注意每一轮雇佣后，剩余工人的下标可能会发生变化。 如果剩余员工数目不足 candidates 人，那么下一轮雇佣他们中代价最小的一人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。\n一位工人只能被选择一次。\n返回雇佣恰好 k 位工人的总代价。\n示例 1：\n1 2 3 4 5 6 7 输入：costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4 输出：11 解释：我们总共雇佣 3 位工人。总代价一开始为 0 。 - 第一轮雇佣，我们从 [17,12,10,2,7,2,11,20,8] 中选择。最小代价是 2 ，有两位工人，我们选择下标更小的一位工人，即第 3 位工人。总代价是 0 + 2 = 2 。 - 第二轮雇佣，我们从 [17,12,10,7,2,11,20,8] 中选择。最小代价是 2 ，下标为 4 ，总代价是 2 + 2 = 4 。 - 第三轮雇佣，我们从 [17,12,10,7,11,20,8] 中选择，最小代价是 7 ，下标为 3 ，总代价是 4 + 7 = 11 。注意下标为 3 的工人同时在最前面和最后面 4 位工人中。 总雇佣代价是 11 。 示例 2：\n1 2 3 4 5 6 7 输入：costs = [1,2,4,1], k = 3, candidates = 3 输出：4 解释：我们总共雇佣 3 位工人。总代价一开始为 0 。 - 第一轮雇佣，我们从 [1,2,4,1] 中选择。最小代价为 1 ，有两位工人，我们选择下标更小的一位工人，即第 0 位工人，总代价是 0 + 1 = 1 。注意，下标为 1 和 2 的工人同时在最前面和最后面 3 位工人中。 - 第二轮雇佣，我们从 [2,4,1] 中选择。最小代价为 1 ，下标为 2 ，总代价是 1 + 1 = 2 。 - 第三轮雇佣，少于 3 位工人，我们从剩余工人 [2,4] 中选择。最小代价是 2 ，下标为 0 。总代价为 2 + 2 = 4 。 总雇佣代价是 4 。 提示：\n1 \u0026lt;= costs.length \u0026lt;= 10^5 1 \u0026lt;= costs[i] \u0026lt;= 10^5 1 \u0026lt;= k, candidates \u0026lt;= costs.length 解题思路 利用堆（或set）等数据结构维护工人信息即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long struct node{ int val,pos,dir; node(int v,int p,int d){ val= v,pos = p, dir=d; } friend bool operator \u0026lt; (const node \u0026amp;a, const node \u0026amp;b){ if(a.val!=b.val) return a.val\u0026lt;b.val; return a.pos\u0026lt;b.pos; } }; class Solution { public: long long totalCost(vector\u0026lt;int\u0026gt;\u0026amp; costs, int k, int candidates) { int n = costs.size(); int l = 0,r = n-1; set\u0026lt;node\u0026gt; tab; while(l\u0026lt;n \u0026amp;\u0026amp; l\u0026lt;candidates) { tab.insert(node(costs[l],l,0)); l++; } while(r\u0026gt;=l \u0026amp;\u0026amp; n-r-1 \u0026lt; candidates){ tab.insert(node(costs[r],r,1)); r--; } ll res = 0; // for(auto \u0026amp;x: tab){ // cout\u0026lt;\u0026lt;x.val\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;x.pos\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;x.dir\u0026lt;\u0026lt;endl; // } for(int i=0;i\u0026lt;k;i++){ node top = *tab.begin(); tab.erase(tab.begin()); // cout\u0026lt;\u0026lt;top.val\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;top.pos\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;top.dir\u0026lt;\u0026lt;endl; res += top.val; if(r\u0026lt;l) continue; if(top.dir==0){ tab.insert(node(costs[l],l,0)); l++; }else{ tab.insert(node(costs[r],r,1)); r--; } } return res; } }; 【dp/记忆化搜索】最小移动总距离 题目 X 轴上有一些机器人和工厂。给你一个整数数组 robot ，其中 robot[i] 是第 i 个机器人的位置。再给你一个二维整数数组 factory ，其中 factory[j] = [positionj, limitj] ，表示第 j 个工厂的位置在 positionj ，且第 j 个工厂最多可以修理 limitj 个机器人。\n每个机器人所在的位置 互不相同 。每个工厂所在的位置也 互不相同 。注意一个机器人可能一开始跟一个工厂在 相同的位置 。\n所有机器人一开始都是坏的，他们会沿着设定的方向一直移动。设定的方向要么是 X 轴的正方向，要么是 X 轴的负方向。当一个机器人经过一个没达到上限的工厂时，这个工厂会维修这个机器人，且机器人停止移动。\n任何时刻，你都可以设置 部分 机器人的移动方向。你的目标是最小化所有机器人总的移动距离。\n请你返回所有机器人移动的最小总距离。测试数据保证所有机器人都可以被维修。\n注意：\n所有机器人移动速度相同。 如果两个机器人移动方向相同，它们永远不会碰撞。 如果两个机器人迎面相遇，它们也不会碰撞，它们彼此之间会擦肩而过。 如果一个机器人经过了一个已经达到上限的工厂，机器人会当作工厂不存在，继续移动。 机器人从位置 x 到位置 y 的移动距离为 |y - x| 。 示例 1：\n1 2 3 4 5 6 7 8 9 输入：robot = [0,4,6], factory = [[2,2],[6,2]] 输出：4 解释：如上图所示： - 第一个机器人从位置 0 沿着正方向移动，在第一个工厂处维修。 - 第二个机器人从位置 4 沿着负方向移动，在第一个工厂处维修。 - 第三个机器人在位置 6 被第二个工厂维修，它不需要移动。 第一个工厂的维修上限是 2 ，它维修了 2 个机器人。 第二个工厂的维修上限是 2 ，它维修了 1 个机器人。 总移动距离是 |2 - 0| + |2 - 4| + |6 - 6| = 4 。没有办法得到比 4 更少的总移动距离。 示例 2：\n1 2 3 4 5 6 7 8 输入：robot = [1,-1], factory = [[-2,1],[2,1]] 输出：2 解释：如上图所示： - 第一个机器人从位置 1 沿着正方向移动，在第二个工厂处维修。 - 第二个机器人在位置 -1 沿着负方向移动，在第一个工厂处维修。 第一个工厂的维修上限是 1 ，它维修了 1 个机器人。 第二个工厂的维修上限是 1 ，它维修了 1 个机器人。 总移动距离是 |2 - 1| + |(-2) - (-1)| = 2 。没有办法得到比 2 更少的总移动距离。 提示：\n1 \u0026lt;= robot.length, factory.length \u0026lt;= 100 factory[j].length == 2 -10^9 \u0026lt;= robot[i], positionj \u0026lt;= 10^9 0 \u0026lt;= limitj \u0026lt;= robot.length 测试数据保证所有机器人都可以被维修。 解题思路 注意一个重要结论，一个工厂肯定是负责一段连续的机器人，不会出现交叉的情况，可以反证（交换邻项）\n利用dp[i][j]表示 工厂[i..n-1]修理机器人[j..m-1]所需的最小移动总距离\n枚举最后一个工厂修理机器人的个数进行状态转移\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #define ll long long const ll INF = LONG_MAX; class Solution { public: long long minimumTotalDistance(vector\u0026lt;int\u0026gt;\u0026amp; robot, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; factory) { int n = factory.size(), m = robot.size(); sort(robot.begin(), robot.end()); sort(factory.begin(), factory.end(),[\u0026amp;](vector\u0026lt;int\u0026gt;\u0026amp; a, vector\u0026lt;int\u0026gt;\u0026amp; b){ return a[0]\u0026lt;b[0]; }); // vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; dp(n+1,vector\u0026lt;ll\u0026gt;(m+1,INF)); //dp[i][j] 表示 工厂[i..n-1]修理机器人[j..m-1]所需的最小移动总距离 function\u0026lt;ll(int,int)\u0026gt; dfs=[\u0026amp;](int i,int j)-\u0026gt;ll{ if(dp[i][j]!=INF) return dp[i][j]; if(j==m) return 0; if(i==n-1){ if(m-j\u0026gt;factory[i][1]) return INF/2; ll res = 0; for(int k=j;k\u0026lt;m;k++) res += abs(robot[k]-factory[i][0]); return res; } ll sum = dfs(i+1,j);//第i个工厂不修 任何一个机器人 int k=1;//枚举第i个工厂修k个机器人 ll cur = 0; while(k\u0026lt;=factory[i][1] \u0026amp;\u0026amp; j+k-1\u0026lt;m){ cur += abs(robot[j+k-1] - factory[i][0]); sum = min(sum, cur + dfs(i+1, j+k)); k++; } return dp[i][j] = sum; }; return dfs(0,0); } }; ","date":"2022-11-21T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC318%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20221121_hu17745687109575338871.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC318%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第318场周赛总结"},{"content":"【模拟】可被三整除的偶数的平均值 题目 给你一个由正整数组成的整数数组 nums ，返回其中可被 3 整除的所有偶数的平均值。\n注意：n 个元素的平均值等于 n 个元素 求和 再除以 n ，结果 向下取整 到最接近的整数。\n示例 1：\n1 2 3 输入：nums = [1,3,6,10,12,15] 输出：9 解释：6 和 12 是可以被 3 整除的偶数。(6 + 12) / 2 = 9 。 示例 2：\n1 2 3 输入：nums = [1,2,4,7,10] 输出：0 解释：不存在满足题目要求的整数，所以返回 0 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 1000 1 \u0026lt;= nums[i] \u0026lt;= 1000 解题思路 按题意模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 class Solution { public: int averageValue(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(), m = 0, res = 0; for(auto \u0026amp;x: nums){ if(x%2==0 \u0026amp;\u0026amp; x%3==0) res+=x,m++; } if(m==0) return 0; return res/m; } }; 【哈希表】最流行的视频创作者 题目 给你两个字符串数组 creators 和 ids ，和一个整数数组 views ，所有数组的长度都是 n 。平台上第 i 个视频者是 creator[i] ，视频分配的 id 是 ids[i] ，且播放量为 views[i] 。\n视频创作者的 流行度 是该创作者的 所有 视频的播放量的 总和 。请找出流行度 最高 创作者以及该创作者播放量 最大 的视频的 id 。\n如果存在多个创作者流行度都最高，则需要找出所有符合条件的创作者。 如果某个创作者存在多个播放量最高的视频，则只需要找出字典序最小的 id 。 返回一个二维字符串数组 answer ，其中 answer[i] = [creatori, idi] 表示 creatori 的流行度 最高 且其最流行的视频 id 是 idi ，可以按任何顺序返回该结果*。*\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：creators = [\u0026#34;alice\u0026#34;,\u0026#34;bob\u0026#34;,\u0026#34;alice\u0026#34;,\u0026#34;chris\u0026#34;], ids = [\u0026#34;one\u0026#34;,\u0026#34;two\u0026#34;,\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;], views = [5,10,5,4] 输出：[[\u0026#34;alice\u0026#34;,\u0026#34;one\u0026#34;],[\u0026#34;bob\u0026#34;,\u0026#34;two\u0026#34;]] 解释： alice 的流行度是 5 + 5 = 10 。 bob 的流行度是 10 。 chris 的流行度是 4 。 alice 和 bob 是流行度最高的创作者。 bob 播放量最高的视频 id 为 \u0026#34;two\u0026#34; 。 alice 播放量最高的视频 id 是 \u0026#34;one\u0026#34; 和 \u0026#34;three\u0026#34; 。由于 \u0026#34;one\u0026#34; 的字典序比 \u0026#34;three\u0026#34; 更小，所以结果中返回的 id 是 \u0026#34;one\u0026#34; 。 示例 2：\n1 2 3 4 5 输入：creators = [\u0026#34;alice\u0026#34;,\u0026#34;alice\u0026#34;,\u0026#34;alice\u0026#34;], ids = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;], views = [1,2,2] 输出：[[\u0026#34;alice\u0026#34;,\u0026#34;b\u0026#34;]] 解释： id 为 \u0026#34;b\u0026#34; 和 \u0026#34;c\u0026#34; 的视频都满足播放量最高的条件。 由于 \u0026#34;b\u0026#34; 的字典序比 \u0026#34;c\u0026#34; 更小，所以结果中返回的 id 是 \u0026#34;b\u0026#34; 。 提示：\nn == creators.length == ids.length == views.length 1 \u0026lt;= n \u0026lt;= 10^5 1 \u0026lt;= creators[i].length, ids[i].length \u0026lt;= 5 creators[i] 和 ids[i] 仅由小写英文字母组成 0 \u0026lt;= views[i] \u0026lt;= 10^5 解题思路 利用两个哈希表，分别存储name-\u0026gt;所有流行度之和， name-\u0026gt;播放量最高且字典序最小的视频id\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #define ll long long class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; mostPopularCreator(vector\u0026lt;string\u0026gt;\u0026amp; creators, vector\u0026lt;string\u0026gt;\u0026amp; ids, vector\u0026lt;int\u0026gt;\u0026amp; views) { int n = creators.size(); unordered_map\u0026lt;string,ll\u0026gt; tab;//tab[name] = sum unordered_map\u0026lt;string,int\u0026gt; part;//part[name] = views[i] ll maxv = 0; for(int i=0;i\u0026lt;n;i++){ if(tab.count(creators[i])){ tab[creators[i]] += views[i]; int \u0026amp;u = part[creators[i]]; if(views[i]\u0026gt;views[u] || (views[i]==views[u] \u0026amp;\u0026amp; ids[i]\u0026lt;ids[u])){ u = i; } }else{ tab[creators[i]] = views[i]; part[creators[i]] = i; } maxv = max(maxv, tab[creators[i]]); } vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; res; for(auto it=part.begin();it!=part.end();it++){ if(tab[it-\u0026gt;first] == maxv){ res.push_back({it-\u0026gt;first, ids[it-\u0026gt;second]}); } } return res; } }; 【数学\u0026amp;模拟进位】美丽整数的最小增量 题目 给你两个正整数 n 和 target 。\n如果某个整数每一位上的数字相加小于或等于 target ，则认为这个整数是一个 美丽整数 。\n找出并返回满足 n + x 是 美丽整数 的最小非负整数 x 。生成的输入保证总可以使 n 变成一个美丽整数。\n示例 1：\n1 2 3 输入：n = 16, target = 6 输出：4 解释：最初，n 是 16 ，且其每一位数字的和是 1 + 6 = 7 。在加 4 之后，n 变为 20 且每一位数字的和变成 2 + 0 = 2 。可以证明无法加上一个小于 4 的非负整数使 n 变成一个美丽整数。 示例 2：\n1 2 3 输入：n = 467, target = 6 输出：33 解释：最初，n 是 467 ，且其每一位数字的和是 4 + 6 + 7 = 17 。在加 33 之后，n 变为 500 且每一位数字的和变成 5 + 0 + 0 = 5 。可以证明无法加上一个小于 33 的非负整数使 n 变成一个美丽整数。 示例 3：\n1 2 3 输入：n = 1, target = 1 输出：0 解释：最初，n 是 1 ，且其每一位数字的和是 1 ，已经小于等于 target 。 提示：\n1 \u0026lt;= n \u0026lt;= 10^12 1 \u0026lt;= target \u0026lt;= 150 生成的输入保证总可以使 n 变成一个美丽整数。 解题思路 首先考虑怎样才能使数位和减小？\n只可能加上x使得原数产生进位才有可能，否则不进位的话，数位和是不可能减小的\n所以从个位开始模拟进位即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #define ll long long class Solution { public: long long makeIntegerBeautiful(long long n, int target) { vector\u0026lt;int\u0026gt; stk; int ori = 0; ll m = n; while(m){ stk.push_back(m%10); ori += m%10; m = m/10; } if(ori\u0026lt;=target) return 0;//如果一开始数位和就小于等于target ll tail = 1, res = 0; reverse(stk.begin(),stk.end()); while(!stk.empty()){//低位到高位 int u = stk.back();//当前位 //必须产生进位才可能能使得数位和减小 int need = 10 - u;//当前位进位所需要的加数 stk.pop_back(); ori -= u;//进位的话 当前位就变成0了 int carry = 1;//向前进位 for(int i=stk.size()-1;i\u0026gt;=0;i--){//模拟进位过程 stk[i] += carry; ori += 1;//进位后数位和加1 if(stk[i]==10){//可以继续进位 carry = 1; ori -= 10; stk[i]=0; }else{ carry = 0; break; } } if(carry) {// ori += 1; stk.insert(stk.begin(),1); } res += 1ll * need * tail; tail *= 10; if(ori \u0026lt;= target) break; } return res; } }; 【DFS序+时间戳】移除子树后的二叉树高度 题目 给你一棵 二叉树 的根节点 root ，树中有 n 个节点。每个节点都可以被分配一个从 1 到 n 且互不相同的值。另给你一个长度为 m 的数组 queries 。\n你必须在树上执行 m 个 独立 的查询，其中第 i 个查询你需要执行以下操作：\n从树中 移除 以 queries[i] 的值作为根节点的子树。题目所用测试用例保证 queries[i] 不 等于根节点的值。 返回一个长度为 m 的数组 answer ，其中 answer[i] 是执行第 i 个查询后树的高度。\n注意：\n查询之间是独立的，所以在每个查询执行后，树会回到其 初始 状态。 树的高度是从根到树中某个节点的 最长简单路径中的边数 。 示例 1：\n1 2 3 4 输入：root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4] 输出：[2] 解释：上图展示了从树中移除以 4 为根节点的子树。 树的高度是 2（路径为 1 -\u0026gt; 3 -\u0026gt; 2）。 示例 2：\n1 2 3 4 5 6 7 输入：root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8] 输出：[3,2,3,2] 解释：执行下述查询： - 移除以 3 为根节点的子树。树的高度变为 3（路径为 5 -\u0026gt; 8 -\u0026gt; 2 -\u0026gt; 4）。 - 移除以 2 为根节点的子树。树的高度变为 2（路径为 5 -\u0026gt; 8 -\u0026gt; 1）。 - 移除以 4 为根节点的子树。树的高度变为 3（路径为 5 -\u0026gt; 8 -\u0026gt; 2 -\u0026gt; 6）。 - 移除以 8 为根节点的子树。树的高度变为 2（路径为 5 -\u0026gt; 9 -\u0026gt; 3）。 提示：\n树中节点的数目是 n 2 \u0026lt;= n \u0026lt;= 10^5 1 \u0026lt;= Node.val \u0026lt;= n 树中的所有值 互不相同 m == queries.length 1 \u0026lt;= m \u0026lt;= min(n, 10^4) 1 \u0026lt;= queries[i] \u0026lt;= n queries[i] != root.val 解题思路 子树里的所有点是 DFS 序里的一个连续区间。因此本题可以被转化为如下问题：\n给定一个序列，每次删除一个连续区间，求序列里剩下的数的最大值。\n显然删除一个连续区间后，序列会剩下一个前缀以及一个后缀。我们预处理前缀 max 和后缀 max，就能 $\\mathcal{O}(1)$ 回答每个询问。复杂度 $\\mathcal{O}(n + q)$。\n即转化为DFS序后，利用时间戳找到在DFS序中的位置，子树在DFS序中是连续的一段值。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ const int MAXN = 1e5+5; class Solution { public: vector\u0026lt;int\u0026gt; treeQueries(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; queries) { int time = 0; vector\u0026lt;int\u0026gt; dfsorder(MAXN,0); vector\u0026lt;int\u0026gt; in(MAXN,0), out(MAXN,0), d(MAXN,0); //dfsorder[i] dfs序列 第i个表示 时间i dfs序列上节点的值 //in[i] 时间戳 值为i的节点 的入时间 //out[i] 时间戳 值为i的节点 的出时间 function\u0026lt;void(TreeNode*,int)\u0026gt; dfs=[\u0026amp;](TreeNode* root, int dep)-\u0026gt;void{ in[root-\u0026gt;val] = ++time; dfsorder[time] = root-\u0026gt;val; d[root-\u0026gt;val] = dep; if(root-\u0026gt;left){ dfs(root-\u0026gt;left, dep+1); } if(root-\u0026gt;right){ dfs(root-\u0026gt;right, dep+1); } out[root-\u0026gt;val] = time; }; dfs(root,0); vector\u0026lt;int\u0026gt; f(MAXN, 0),g(MAXN, 0); int n = time; for(int i=1;i\u0026lt;=n;i++){ f[i] = max(f[i-1], d[dfsorder[i]]); } for(int i=n;i\u0026gt;=1;i--){ g[i] = max(g[i+1], d[dfsorder[i]]); } vector\u0026lt;int\u0026gt; res; for(auto \u0026amp;u: queries){ int l = in[u], r = out[u]; res.push_back(max(f[l-1], g[r+1])); } return res; } }; ","date":"2022-11-20T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC317%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20221120_hu957321184425855222.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC317%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第317场周赛总结"},{"content":"没打\nhttps://leetcode.cn/contest/biweekly-contest-90/\n【模拟】差值数组不同的字符串 题目 给你一个字符串数组 words ，每一个字符串长度都相同，令所有字符串的长度都为 n 。\n每个字符串 words[i] 可以被转化为一个长度为 n - 1 的 差值整数数组 difference[i] ，其中对于 0 \u0026lt;= j \u0026lt;= n - 2 有 difference[i][j] = words[i][j+1] - words[i][j] 。注意两个字母的差值定义为它们在字母表中 位置 之差，也就是说 'a' 的位置是 0 ，'b' 的位置是 1 ，'z' 的位置是 25 。\n比方说，字符串 \u0026quot;acb\u0026quot; 的差值整数数组是 [2 - 0, 1 - 2] = [2, -1] 。 words 中所有字符串 除了一个字符串以外 ，其他字符串的差值整数数组都相同。你需要找到那个不同的字符串。\n请你返回 words中 差值整数数组 不同的字符串。\n示例 1：\n1 2 3 4 5 6 7 输入：words = [\u0026#34;adc\u0026#34;,\u0026#34;wzy\u0026#34;,\u0026#34;abc\u0026#34;] 输出：\u0026#34;abc\u0026#34; 解释： - \u0026#34;adc\u0026#34; 的差值整数数组是 [3 - 0, 2 - 3] = [3, -1] 。 - \u0026#34;wzy\u0026#34; 的差值整数数组是 [25 - 22, 24 - 25]= [3, -1] 。 - \u0026#34;abc\u0026#34; 的差值整数数组是 [1 - 0, 2 - 1] = [1, 1] 。 不同的数组是 [1, 1]，所以返回对应的字符串，\u0026#34;abc\u0026#34;。 示例 2：\n1 2 3 输入：words = [\u0026#34;aaa\u0026#34;,\u0026#34;bob\u0026#34;,\u0026#34;ccc\u0026#34;,\u0026#34;ddd\u0026#34;] 输出：\u0026#34;bob\u0026#34; 解释：除了 \u0026#34;bob\u0026#34; 的差值整数数组是 [13, -13] 以外，其他字符串的差值整数数组都是 [0, 0] 。 提示：\n3 \u0026lt;= words.length \u0026lt;= 100 n == words[i].length 2 \u0026lt;= n \u0026lt;= 20 words[i] 只含有小写英文字母。 解题思路 按题意模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: string oddString(vector\u0026lt;string\u0026gt;\u0026amp; words) { int n = words.size(); string res,res2; map\u0026lt;string,int\u0026gt; tab; for(auto \u0026amp;word: words){ char minch = *min_element(word.begin(),word.end()); string tmp = word; for(auto \u0026amp;ch: tmp){ ch = ch-minch+\u0026#39;a\u0026#39;; } // cout\u0026lt;\u0026lt;tmp\u0026lt;\u0026lt;endl; tab[tmp]++; } for(auto \u0026amp;word: words){ char minch = *min_element(word.begin(),word.end()); string tmp = word; for(auto \u0026amp;ch: tmp){ ch = ch-minch+\u0026#39;a\u0026#39;; } if(tab[tmp]==1){ res = word; break; } } return res; } }; 【枚举】距离字典两次编辑以内的单词 题目 给你两个字符串数组 queries 和 dictionary 。数组中所有单词都只包含小写英文字母，且长度都相同。\n一次 编辑 中，你可以从 queries 中选择一个单词，将任意一个字母修改成任何其他字母。从 queries 中找到所有满足以下条件的字符串：不超过 两次编辑内，字符串与 dictionary 中某个字符串相同。\n请你返回 queries 中的单词列表，这些单词距离 dictionary 中的单词 编辑次数 不超过 两次 。单词返回的顺序需要与 queries 中原本顺序相同。\n示例 1：\n1 2 3 4 5 6 7 8 输入：queries = [\u0026#34;word\u0026#34;,\u0026#34;note\u0026#34;,\u0026#34;ants\u0026#34;,\u0026#34;wood\u0026#34;], dictionary = [\u0026#34;wood\u0026#34;,\u0026#34;joke\u0026#34;,\u0026#34;moat\u0026#34;] 输出：[\u0026#34;word\u0026#34;,\u0026#34;note\u0026#34;,\u0026#34;wood\u0026#34;] 解释： - 将 \u0026#34;word\u0026#34; 中的 \u0026#39;r\u0026#39; 换成 \u0026#39;o\u0026#39; ，得到 dictionary 中的单词 \u0026#34;wood\u0026#34; 。 - 将 \u0026#34;note\u0026#34; 中的 \u0026#39;n\u0026#39; 换成 \u0026#39;j\u0026#39; 且将 \u0026#39;t\u0026#39; 换成 \u0026#39;k\u0026#39; ，得到 \u0026#34;joke\u0026#34; 。 - \u0026#34;ants\u0026#34; 需要超过 2 次编辑才能得到 dictionary 中的单词。 - \u0026#34;wood\u0026#34; 不需要修改（0 次编辑），就得到 dictionary 中相同的单词。 所以我们返回 [\u0026#34;word\u0026#34;,\u0026#34;note\u0026#34;,\u0026#34;wood\u0026#34;] 。 示例 2：\n1 2 3 4 5 输入：queries = [\u0026#34;yes\u0026#34;], dictionary = [\u0026#34;not\u0026#34;] 输出：[] 解释： \u0026#34;yes\u0026#34; 需要超过 2 次编辑才能得到 \u0026#34;not\u0026#34; 。 所以我们返回空数组。 提示：\n1 \u0026lt;= queries.length, dictionary.length \u0026lt;= 100 n == queries[i].length == dictionary[j].length 1 \u0026lt;= n \u0026lt;= 100 所有 queries[i] 和 dictionary[j] 都只包含小写英文字母。 解题思路 就是找不同字符的个数\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;string\u0026gt; twoEditWords(vector\u0026lt;string\u0026gt;\u0026amp; queries, vector\u0026lt;string\u0026gt;\u0026amp; dictionary) { vector\u0026lt;string\u0026gt; res; for(auto \u0026amp;query: queries){ bool flag = false; for(auto \u0026amp;words: dictionary){ if(query.size()!=words.size()) continue; int diff = 0; for(int i=0;i\u0026lt;query.size();i++){ if(query[i]!=words[i]) diff++; if(diff\u0026gt;2) break; } if(diff\u0026lt;=2) { flag = true; break; } } if(flag) res.push_back(query); } return res; } }; 【枚举+数学】摧毁一系列目标 题目 给你一个下标从 0 开始的数组 nums ，它包含若干正整数，表示数轴上你需要摧毁的目标所在的位置。同时给你一个整数 space 。\n你有一台机器可以摧毁目标。给机器 输入 nums[i] ，这台机器会摧毁所有位置在 nums[i] + c * space 的目标，其中 c 是任意非负整数。你想摧毁 nums 中 尽可能多 的目标。\n请你返回在摧毁数目最多的前提下，nums[i] 的 最小值 。\n示例 1：\n1 2 3 4 5 输入：nums = [3,7,8,1,1,5], space = 2 输出：1 解释：如果我们输入 nums[3] ，我们可以摧毁位于 1,3,5,7,9,... 这些位置的目标。 这种情况下， 我们总共可以摧毁 5 个目标（除了 nums[2]）。 没有办法摧毁多于 5 个目标，所以我们返回 nums[3] 。 示例 2：\n1 2 3 4 5 输入：nums = [1,3,5,2,4,6], space = 2 输出：1 解释：输入 nums[0] 或者 nums[3] 都会摧毁 3 个目标。 没有办法摧毁多于 3 个目标。 由于 nums[0] 是最小的可以摧毁 3 个目标的整数，所以我们返回 1 。 示例 3：\n1 2 3 输入：nums = [6,2,5], space = 100 输出：2 解释：无论我们输入哪个数字，都只能摧毁 1 个目标。输入的最小整数是 nums[1] 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^9 1 \u0026lt;= space \u0026lt;= 10^9 解题思路 将 nums 里的所有数按 nums[i] % space 分组。只要选择每一组里最小的数，就能摧毁整组。\n和顺序无关，可以先对数组排序，第一次找到最多的即最小值\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int destroyTargets(vector\u0026lt;int\u0026gt;\u0026amp; nums, int space) { int n = nums.size(); sort(nums.begin(),nums.end()); unordered_map\u0026lt;int,int\u0026gt; tab; vector\u0026lt;int\u0026gt; a(nums.begin(),nums.end()); for(auto \u0026amp;x: a) x = x%space; int maxcnt=0; for(int i=0;i\u0026lt;n;i++){ tab[a[i]]++; if(tab[a[i]]\u0026gt;maxcnt){ maxcnt = tab[a[i]]; } } int res; for(int i=0;i\u0026lt;n;i++){ if(maxcnt == tab[a[i]]){ res = nums[i]; break; } } return res; } }; 【单调栈+优先队列】下一个更大元素 IV 题目 给你一个下标从 0 开始的非负整数数组 nums 。对于 nums 中每一个整数，你必须找到对应元素的 第二大 整数。\n如果 nums[j] 满足以下条件，那么我们称它为 nums[i] 的 第二大 整数：\nj \u0026gt; i nums[j] \u0026gt; nums[i] 恰好存在 一个 k 满足 i \u0026lt; k \u0026lt; j 且 nums[k] \u0026gt; nums[i] 。 如果不存在 nums[j] ，那么第二大整数为 -1 。\n比方说，数组 [1, 2, 4, 3] 中，1 的第二大整数是 4 ，2 的第二大整数是 3 ，3 和 4 的第二大整数是 -1 。 请你返回一个整数数组 answer ，其中 answer[i]是 nums[i] 的第二大整数。\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：nums = [2,4,0,9,6] 输出：[9,6,6,-1,-1] 解释： 下标为 0 处：2 的右边，4 是大于 2 的第一个整数，9 是第二个大于 2 的整数。 下标为 1 处：4 的右边，9 是大于 4 的第一个整数，6 是第二个大于 4 的整数。 下标为 2 处：0 的右边，9 是大于 0 的第一个整数，6 是第二个大于 0 的整数。 下标为 3 处：右边不存在大于 9 的整数，所以第二大整数为 -1 。 下标为 4 处：右边不存在大于 6 的整数，所以第二大整数为 -1 。 所以我们返回 [9,6,6,-1,-1] 。 示例 2：\n1 2 3 4 输入：nums = [3,3] 输出：[-1,-1] 解释： 由于每个数右边都没有更大的数，所以我们返回 [-1,-1] 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 0 \u0026lt;= nums[i] \u0026lt;= 10^9 解题思路 如果是右侧第一个更大元素，很显然是单调栈的模板题。但之前写右侧第一个更大元素的单调栈，都是从右侧开始遍历。其实也可以从左侧遍历。从左侧遍历可能更好。\n这题用单调栈的话，也需要从左侧开始遍历才好。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public: vector\u0026lt;int\u0026gt; secondGreaterElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); stack\u0026lt;int\u0026gt; stk; vector\u0026lt;int\u0026gt; R(n, -1); //右侧第一个更大元素的位置 // for(int i=0;i\u0026lt;n;i++){ // while(!stk.empty() \u0026amp;\u0026amp; nums[i]\u0026gt;nums[stk.top()]){ // R[stk.top()] = i; // stk.pop(); // } // stk.push(i); // } //如果是右侧第二个更大元素的位置呢 //pq中元素 first: 值 second: 索引 堆顶元素为最小值 priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;,vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;,greater\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;\u0026gt; pq; for(int i=0;i\u0026lt;n;i++){ while(!pq.empty() \u0026amp;\u0026amp; nums[i]\u0026gt;pq.top().first){ R[pq.top().second] = nums[i]; pq.pop(); } while(!stk.empty() \u0026amp;\u0026amp; nums[i]\u0026gt;nums[stk.top()]){ //nums[stk.top()]的右侧第一个更大元素为nums[i] //将nums[stk.top]存下来，可能有右侧第二个更大元素 pq.emplace(nums[stk.top()],stk.top()); stk.pop(); } stk.push(i); } return R; } }; ","date":"2022-11-14T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC90%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20221114_hu7284974598528980120.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC90%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第90场双周赛总结"},{"content":"\n【模拟】判断两个事件是否存在冲突 题目 给你两个字符串数组 event1 和 event2 ，表示发生在同一天的两个闭区间时间段事件，其中：\nevent1 = [startTime1, endTime1] 且 event2 = [startTime2, endTime2] 事件的时间为有效的 24 小时制且按 HH:MM 格式给出。\n当两个事件存在某个非空的交集时（即，某些时刻是两个事件都包含的），则认为出现 冲突 。\n如果两个事件之间存在冲突，返回 true ；否则，返回 false 。\n示例 1：\n1 2 3 输入：event1 = [\u0026#34;01:15\u0026#34;,\u0026#34;02:00\u0026#34;], event2 = [\u0026#34;02:00\u0026#34;,\u0026#34;03:00\u0026#34;] 输出：true 解释：两个事件在 2:00 出现交集。 示例 2：\n1 2 3 输入：event1 = [\u0026#34;01:00\u0026#34;,\u0026#34;02:00\u0026#34;], event2 = [\u0026#34;01:20\u0026#34;,\u0026#34;03:00\u0026#34;] 输出：true 解释：两个事件的交集从 01:20 开始，到 02:00 结束。 示例 3：\n1 2 3 输入：event1 = [\u0026#34;10:00\u0026#34;,\u0026#34;11:00\u0026#34;], event2 = [\u0026#34;14:00\u0026#34;,\u0026#34;15:00\u0026#34;] 输出：false 解释：两个事件不存在交集。 提示：\nevnet1.length == event2.length == 2. event1[i].length == event2[i].length == 5 startTime1 \u0026lt;= endTime1 startTime2 \u0026lt;= endTime2 所有事件的时间都按照 HH:MM 格式给出 解题思路 判断两个区间是否相交\n其实直接比较字符串大小即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long class Solution { public: int fun(string s){ int res = 0; res += s[4]-\u0026#39;0\u0026#39;; res += 10*(s[3]-\u0026#39;0\u0026#39;); int x = ((s[0]-\u0026#39;0\u0026#39;)*10 + (s[1]-\u0026#39;0\u0026#39;)); res += x*60; return res; } bool haveConflict(vector\u0026lt;string\u0026gt;\u0026amp; event1, vector\u0026lt;string\u0026gt;\u0026amp; event2) { int x1 = fun(event1[0]),x2 = fun(event1[1]); int y1 = fun(event2[0]),y2 = fun(event2[1]); if(x1\u0026gt;y2 || x2\u0026lt;y1) return false; return true; } }; 【枚举+gcd】最大公因数等于 K 的子数组数目 题目 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 nums 的子数组中元素的最大公因数等于 k 的子数组数目。\n子数组 是数组中一个连续的非空序列。\n数组的最大公因数 是能整除数组中所有元素的最大整数。\n示例 1：\n1 2 3 4 5 6 7 输入：nums = [9,3,1,2,6,3], k = 3 输出：4 解释：nums 的子数组中，以 3 作为最大公因数的子数组如下： - [9,3,1,2,6,3] - [9,3,1,2,6,3] - [9,3,1,2,6,3] - [9,3,1,2,6,3] 示例 2：\n1 2 3 输入：nums = [4], k = 7 输出：0 解释：不存在以 7 作为最大公因数的子数组。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 1000 1 \u0026lt;= nums[i], k \u0026lt;= 10^9 解题思路 枚举子数组并计算最大公因数即可\n可惜一开始想太简单了 WA了两发\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long class Solution { public: int subarrayGCD(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); int res = 0; for(int i=0;i\u0026lt;n;i++){ if(nums[i] == k) res++; int g = nums[i]; for(int j=i-1;j\u0026gt;=0;j--){ if(__gcd(g,nums[j])==k) { res++; } g = __gcd(g,nums[j]); } } return res; } }; 【枚举+数学】使数组相等的最小开销 题目 给你两个下标从 0 开始的数组 nums 和 cost ，分别包含 n 个 正 整数。\n你可以执行下面操作 任意 次：\n将 nums 中 任意 元素增加或者减小 1 。 对第 i 个元素执行一次操作的开销是 cost[i] 。\n请你返回使 nums 中所有元素 相等 的 最少 总开销。\n示例 1：\n1 2 3 4 5 6 7 8 输入：nums = [1,3,5,2], cost = [2,3,1,14] 输出：8 解释：我们可以执行以下操作使所有元素变为 2 ： - 增加第 0 个元素 1 次，开销为 2 。 - 减小第 1 个元素 1 次，开销为 3 。 - 减小第 2 个元素 3 次，开销为 1 + 1 + 1 = 3 。 总开销为 2 + 3 + 3 = 8 。 这是最小开销。 示例 2：\n1 2 3 输入：nums = [2,2,2,2,2], cost = [4,2,8,1,3] 输出：0 解释：数组中所有元素已经全部相等，不需要执行额外的操作。 提示：\nn == nums.length == cost.length 1 \u0026lt;= n \u0026lt;= 10^5 1 \u0026lt;= nums[i], cost[i] \u0026lt;= 10^6 解题思路 可以对nums数组进行排序，枚举将所有元素都变为num[i]所需的cost\n考虑一步到下一步所需的cost的变化即可 可发现数学规律\nRE了一发是 int溢出 记得多乘个1ll\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long class Solution { public: long long minCost(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;int\u0026gt;\u0026amp; cost) { int n = nums.size(); vector\u0026lt;int\u0026gt; idx(n); iota(idx.begin(),idx.end(),0); sort(idx.begin(),idx.end(),[\u0026amp;](int a,int b){ return nums[a]\u0026lt;nums[b]; }); ll sum = 0; for(auto \u0026amp;x: cost) sum += x; ll res = 0, u = 0; for(int i=0;i\u0026lt;n;i++){ u += 1ll*(nums[idx[i]]-nums[idx[0]])*cost[idx[i]]; } res = u; ll head = cost[idx[0]], tail = sum - head; for(int i=1;i\u0026lt;n;i++){ ll diff = nums[idx[i]] - nums[idx[i-1]]; u += diff * head; u -= diff * tail; head += cost[idx[i]]; tail -= cost[idx[i]]; res = min(res, u); } return res; } }; 【贪心+排序】使数组相似的最少操作次数 题目 给你两个正整数数组 nums 和 target ，两个数组长度相等。\n在一次操作中，你可以选择两个 不同 的下标 i 和 j ，其中 0 \u0026lt;= i, j \u0026lt; nums.length ，并且：\n令 nums[i] = nums[i] + 2 且 令 nums[j] = nums[j] - 2 。 如果两个数组中每个元素出现的频率相等，我们称两个数组是 相似 的。\n请你返回将 nums 变得与 target 相似的最少操作次数。测试数据保证 nums 一定能变得与 target 相似。\n示例 1：\n1 2 3 4 5 6 输入：nums = [8,12,6], target = [2,14,10] 输出：2 解释：可以用两步操作将 nums 变得与 target 相似： - 选择 i = 0 和 j = 2 ，nums = [10,12,4] 。 - 选择 i = 1 和 j = 2 ，nums = [10,14,2] 。 2 次操作是最少需要的操作次数。 示例 2：\n1 2 3 4 输入：nums = [1,2,5], target = [4,1,3] 输出：1 解释：一步操作可以使 nums 变得与 target 相似： - 选择 i = 1 和 j = 2 ，nums = [1,4,3] 。 示例 3：\n1 2 3 输入：nums = [1,1,1,1,1], target = [1,1,1,1,1] 输出：0 解释：数组 nums 已经与 target 相似。 提示：\nn == nums.length == target.length 1 \u0026lt;= n \u0026lt;= 10^5 1 \u0026lt;= nums[i], target[i] \u0026lt;= 10^6 nums 一定可以变得与 target 相似。 解题思路 每次加减2操作不改变奇偶性，所以可以分别对奇偶进行讨论\n贪心的想，对原数组和目标数组进行排序后，一一对应，增的操作次数一定和减的操作次数相等\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Solution { public: long long makeSimilar(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;int\u0026gt;\u0026amp; target) { vector\u0026lt;int\u0026gt; nums1,nums2,target1,target2; for(auto \u0026amp;x: nums){ if(x\u0026amp;1) nums1.push_back(x); else nums2.push_back(x); } for(auto \u0026amp;x: target){ if(x\u0026amp;1) target1.push_back(x); else target2.push_back(x); } sort(nums1.begin(),nums1.end()); sort(nums2.begin(),nums2.end()); sort(target1.begin(),target1.end()); sort(target2.begin(),target2.end()); long long u=0,v=0; for(int i=0;i\u0026lt;nums1.size();i++){ if(nums1[i]\u0026gt;target1[i]){ u += (nums1[i]-target1[i])/2; } } for(int i=0;i\u0026lt;nums2.size();i++){ if(nums2[i]\u0026gt;target2[i]){ v += (nums2[i]-target2[i])/2; } } return u+v; } }; ","date":"2022-10-29T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC316%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20221029_hu7969590027360486842.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC316%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第316场周赛总结"},{"content":"没打\n【模拟】与对应负数同时存在的最大正整数 题目 给你一个 不包含 任何零的整数数组 nums ，找出自身与对应的负数都在数组中存在的最大正整数 k 。\n返回正整数 k ，如果不存在这样的整数，返回 -1 。\n示例 1：\n1 2 3 输入：nums = [-1,2,-3,3] 输出：3 解释：3 是数组中唯一一个满足题目要求的 k 。 示例 2：\n1 2 3 输入：nums = [-1,10,6,7,-7,1] 输出：7 解释：数组中存在 1 和 7 对应的负数，7 的值更大。 示例 3：\n1 2 3 输入：nums = [-10,8,6,7,-2,-3] 输出：-1 解释：不存在满足题目要求的 k ，返回 -1 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 1000 -1000 \u0026lt;= nums[i] \u0026lt;= 1000 nums[i] != 0 解题思路 按题意模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int findMaxK(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int res = -1; unordered_set\u0026lt;int\u0026gt; tab; for(auto \u0026amp;x:nums) tab.insert(x); for(auto \u0026amp;x: nums){ if(x\u0026gt;0 \u0026amp;\u0026amp; tab.count(-x)) res = max(res, x); } return res; } }; 【模拟】反转之后不同整数的数目 题目 给你一个由 正 整数组成的数组 nums 。\n你必须取出数组中的每个整数，反转其中每个数位，并将反转后得到的数字添加到数组的末尾。这一操作只针对 nums 中原有的整数执行。\n返回结果数组中 不同 整数的数目。\n示例 1：\n1 2 3 4 5 输入：nums = [1,13,10,12,31] 输出：6 解释：反转每个数字后，结果数组是 [1,13,10,12,31,1,31,1,21,13] 。 反转后得到的数字添加到数组的末尾并按斜体加粗表示。注意对于整数 10 ，反转之后会变成 01 ，即 1 。 数组中不同整数的数目为 6（数字 1、10、12、13、21 和 31）。 示例 2：\n1 2 3 4 输入：nums = [2,2,2] 输出：1 解释：反转每个数字后，结果数组是 [2,2,2,2,2,2] 。 数组中不同整数的数目为 1（数字 2）。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^6 解题思路 按题意模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int countDistinctIntegers(vector\u0026lt;int\u0026gt;\u0026amp; nums) { set\u0026lt;int\u0026gt; tab; for(auto x: nums){ tab.insert(x); int u = 0; while(x){ int tail = x%10; x = x/10; u = 10*u + tail; } tab.insert(u); } return tab.size(); } }; 【枚举】反转之后的数字和 题目 给你一个 非负 整数 num 。如果存在某个 非负 整数 k 满足 k + reverse(k) = num ，则返回 true ；否则，返回 false 。\nreverse(k) 表示 k 反转每个数位后得到的数字。\n示例 1：\n1 2 3 输入：num = 443 输出：true 解释：172 + 271 = 443 ，所以返回 true 。 示例 2：\n1 2 3 输入：num = 63 输出：false 解释：63 不能表示为非负整数及其反转后数字之和，返回 false 。 示例 3：\n1 2 3 输入：num = 181 输出：true 解释：140 + 041 = 181 ，所以返回 true 。注意，反转后的数字可能包含前导零。 提示：\n0 \u0026lt;= num \u0026lt;= 10^5 解题思路 枚举即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int rev(int num){ int res = 0; while(num){ res = 10*res+num%10; num/=10; } return res; } bool sumOfNumberAndReverse(int num) { for(int i=0;i\u0026lt;=num;i++){ if(i+rev(i) == num) return true; } return false; } }; 【枚举+统计子数组】统计定界子数组的数目 题目 给你一个整数数组 nums 和两个整数 minK 以及 maxK 。\nnums 的定界子数组是满足下述条件的一个子数组：\n子数组中的 最小值 等于 minK 。 子数组中的 最大值 等于 maxK 。 返回定界子数组的数目。\n子数组是数组中的一个连续部分。\n示例 1：\n1 2 3 输入：nums = [1,3,5,2,7,5], minK = 1, maxK = 5 输出：2 解释：定界子数组是 [1,3,5] 和 [1,3,5,2] 。 示例 2：\n1 2 3 输入：nums = [1,1,1,1], minK = 1, maxK = 1 输出：10 解释：nums 的每个子数组都是一个定界子数组。共有 10 个子数组。 提示：\n2 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i], minK, maxK \u0026lt;= 10^6 解题思路 考虑以nums[i]结尾的合法数组，是否合法取决于：[0..i]范围内的minK、maxK出现情况，以及[minK, maxK]范围之外的数的出现情况\n那么，维护三个东西：存储minK出现位置的数组，存储maxK出现位置的数组，存储范围之外的数出现位置的数组\n（实际上，只需要维护出现的最后一个位置即可）\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: long long countSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int minK, int maxK) { int n = nums.size(); vector\u0026lt;int\u0026gt; minvec,maxvec,outvec; long long res = 0; for(int i=0;i\u0026lt;n;i++){ if(nums[i]\u0026lt;minK || nums[i]\u0026gt;maxK){ outvec.push_back(i); minvec.clear(); maxvec.clear(); continue; } if(nums[i] == minK) { minvec.push_back(i); } if(nums[i] == maxK) { maxvec.push_back(i); } if(minvec.empty() || maxvec.empty()) continue; int x = outvec.empty()?-1:outvec.back(); int u = min(minvec.back(), maxvec.back()); // cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;u-x\u0026lt;\u0026lt;endl; res += u-x; } return res; } }; 偷学代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: long long countSubarrays(vector\u0026lt;int\u0026gt; \u0026amp;nums, int min_k, int max_k) { long long ans = 0L; int n = nums.size(), min_i = -1, max_i = -1, i0 = -1; for (int i = 0; i \u0026lt; n; ++i) { int x = nums[i]; if (x == min_k) min_i = i; if (x == max_k) max_i = i; if (x \u0026lt; min_k || x \u0026gt; max_k) i0 = i; // 子数组不能包含 nums[i0] ans += max(min(min_i, max_i) - i0, 0); } return ans; } }; ","date":"2022-10-23T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC315%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20221023_hu3474600828205037491.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC315%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第315场周赛总结"},{"content":"没打\n【枚举】有效时间的数目 题目 给你一个长度为 5 的字符串 time ，表示一个电子时钟当前的时间，格式为 \u0026quot;hh:mm\u0026quot; 。最早 可能的时间是 \u0026quot;00:00\u0026quot; ，最晚 可能的时间是 \u0026quot;23:59\u0026quot; 。\n在字符串 time 中，被字符 ? 替换掉的数位是 未知的 ，被替换的数字可能是 0 到 9 中的任何一个。\n请你返回一个整数 answer ，将每一个 ? 都用 0 到 9 中一个数字替换后，可以得到的有效时间的数目。\n示例 1：\n1 2 3 输入：time = \u0026#34;?5:00\u0026#34; 输出：2 解释：我们可以将 ? 替换成 0 或 1 ，得到 \u0026#34;05:00\u0026#34; 或者 \u0026#34;15:00\u0026#34; 。注意我们不能替换成 2 ，因为时间 \u0026#34;25:00\u0026#34; 是无效时间。所以我们有两个选择。 示例 2：\n1 2 3 输入：time = \u0026#34;0?:0?\u0026#34; 输出：100 解释：两个 ? 都可以被 0 到 9 之间的任意数字替换，所以我们总共有 100 种选择。 示例 3：\n1 2 3 输入：time = \u0026#34;??:??\u0026#34; 输出：1440 解释：小时总共有 24 种选择，分钟总共有 60 种选择。所以总共有 24 * 60 = 1440 种选择。 提示：\ntime 是一个长度为 5 的有效字符串，格式为 \u0026quot;hh:mm\u0026quot; 。 \u0026quot;00\u0026quot; \u0026lt;= hh \u0026lt;= \u0026quot;23\u0026quot; \u0026quot;00\u0026quot; \u0026lt;= mm \u0026lt;= \u0026quot;59\u0026quot; 字符串中有的数位是 '?' ，需要用 0 到 9 之间的数字替换。 解题思路 枚举即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public: int trans(string time){ int res = 0; res += time[4]-\u0026#39;0\u0026#39;; if(time[3]\u0026gt;\u0026#39;5\u0026#39;) return -1; res += (time[3]-\u0026#39;0\u0026#39;)*10; int hour = 10*(time[0]-\u0026#39;0\u0026#39;)+(time[1]-\u0026#39;0\u0026#39;); if(time[0]\u0026gt;\u0026#39;2\u0026#39;) return -1; if(time[0]==\u0026#39;2\u0026#39; \u0026amp;\u0026amp; time[1]\u0026gt;\u0026#39;3\u0026#39;) return -1; res += hour*60; return res; } int countTime(string time) { vector\u0026lt;int\u0026gt; a(5,0); for(int i=0;i\u0026lt;5;i++){ if(time[i]==\u0026#39;?\u0026#39;) a[i] = 1; } int res = 0; function\u0026lt;void(int,string)\u0026gt; dfs = [\u0026amp;](int pos,string ctime)-\u0026gt;void{ if(pos==5){ // cout\u0026lt;\u0026lt;ctime\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;trans(ctime)\u0026lt;\u0026lt;endl; if(trans(ctime)\u0026gt;-1 \u0026amp;\u0026amp; trans(ctime)\u0026lt;=1440) res++; return; } if(a[pos]){ for(int d=0;d\u0026lt;10;d++){ ctime[pos] = char(d+\u0026#39;0\u0026#39;); dfs(pos+1, ctime); } }else dfs(pos+1,ctime); return; }; dfs(0,time); return res; } }; 【快速幂】二的幂数组中查询范围内的乘积 题目 给你一个正整数 n ，你需要找到一个下标从 0 开始的数组 powers ，它包含 最少 数目的 2 的幂，且它们的和为 n 。powers 数组是 非递减 顺序的。根据前面描述，构造 powers 数组的方法是唯一的。\n同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, righti] ，其中 queries[i] 表示请你求出满足 lefti \u0026lt;= j \u0026lt;= righti 的所有 powers[j] 的乘积。\n请你返回一个数组 answers ，长度与 queries 的长度相同，其中 answers[i]是第 i 个查询的答案。由于查询的结果可能非常大，请你将每个 answers[i] 都对 109 + 7 取余 。\n示例 1：\n1 2 3 4 5 6 7 8 输入：n = 15, queries = [[0,1],[2,2],[0,3]] 输出：[2,4,64] 解释： 对于 n = 15 ，得到 powers = [1,2,4,8] 。没法得到元素数目更少的数组。 第 1 个查询的答案：powers[0] * powers[1] = 1 * 2 = 2 。 第 2 个查询的答案：powers[2] = 4 。 第 3 个查询的答案：powers[0] * powers[1] * powers[2] * powers[3] = 1 * 2 * 4 * 8 = 64 。 每个答案对 109 + 7 得到的结果都相同，所以返回 [2,4,64] 。 示例 2：\n1 2 3 4 5 输入：n = 2, queries = [[0,0]] 输出：[2] 解释： 对于 n = 2, powers = [2] 。 唯一一个查询的答案是 powers[0] = 2 。答案对 109 + 7 取余后结果相同，所以返回 [2] 。 提示：\n1 \u0026lt;= n \u0026lt;= 10^9 1 \u0026lt;= queries.length \u0026lt;= 10^5 0 \u0026lt;= starti \u0026lt;= endi \u0026lt; powers.length 解题思路 预处理出2的幂的指数的前缀和 再利用快速幂即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #define ll long long class Solution { public: ll quickpower(ll x,ll y,int mod){//x^y % mod ll res = 1; while(y\u0026gt;0){ if(y\u0026amp;1) res = (res*x)%mod; x = (x*x)%mod; y\u0026gt;\u0026gt;=1; } return res; } vector\u0026lt;int\u0026gt; productQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;int\u0026gt; powers; for(int i=0;i\u0026lt;32;i++){ if((n\u0026gt;\u0026gt;i)\u0026amp;1) powers.push_back(i); } // for(auto \u0026amp;x: powers) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;; int m = powers.size(); vector\u0026lt;int\u0026gt; sum(m+1,0),res; for(int i=1;i\u0026lt;=m;i++) sum[i] = sum[i-1]+powers[i-1]; for(auto \u0026amp;vec: queries){ int cnt = sum[vec[1]+1]-sum[vec[0]]; res.push_back(quickpower(2,cnt,1e9+7)); } return res; } }; 【二分】最小化数组中的最大值 题目 给你一个下标从 0 开始的数组 nums ，它含有 n 个非负整数。\n每一步操作中，你需要：\n选择一个满足 1 \u0026lt;= i \u0026lt; n 的整数 i ，且 nums[i] \u0026gt; 0 。 将 nums[i] 减 1 。 将 nums[i - 1] 加 1 。 你可以对数组执行 任意 次上述操作，请你返回可以得到的 nums 数组中 最大值 最小 为多少。\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：nums = [3,7,1,6] 输出：5 解释： 一串最优操作是： 1. 选择 i = 1 ，nums 变为 [4,6,1,6] 。 2. 选择 i = 3 ，nums 变为 [4,6,2,5] 。 3. 选择 i = 1 ，nums 变为 [5,5,2,5] 。 nums 中最大值为 5 。无法得到比 5 更小的最大值。 所以我们返回 5 。 示例 2：\n1 2 3 4 输入：nums = [10,1] 输出：10 解释： 最优解是不改动 nums ，10 是最大值，所以返回 10 。 提示：\nn == nums.length 2 \u0026lt;= n \u0026lt;= 10^5 0 \u0026lt;= nums[i] \u0026lt;= 10^9 解题思路 最小化最大值 想到二分，即二分这个最大值res\nres的可从[0, maxv]二分搜索\n在O(n)时间内判断最大值为res时是否合法\n每次操作是将后一个元素减1，加到前一个元素上\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long class Solution { public: int minimizeArrayValue(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); function\u0026lt;bool(int)\u0026gt; isok = [\u0026amp;](int k)-\u0026gt;bool{ ll rst = 0; for(int i=n-1;i\u0026gt;=1;i--){ if(rst + nums[i] \u0026gt; k) rst = rst + nums[i] - k; else rst = 0; } if(nums[0]+rst\u0026gt;k) return false; else return true; }; int l = 0, r = *max_element(nums.begin(),nums.end()); while(l\u0026lt;r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(isok(mid)) r = mid; else l=mid+1; } return r; } }; 【枚举+dfs树上统计】创建价值相同的连通块 题目 有一棵 n 个节点的无向树，节点编号为 0 到 n - 1 。\n给你一个长度为 n 下标从 0 开始的整数数组 nums ，其中 nums[i] 表示第 i 个节点的值。同时给你一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示节点 ai 与 bi 之间有一条边。\n你可以 删除 一些边，将这棵树分成几个连通块。一个连通块的 价值 定义为这个连通块中 所有 节点 i 对应的 nums[i] 之和。\n你需要删除一些边，删除后得到的各个连通块的价值都相等。请返回你可以删除的边数 最多 为多少。\n示例 1：\n1 2 3 输入：nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] 输出：2 解释：上图展示了我们可以删除边 [0,1] 和 [3,4] 。得到的连通块为 [0] ，[1,2,3] 和 [4] 。每个连通块的价值都为 6 。可以证明没有别的更好的删除方案存在了，所以答案为 2 。 示例 2：\n1 2 3 输入：nums = [2], edges = [] 输出：0 解释：没有任何边可以删除。 提示：\n1 \u0026lt;= n \u0026lt;= 2 * 10^4 nums.length == n 1 \u0026lt;= nums[i] \u0026lt;= 50 edges.length == n - 1 edges[i].length == 2 0 \u0026lt;= edges[i][0], edges[i][1] \u0026lt;= n - 1 edges 表示一棵合法的树。 解题思路 主要思路是枚举可以划分的联通块块数\n所有权值的和sum最大为10^6，可以划分的联通块的权值即是sum的因子，数字x的因子个数可近似估计为x开立方。实际上10^6的因子个数为240。\n那么枚举sum的因子target，然后再在O(n)时间内判断是否可以划分出权值总和为target的连通块即可\n利用dfs在树上统计，详见代码\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: int componentValue(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { int n = nums.size(); vector\u0026lt;int\u0026gt; G[n]; for(auto \u0026amp;vec: edges){ G[vec[0]].push_back(vec[1]); G[vec[1]].push_back(vec[0]); } int sum = accumulate(nums.begin(),nums.end(),0); function\u0026lt;int(int,int,int)\u0026gt; dfs = [\u0026amp;](int u, int fa, int target)-\u0026gt;int{ int s = nums[u]; for(auto \u0026amp;v: G[u]){ if(v == fa) continue; int ss = dfs(v,u,target); if(ss==-1) return -1; s += ss; } if(s == target) return 0;//连通块总和为target，赋值为0表示删去 else if(s\u0026gt;target) return -1;//连通块总和大于target，肯定有一个连通块权值和大于target了，非法 return s; };//以u为根节点的子树，是否可以分成价值总和为target的连通块，等于则0 for(int i=n;i\u0026gt;=1;i--){//枚举分成i个联通块 if(sum%i==0){ if(dfs(0,-1, sum/i) == 0){ return i-1; } } } return 0; } }; ","date":"2022-10-20T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC89%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20221020_hu12198363334045160678.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC89%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第89场双周赛总结"},{"content":"\n【模拟】处理用时最长的那个任务的员工 题目 共有 n 位员工，每位员工都有一个从 0 到 n - 1 的唯一 id 。\n给你一个二维整数数组 logs ，其中 logs[i] = [idi, leaveTimei] ：\nidi 是处理第 i 个任务的员工的 id ，且 leaveTimei 是员工完成第 i 个任务的时刻。所有 leaveTimei 的值都是 唯一 的。 注意，第 i 个任务在第 (i - 1) 个任务结束后立即开始，且第 0 个任务从时刻 0 开始。\n返回处理用时最长的那个任务的员工的 id 。如果存在两个或多个员工同时满足，则返回几人中 最小 的 id 。\n示例 1：\n1 2 3 4 5 6 7 8 输入：n = 10, logs = [[0,3],[2,5],[0,9],[1,15]] 输出：1 解释： 任务 0 于时刻 0 开始，且在时刻 3 结束，共计 3 个单位时间。 任务 1 于时刻 3 开始，且在时刻 5 结束，共计 2 个单位时间。 任务 2 于时刻 5 开始，且在时刻 9 结束，共计 4 个单位时间。 任务 3 于时刻 9 开始，且在时刻 15 结束，共计 6 个单位时间。 时间最长的任务是任务 3 ，而 id 为 1 的员工是处理此任务的员工，所以返回 1 。 示例 2：\n1 2 3 4 5 6 7 8 输入：n = 26, logs = [[1,1],[3,7],[2,12],[7,17]] 输出：3 解释： 任务 0 于时刻 0 开始，且在时刻 1 结束，共计 1 个单位时间。 任务 1 于时刻 1 开始，且在时刻 7 结束，共计 6 个单位时间。 任务 2 于时刻 7 开始，且在时刻 12 结束，共计 5 个单位时间。 任务 3 于时刻 12 开始，且在时刻 17 结束，共计 5 个单位时间。 时间最长的任务是任务 1 ，而 id 为 3 的员工是处理此任务的员工，所以返回 3 。 示例 3：\n1 2 3 4 5 6 输入：n = 2, logs = [[0,10],[1,20]] 输出：0 解释： 任务 0 于时刻 0 开始，且在时刻 10 结束，共计 10 个单位时间。 任务 1 于时刻 10 开始，且在时刻 20 结束，共计 10 个单位时间。 时间最长的任务是任务 0 和 1 ，处理这两个任务的员工的 id 分别是 0 和 1 ，所以返回最小的 0 。 提示：\n2 \u0026lt;= n \u0026lt;= 500 1 \u0026lt;= logs.length \u0026lt;= 500 logs[i].length == 2 0 \u0026lt;= idi \u0026lt;= n - 1 1 \u0026lt;= leaveTimei \u0026lt;= 500 idi != idi + 1 leaveTimei 按严格递增顺序排列 解题思路 按题意模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Solution { public: int hardestWorker(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; logs) { vector\u0026lt;int\u0026gt; dp(n,0); int m = logs.size(); dp[logs[0][0]] = logs[0][1]; int last = logs[0][1]; for(int i=1;i\u0026lt;m;i++){ dp[logs[i][0]] = max(dp[logs[i][0]],logs[i][1]-last); last = logs[i][1]; } int maxv = dp[n-1], res = n-1; for(int i=n-2;i\u0026gt;=0;i--){ if(dp[i]\u0026gt;=maxv){ maxv = dp[i]; res = i; } } return res; } }; 【位运算/异或】找出前缀异或的原始数组 题目 给你一个长度为 n 的 整数 数组 pref 。找出并返回满足下述条件且长度为 n 的数组 arr ：\npref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]. 注意 ^ 表示 按位异或（bitwise-xor）运算。\n可以证明答案是 唯一 的。\n示例 1：\n1 2 3 4 5 6 7 8 输入：pref = [5,2,0,3,1] 输出：[5,7,2,3,2] 解释：从数组 [5,7,2,3,2] 可以得到如下结果： - pref[0] = 5 - pref[1] = 5 ^ 7 = 2 - pref[2] = 5 ^ 7 ^ 2 = 0 - pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3 - pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1 示例 2：\n1 2 3 输入：pref = [13] 输出：[13] 解释：pref[0] = arr[0] = 13 提示：\n1 \u0026lt;= pref.length \u0026lt;= 10^5 0 \u0026lt;= pref[i] \u0026lt;= 10^6 解题思路 根据异或的运算性质可得，res[i] = pref[i-1] ^ pref[i]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: vector\u0026lt;int\u0026gt; findArray(vector\u0026lt;int\u0026gt;\u0026amp; pref) { int n = pref.size(); vector\u0026lt;int\u0026gt; res(n,0); res[0] = pref[0]; for(int i=1;i\u0026lt;n;i++){ res[i] = pref[i-1] ^ pref[i]; } return res; } }; 【贪心+栈模拟】使用机器人打印字典序最小的字符串 题目 给你一个字符串 s 和一个机器人，机器人当前有一个空字符串 t 。执行以下操作之一，直到 s 和 t 都变成空字符串：\n删除字符串 s 的 第一个 字符，并将该字符给机器人。机器人把这个字符添加到 t 的尾部。 删除字符串 t 的 最后一个 字符，并将该字符给机器人。机器人将该字符写到纸上。 请你返回纸上能写出的字典序最小的字符串。\n示例 1：\n1 2 3 4 5 6 输入：s = \u0026#34;zza\u0026#34; 输出：\u0026#34;azz\u0026#34; 解释：用 p 表示写出来的字符串。 一开始，p=\u0026#34;\u0026#34; ，s=\u0026#34;zza\u0026#34; ，t=\u0026#34;\u0026#34; 。 执行第一个操作三次，得到 p=\u0026#34;\u0026#34; ，s=\u0026#34;\u0026#34; ，t=\u0026#34;zza\u0026#34; 。 执行第二个操作三次，得到 p=\u0026#34;azz\u0026#34; ，s=\u0026#34;\u0026#34; ，t=\u0026#34;\u0026#34; 。 示例 2：\n1 2 3 4 5 6 7 输入：s = \u0026#34;bac\u0026#34; 输出：\u0026#34;abc\u0026#34; 解释：用 p 表示写出来的字符串。 执行第一个操作两次，得到 p=\u0026#34;\u0026#34; ，s=\u0026#34;c\u0026#34; ，t=\u0026#34;ba\u0026#34; 。 执行第二个操作两次，得到 p=\u0026#34;ab\u0026#34; ，s=\u0026#34;c\u0026#34; ，t=\u0026#34;\u0026#34; 。 执行第一个操作，得到 p=\u0026#34;ab\u0026#34; ，s=\u0026#34;\u0026#34; ，t=\u0026#34;c\u0026#34; 。 执行第二个操作，得到 p=\u0026#34;abc\u0026#34; ，s=\u0026#34;\u0026#34; ，t=\u0026#34;\u0026#34; 。 示例 3：\n1 2 3 4 5 6 输入：s = \u0026#34;bdda\u0026#34; 输出：\u0026#34;addb\u0026#34; 解释：用 p 表示写出来的字符串。 一开始，p=\u0026#34;\u0026#34; ，s=\u0026#34;bdda\u0026#34; ，t=\u0026#34;\u0026#34; 。 执行第一个操作四次，得到 p=\u0026#34;\u0026#34; ，s=\u0026#34;\u0026#34; ，t=\u0026#34;bdda\u0026#34; 。 执行第二个操作四次，得到 p=\u0026#34;addb\u0026#34; ，s=\u0026#34;\u0026#34; ，t=\u0026#34;\u0026#34; 。 提示：\n1 \u0026lt;= s.length \u0026lt;= 10^5 s 只包含小写英文字母。 解题思路 很可惜没写出来。看描述肯定是要用栈模拟的，再加上贪心。可惜没贪对\n经典贪心：有一个初始为空的栈，给定字符的入栈顺序，求字典序最小的出栈序列。\n当一个字符入栈后，我们持续检查栈顶元素 c。设还未入栈的字符中，字典序最小的字符是 m，有以下两种情况。\n$c \\le m$：此时弹出 c 最优。如果此时按兵不动，下一个出栈的将会是大等于 c 的字符，答案不会变优。 $c \u0026gt; m$：此时不弹出 c，等待后续更小的字符入栈。 所有字符都入栈后，栈内的剩余字符按顺序弹出即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Solution { public: string robotWithString(string s) { int n = s.size(); vector\u0026lt;char\u0026gt; R(n+1);//R[i]: s[i..n]中最小的字符 R[n] = \u0026#39;z\u0026#39;; for(int i=n-1;i\u0026gt;=0;i--){ R[i] = min(R[i+1],s[i]); } stack\u0026lt;char\u0026gt; stk; string res; for(int i=0;i\u0026lt;n;i++){ stk.push(s[i]); while(!stk.empty() \u0026amp;\u0026amp; stk.top()\u0026lt;=R[i+1]){ res += stk.top(); stk.pop(); } } return res; } }; 【动态规划】矩阵中和能被 K 整除的路径 题目 给你一个下标从 0 开始的 m x n 整数矩阵 grid 和一个整数 k 。你从起点 (0, 0) 出发，每一步只能往 下 或者往 右 ，你想要到达终点 (m - 1, n - 1) 。\n请你返回路径和能被 k 整除的路径数目，由于答案可能很大，返回答案对 10^9 + 7 取余 的结果。\n示例 1：\n1 2 3 4 5 输入：grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3 输出：2 解释：有两条路径满足路径上元素的和能被 k 整除。 第一条路径为上图中用红色标注的路径，和为 5 + 2 + 4 + 5 + 2 = 18 ，能被 3 整除。 第二条路径为上图中用蓝色标注的路径，和为 5 + 3 + 0 + 5 + 2 = 15 ，能被 3 整除。 示例 2：\n1 2 3 输入：grid = [[0,0]], k = 5 输出：1 解释：红色标注的路径和为 0 + 0 = 0 ，能被 5 整除。 示例 3：\n1 2 3 输入：grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1 输出：10 解释：每个数字都能被 1 整除，所以每一条路径的和都能被 k 整除。 提示：\nm == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 5 * 10^4 1 \u0026lt;= m * n \u0026lt;= 5 * 10^4 0 \u0026lt;= grid[i][j] \u0026lt;= 100 1 \u0026lt;= k \u0026lt;= 50 解题思路 路径类动态规划\n令dp[i, j, p]表示从[0, 0]走到[i, j]过程中路径和模k等于p的路径数目\n[i, j] 处状态由 [i-1, j]和[i, j-1]处转移得来\n最后答案为dp[n-1, m-1, 0]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MOD = 1e9+7; class Solution { public: int numberOfPaths(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, int k) { int n = grid.size(),m = grid[0].size(); for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ grid[i][j] = grid[i][j]%k; } } long long dp[n+1][m+1][k+1]; memset(dp,0,sizeof(dp)); dp[0][0][grid[0][0]] = 1; for(int j=1;j\u0026lt;m;j++){ for(int p=0;p\u0026lt;k;p++){ dp[0][j][(p+grid[0][j])%k] = dp[0][j-1][p]; } } for(int i=1;i\u0026lt;n;i++){ for(int p=0;p\u0026lt;k;p++){ dp[i][0][(p+grid[i][0])%k] = dp[i-1][0][p]; } } for(int i=1;i\u0026lt;n;i++){ for(int j=1;j\u0026lt;m;j++){ for(int p=0;p\u0026lt;k;p++){ dp[i][j][(p+grid[i][j])%k] = (dp[i-1][j][p]+dp[i][j-1][p])%MOD; } } } return dp[n-1][m-1][0]; } }; ","date":"2022-10-15T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC314%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20221015_hu18043258970325532167.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC314%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第314场周赛总结"},{"content":"国庆期间没打\n【模拟】公因子的数目 题目 给你两个正整数 a 和 b ，返回 a 和 b 的 公 因子的数目。\n如果 x 可以同时整除 a 和 b ，则认为 x 是 a 和 b 的一个 公因子 。\n示例 1：\n1 2 3 输入：a = 12, b = 6 输出：4 解释：12 和 6 的公因子是 1、2、3、6 。 示例 2：\n1 2 3 输入：a = 25, b = 30 输出：2 解释：25 和 30 的公因子是 1、5 。 提示：\n1 \u0026lt;= a, b \u0026lt;= 1000 解题思路 简单模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 class Solution { public: int commonFactors(int a, int b) { int res = 0; for(int i=1;i\u0026lt;=min(a,b);i++){ if(a%i==0 \u0026amp;\u0026amp; b%i==0) res++; } return res; } }; 【模拟】沙漏的最大总和 题目 给你一个大小为 m x n 的整数矩阵 grid 。\n按以下形式将矩阵的一部分定义为一个 沙漏 ：\n返回沙漏中元素的 最大 总和。\n**注意：**沙漏无法旋转且必须整个包含在矩阵中。\n示例 1：\n1 2 3 输入：grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]] 输出：30 解释：上图中的单元格表示元素总和最大的沙漏：6 + 2 + 1 + 2 + 9 + 2 + 8 = 30 。 示例 2：\n1 2 3 输入：grid = [[1,2,3],[4,5,6],[7,8,9]] 输出：35 解释：上图中的单元格表示元素总和最大的沙漏：1 + 2 + 3 + 5 + 7 + 8 + 9 = 35 。 提示：\nm == grid.length n == grid[i].length 3 \u0026lt;= m, n \u0026lt;= 150 0 \u0026lt;= grid[i][j] \u0026lt;= 10^6 解题思路 简单模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Solution { public: int maxSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(),m = grid[0].size(); int res=0; for(int i=0;i+2\u0026lt;n;i++){ for(int j=0;j+2\u0026lt;m;j++){ int cur = 0; cur += grid[i][j] + grid[i][j+1] + grid[i][j+2]; cur += grid[i+1][j+1]; cur += grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]; res = max(res, cur); } } return res; } }; 【位运算+分类讨论】最小 XOR 题目 给你两个正整数 num1 和 num2 ，找出满足下述条件的整数 x ：\nx 的置位数和 num2 相同，且 x XOR num1 的值 最小 注意 XOR 是按位异或运算。\n返回整数 x 。题目保证，对于生成的测试用例， x 是 唯一确定 的。\n整数的 置位数 是其二进制表示中 1 的数目。\n示例 1：\n1 2 3 4 5 输入：num1 = 3, num2 = 5 输出：3 解释： num1 和 num2 的二进制表示分别是 0011 和 0101 。 整数 3 的置位数与 num2 相同，且 3 XOR 3 = 0 是最小的。 示例 2：\n1 2 3 4 5 输入：num1 = 1, num2 = 12 输出：3 解释： num1 和 num2 的二进制表示分别是 0001 和 1100 。 整数 3 的置位数与 num2 相同，且 3 XOR 1 = 2 是最小的。 提示：\n1 \u0026lt;= num1, num2 \u0026lt;= 10^9 解题思路 统计num1的二进制表示中1的个数n，以及num2的二进制表示中1的个数m\n注意找的是x，令x XOR num1的最小值为minv\n当n=m时，很显然minv=0，此时x为num1\n当n\u0026gt;m时，说明num1的前m个高位1应该变成0\n当n\u0026lt;m时，说明num1的前m-n个低位0应该变成1\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Solution { public: int minimizeXor(int num1, int num2) { int n=0,m=0; for(int i=0;i\u0026lt;32;i++) if((num1\u0026gt;\u0026gt;i)\u0026amp;1) n++; for(int i=0;i\u0026lt;32;i++) if((num2\u0026gt;\u0026gt;i)\u0026amp;1) m++; if(n==m) return num1; int res = 0; if(m\u0026gt;n){ res = num1; for(int i=0,rest=m-n;i\u0026lt;32\u0026amp;\u0026amp;rest;i++){ if((num1\u0026gt;\u0026gt;i)\u0026amp;1) continue; res ^= (1\u0026lt;\u0026lt;i); rest--; } }else { for(int i=31,rest=m;i\u0026gt;=0 \u0026amp;\u0026amp; rest;i--){ if((num1\u0026gt;\u0026gt;i)\u0026amp;1) { res ^= (1\u0026lt;\u0026lt;i), rest--; } } } return res; } }; 【线性DP】对字母串可执行的最大删除数 题目 给你一个仅由小写英文字母组成的字符串 s 。在一步操作中，你可以：\n删除 整个字符串 s ，或者 对于满足 1 \u0026lt;= i \u0026lt;= s.length / 2 的任意 i ，如果 s 中的 前 i 个字母和接下来的 i 个字母 相等 ，删除 前 i 个字母。 例如，如果 s = \u0026quot;ababc\u0026quot; ，那么在一步操作中，你可以删除 s 的前两个字母得到 \u0026quot;abc\u0026quot; ，因为 s 的前两个字母和接下来的两个字母都等于 \u0026quot;ab\u0026quot; 。\n返回删除 s 所需的最大操作数。\n示例 1：\n1 2 3 4 5 6 7 输入：s = \u0026#34;abcabcdabc\u0026#34; 输出：2 解释： - 删除前 3 个字母（\u0026#34;abc\u0026#34;），因为它们和接下来 3 个字母相等。现在，s = \u0026#34;abcdabc\u0026#34;。 - 删除全部字母。 一共用了 2 步操作，所以返回 2 。可以证明 2 是所需的最大操作数。 注意，在第二步操作中无法再次删除 \u0026#34;abc\u0026#34; ，因为 \u0026#34;abc\u0026#34; 的下一次出现并不是位于接下来的 3 个字母。 示例 2：\n1 2 3 4 5 6 7 8 输入：s = \u0026#34;aaabaab\u0026#34; 输出：4 解释： - 删除第一个字母（\u0026#34;a\u0026#34;），因为它和接下来的字母相等。现在，s = \u0026#34;aabaab\u0026#34;。 - 删除前 3 个字母（\u0026#34;aab\u0026#34;），因为它们和接下来 3 个字母相等。现在，s = \u0026#34;aab\u0026#34;。 - 删除第一个字母（\u0026#34;a\u0026#34;），因为它和接下来的字母相等。现在，s = \u0026#34;ab\u0026#34;。 - 删除全部字母。 一共用了 4 步操作，所以返回 4 。可以证明 4 是所需的最大操作数。 示例 3：\n1 2 3 输入：s = \u0026#34;aaaaa\u0026#34; 输出：5 解释：在每一步操作中，都可以仅删除 s 的第一个字母。 提示：\n1 \u0026lt;= s.length \u0026lt;= 4000 s 仅由小写英文字母组成 解题思路 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: int deleteString(string s) { int n = s.size(); int lcp[n][n]; //lcp[i][j] s[i..n]与s[j..n]的最长公共前缀 memset(lcp,0,sizeof(lcp)); for(int i=0;i\u0026lt;n;i++){ lcp[n-1][i] = s[n-1]==s[i]?1:0; lcp[i][n-1] = s[i]==s[n-1]?1:0; } for(int i=n-2;i\u0026gt;=0;i--){ for(int j=n-2;j\u0026gt;=0;j--){ if(s[i]==s[j]) lcp[i][j] = max(lcp[i+1][j+1]+1, 1); else lcp[i][j] = 0; } } vector\u0026lt;int\u0026gt; dp(n,1);//dp[i]: 删除s[i..n]所需的最大操作数 dp[n-1] = 1; for(int i=n-2;i\u0026gt;=0;i--){ for(int len=1;i+len\u0026lt;n;len++){ if(lcp[i][i+len]\u0026gt;=len){//有至少len个字母相等 dp[i] = max(dp[i], dp[i+len]+1); } } } // for(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;dp[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return dp[0]; } }; ","date":"2022-10-06T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC313%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20221006_hu11020439561425980146.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC313%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第313场周赛总结"},{"content":"\n第一题好像被rejudge掉了，麻了。\n【枚举】删除字符使频率相同 题目 给你一个下标从 0 开始的字符串 word ，字符串只包含小写英文字母。你需要选择 一个 下标并 删除 下标处的字符，使得 word 中剩余每个字母出现 频率 相同。\n如果删除一个字母后，word 中剩余所有字母的出现频率都相同，那么返回 true ，否则返回 false 。\n注意：\n字母 x 的 频率 是这个字母在字符串中出现的次数。 你 必须 恰好删除一个字母，不能一个字母都不删除。 示例 1：\n1 2 3 输入：word = \u0026#34;abcc\u0026#34; 输出：true 解释：选择下标 3 并删除该字母，word 变成 \u0026#34;abc\u0026#34; 且每个字母出现频率都为 1 。 示例 2：\n1 2 3 输入：word = \u0026#34;aazz\u0026#34; 输出：false 解释：我们必须删除一个字母，所以要么 \u0026#34;a\u0026#34; 的频率变为 1 且 \u0026#34;z\u0026#34; 的频率为 2 ，要么两个字母频率反过来。所以不可能让剩余所有字母出现频率相同。 提示：\n2 \u0026lt;= word.length \u0026lt;= 100 word 只包含小写英文字母。 解题思路 这题情况有点多，没考虑全就容易WA\n赛时WA了两发才过。今天看竟然被rejudge掉了。\n赛后看其实暴力枚举就行了呀，也就不用考虑那么多情况了。\n枚举删除第i种字符，再看剩余的是否合题意就行。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: bool equalFrequency(string word) { vector\u0026lt;int\u0026gt; cnt(26,0); for(auto \u0026amp;x: word){ cnt[x-\u0026#39;a\u0026#39;]++; } for(int i=0;i\u0026lt;26;i++){//枚举删除字符 i+\u0026#39;a\u0026#39; if(cnt[i]==0) continue; cnt[i]--; int last = -1; bool ok = true; for(int j=0;j\u0026lt;26\u0026amp;\u0026amp;ok;j++){//考虑删除字符i+\u0026#39;a\u0026#39;后，剩余字符分布情况是否合题意 if(cnt[j]==0) continue; if(last==-1) last = cnt[j]; else { if(last!=cnt[j]) ok=false; } } cnt[i]++; if(ok) return true; } return false; } }; 【模拟】最长上传前缀 题目 给你一个 n 个视频的上传序列，每个视频编号为 1 到 n 之间的 不同 数字，你需要依次将这些视频上传到服务器。请你实现一个数据结构，在上传的过程中计算 最长上传前缀 。\n如果 闭区间 1 到 i 之间的视频全部都已经被上传到服务器，那么我们称 i 是上传前缀。最长上传前缀指的是符合定义的 i 中的 最大值 。\n请你实现 LUPrefix 类：\nLUPrefix(int n) 初始化一个 n 个视频的流对象。 void upload(int video) 上传 video 到服务器。 int longest() 返回上述定义的 最长上传前缀 的长度。 示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 输入： [\u0026#34;LUPrefix\u0026#34;, \u0026#34;upload\u0026#34;, \u0026#34;longest\u0026#34;, \u0026#34;upload\u0026#34;, \u0026#34;longest\u0026#34;, \u0026#34;upload\u0026#34;, \u0026#34;longest\u0026#34;] [[4], [3], [], [1], [], [2], []] 输出： [null, null, 0, null, 1, null, 3] 解释： LUPrefix server = new LUPrefix(4); // 初始化 4个视频的上传流 server.upload(3); // 上传视频 3 。 server.longest(); // 由于视频 1 还没有被上传，最长上传前缀是 0 。 server.upload(1); // 上传视频 1 。 server.longest(); // 前缀 [1] 是最长上传前缀，所以我们返回 1 。 server.upload(2); // 上传视频 2 。 server.longest(); // 前缀 [1,2,3] 是最长上传前缀，所以我们返回 3 。 提示：\n1 \u0026lt;= n \u0026lt;= 10^5 1 \u0026lt;= video \u0026lt;= 10^5 video 中所有值 互不相同 。 upload 和 longest 总调用 次数至多不超过 2 * 10^5 次。 至少会调用 longest 一次。 解题思路 乐。赛时又用了线段树。\n其实用一个数组一个指针就可以维护这个最长前缀了，这个最长前缀不会减小。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class LUPrefix { public: int a[100005]; int cur; LUPrefix(int n) { memset(a,0,sizeof(a)); cur = 0; } void upload(int video) { a[video] = 1; } int longest() { while(a[cur+1]==1){ cur++; } return cur; } }; /** * Your LUPrefix object will be instantiated and called as such: * LUPrefix* obj = new LUPrefix(n); * obj-\u0026gt;upload(video); * int param_2 = obj-\u0026gt;longest(); */ 线段树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #define ll long long #define ls(p) (p\u0026lt;\u0026lt;1) #define rs(p) (p\u0026lt;\u0026lt;1|1) const int MAXN = 2e5+5; struct node{ int cnt; }T[MAXN\u0026lt;\u0026lt;2]; void push_up(int p,int l,int r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(T[ls(p)].cnt==(mid-l+1)) T[p].cnt = T[ls(p)].cnt+T[rs(p)].cnt; else T[p].cnt = T[ls(p)].cnt; } void build(int p, int l, int r){ if(l==r){ T[p].cnt = 0; return; } int mid = (l+r)\u0026gt;\u0026gt;1; build(ls(p),l,mid); build(rs(p),mid+1,r); push_up(p,l,r); } void update(int p,int l,int r,int lr){ if(l==r \u0026amp;\u0026amp; l==lr){ T[p].cnt =1; return; } int mid=(l+r)\u0026gt;\u0026gt;1; if(lr\u0026lt;=mid) update(ls(p),l,mid,lr); else update(rs(p),mid+1,r,lr); push_up(p,l,r); } class LUPrefix { public: int N; LUPrefix(int n) { N = n; build(1,1,N); } void upload(int video) { update(1,1,N,video); } int longest() { return T[1].cnt; } }; 【思维+位运算】所有数对的异或和 题目 给你两个下标从 0 开始的数组 nums1 和 nums2 ，两个数组都只包含非负整数。请你求出另外一个数组 nums3 ，包含 nums1 和 nums2 中 所有数对 的异或和（nums1 中每个整数都跟 nums2 中每个整数 恰好 匹配一次）。\n请你返回 nums3 中所有整数的 异或和 。\n示例 1：\n1 2 3 4 5 输入：nums1 = [2,1,3], nums2 = [10,2,5,0] 输出：13 解释： 一个可能的 nums3 数组是 [8,0,7,2,11,3,4,1,9,1,6,3] 。 所有这些数字的异或和是 13 ，所以我们返回 13 。 示例 2：\n1 2 3 4 5 6 输入：nums1 = [1,2], nums2 = [3,4] 输出：0 解释： 所有数对异或和的结果分别为 nums1[0] ^ nums2[0] ，nums1[0] ^ nums2[1] ，nums1[1] ^ nums2[0] 和 nums1[1] ^ nums2[1] 。 所以，一个可能的 nums3 数组是 [2,5,1,6] 。 2 ^ 5 ^ 1 ^ 6 = 0 ，所以我们返回 0 。 提示：\n1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 10^5 0 \u0026lt;= nums1[i], nums2[j] \u0026lt;= 10^9 解题思路 主要利用异或的性质： a^a = 0\n这题的答案与两个数组的奇偶性有关\n两个数组都是偶数个时，答案为0\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Solution { public: int xorAllNums(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { int n = nums1.size(), m = nums2.size(); int res1 = 0, res2 = 0; for(auto \u0026amp;x: nums1) res1 = res1 ^ x; for(auto \u0026amp;x: nums2) res2 = res2 ^ x; if((n\u0026amp;1) \u0026amp;\u0026amp; (m\u0026amp;1)) return res1^res2; else if(!(n\u0026amp;1) \u0026amp;\u0026amp; !(m\u0026amp;1)) return 0; else if((n\u0026amp;1) \u0026amp;\u0026amp; !(m\u0026amp;1)) return res2; else return res1; } }; 【线段树+类逆序对】满足不等式的数对数目 题目 给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，两个数组的大小都为 n ，同时给你一个整数 diff ，统计满足以下条件的 数对 (i, j) ：\n0 \u0026lt;= i \u0026lt; j \u0026lt;= n - 1 且 nums1[i] - nums1[j] \u0026lt;= nums2[i] - nums2[j] + diff. 请你返回满足条件的 数对数目 。\n示例 1：\n1 2 3 4 5 6 7 8 输入：nums1 = [3,2,5], nums2 = [2,2,1], diff = 1 输出：3 解释： 总共有 3 个满足条件的数对： 1. i = 0, j = 1：3 - 2 \u0026lt;= 2 - 2 + 1 。因为 i \u0026lt; j 且 1 \u0026lt;= 1 ，这个数对满足条件。 2. i = 0, j = 2：3 - 5 \u0026lt;= 2 - 1 + 1 。因为 i \u0026lt; j 且 -2 \u0026lt;= 2 ，这个数对满足条件。 3. i = 1, j = 2：2 - 5 \u0026lt;= 2 - 1 + 1 。因为 i \u0026lt; j 且 -3 \u0026lt;= 2 ，这个数对满足条件。 所以，我们返回 3 。 示例 2：\n1 2 3 4 输入：nums1 = [3,-1], nums2 = [-2,2], diff = -1 输出：0 解释： 没有满足条件的任何数对，所以我们返回 0 。 提示：\nn == nums1.length == nums2.length 2 \u0026lt;= n \u0026lt;= 10^5 -10^4 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 10^4 -10^4 \u0026lt;= diff \u0026lt;= 10^4 解题思路 根据nums1[i] - nums1[j] \u0026lt;= nums2[i] - nums2[j] + diff移项得：nums1[i] - nums2[i] \u0026lt;= nums1[j]- nums2[j] + diff\n这样研究对象就变成一个数组了\n令a[i] = nums1[i] - nums2[i]，要求a[i] \u0026lt;= a[j]+diff且i\u0026lt;j的数对个数。\n和逆序对的思路类似。\n倒序遍历数组，考虑a[i]时，就不会受下标小于i的数的影响。\n再利用线段树/树状数组等结构维护a[j] + diff，（其中$j\\in[i+1,n]$）的值的分布情况，可在log(n)时间复杂度内求得以i开头的数对(i,j)数目。\n由于值可能出现负数，离散化一下即可。\n总时间复杂度$O(n\\log n)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define ls(p) (p\u0026lt;\u0026lt;1) #define rs(p) (p\u0026lt;\u0026lt;1|1) const int MAXN = 2e5+5; struct node{ int cnt; }T[MAXN\u0026lt;\u0026lt;2]; void push_up(int p){ T[p].cnt = T[ls(p)].cnt + T[rs(p)].cnt; } void build(int p, int l, int r){ if(l==r){ T[p].cnt = 0; return; } int mid = (l+r)\u0026gt;\u0026gt;1; build(ls(p),l,mid); build(rs(p),mid+1,r); push_up(p); } void update(int p,int l,int r,int lr){ if(l==r \u0026amp;\u0026amp; l==lr){ T[p].cnt += 1; return ; } int mid=(l+r)\u0026gt;\u0026gt;1; if(lr\u0026lt;=mid) update(ls(p),l,mid,lr); else update(rs(p),mid+1,r,lr); push_up(p); } int query(int p,int l,int r,int nl,int nr){ if(nl\u0026lt;=l \u0026amp;\u0026amp; nr\u0026gt;=r) return T[p].cnt; int mid=(l+r)\u0026gt;\u0026gt;1; int res=0; if(nl\u0026lt;=mid) res+= query(ls(p),l,mid,nl,nr); if(nr\u0026gt;mid) res+=query(rs(p),mid+1,r,nl,nr); return res; } class Solution { public: long long numberOfPairs(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int diff) { int n = nums1.size(); vector\u0026lt;int\u0026gt; a(n,0); vector\u0026lt;int\u0026gt; tab; for(int i=0;i\u0026lt;n;i++) { a[i] = nums1[i] - nums2[i]; tab.push_back(a[i]); tab.push_back(a[i]+diff); } ll res=0; sort(tab.begin(),tab.end()); // int m = unique(tab.begin(),tab.end())-tab.begin()+1; int m = n*2; function\u0026lt;int(int)\u0026gt; getid = [\u0026amp;](int val)-\u0026gt;int{ int idx = lower_bound(tab.begin(),tab.end(),val)-tab.begin()+1; return idx; } ; build(1,1,m); for(int i=n-1;i\u0026gt;=0;i--){ int u = getid(a[i]); int num = query(1,1,m,u,m); res += num; int v = getid(a[i]+diff); update(1,1,m,v); } return res; } }; ","date":"2022-10-05T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC88%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20221005_hu13870223328537887204.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC88%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第88场双周赛总结"},{"content":"连续几周掉分了\n【自定义排序】按身高排序 题目 给你一个字符串数组 names ，和一个由 互不相同 的正整数组成的数组 heights 。两个数组的长度均为 n 。\n对于每个下标 i，names[i] 和 heights[i] 表示第 i 个人的名字和身高。\n请按身高 降序 顺序返回对应的名字数组 names 。\n示例 1：\n1 2 3 输入：names = [\u0026#34;Mary\u0026#34;,\u0026#34;John\u0026#34;,\u0026#34;Emma\u0026#34;], heights = [180,165,170] 输出：[\u0026#34;Mary\u0026#34;,\u0026#34;Emma\u0026#34;,\u0026#34;John\u0026#34;] 解释：Mary 最高，接着是 Emma 和 John 。 示例 2：\n1 2 3 输入：names = [\u0026#34;Alice\u0026#34;,\u0026#34;Bob\u0026#34;,\u0026#34;Bob\u0026#34;], heights = [155,185,150] 输出：[\u0026#34;Bob\u0026#34;,\u0026#34;Alice\u0026#34;,\u0026#34;Bob\u0026#34;] 解释：第一个 Bob 最高，然后是 Alice 和第二个 Bob 。 提示：\nn == names.length == heights.length 1 \u0026lt;= n \u0026lt;= 10^3 1 \u0026lt;= names[i].length \u0026lt;= 20 1 \u0026lt;= heights[i] \u0026lt;= 10^5 names[i] 由大小写英文字母组成 heights 中的所有值互不相同 解题思路 自定义排序\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;deque\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;set\u0026gt; #include\u0026lt;numeric\u0026gt; using namespace std; class Solution { public: vector\u0026lt;string\u0026gt; sortPeople(vector\u0026lt;string\u0026gt;\u0026amp; names, vector\u0026lt;int\u0026gt;\u0026amp; heights) { int n = names.size(); vector\u0026lt;int\u0026gt; a(n,0); iota(a.begin(),a.end(),0); sort(a.begin(),a.end(),[\u0026amp;](int x, int y){ return heights[x]\u0026gt;heights[y]; }); vector\u0026lt;string\u0026gt; res(n); for(int i=0;i\u0026lt;n;i++){ res[i] = names[a[i]]; } return res; } }; 【思维】按位与最大的最长子数组 题目 给你一个长度为 n 的整数数组 nums 。\n考虑 nums 中进行 **按位与（bitwise AND）**运算得到的值 最大 的 非空 子数组。\n换句话说，令 k 是 nums 任意 子数组执行按位与运算所能得到的最大值。那么，只需要考虑那些执行一次按位与运算后等于 k 的子数组。 返回满足要求的 最长 子数组的长度。\n数组的按位与就是对数组中的所有数字进行按位与运算。\n子数组 是数组中的一个连续元素序列。\n示例 1：\n1 2 3 4 5 输入：nums = [1,2,3,3,2,2] 输出：2 解释： 子数组按位与运算的最大值是 3 。 能得到此结果的最长子数组是 [3,3]，所以返回 2 。 示例 2：\n1 2 3 4 5 输入：nums = [1,2,3,4] 输出：1 解释： 子数组按位与运算的最大值是 4 。 能得到此结果的最长子数组是 [4]，所以返回 1 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^6 解题思路 根据按位与运算的特性，有 a AND b \u0026lt;= min(a, b)。题目首先要求子数组按位与结果最大，然后求最长子数组。因此题目实际上求的是数组中的最大值最多连续出现了几次\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;deque\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;set\u0026gt; #include\u0026lt;numeric\u0026gt; using namespace std; class Solution { public: int longestSubarray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int maxv = *max_element(nums.begin(),nums.end()); int res = 0; int cur=0; for(int i=0;i\u0026lt;n;i++){ if(nums[i]==maxv){ cur++; }else cur=0; res = max(res, cur); } return res; } }; 【DP/线段树】找到所有好下标 题目 给你一个大小为 n 下标从 0 开始的整数数组 nums 和一个正整数 k 。\n对于 k \u0026lt;= i \u0026lt; n - k 之间的一个下标 i ，如果它满足以下条件，我们就称它为一个 好 下标：\n下标 i 之前 的 k 个元素是 非递增的 。 下标 i 之后 的 k 个元素是 非递减的 。 按 升序 返回所有好下标。\n示例 1：\n1 2 3 4 5 6 输入：nums = [2,1,1,1,3,4,1], k = 2 输出：[2,3] 解释：数组中有两个好下标： - 下标 2 。子数组 [2,1] 是非递增的，子数组 [1,3] 是非递减的。 - 下标 3 。子数组 [1,1] 是非递增的，子数组 [3,4] 是非递减的。 注意，下标 4 不是好下标，因为 [4,1] 不是非递减的。 示例 2：\n1 2 3 输入：nums = [2,1,1,2], k = 2 输出：[] 解释：数组中没有好下标。 提示：\nn == nums.length 3 \u0026lt;= n \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^6 1 \u0026lt;= k \u0026lt;= n / 2 解题思路 思维钝化了，直接用线段树莽了，调了很长时间，还WA了一发\n用线段树的话，可以维护每一个区间的单调性，额外记录对应区间的左右端点值即可\n简单的想，其实用一维数组即可维护单调性情况\n代码 DP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: vector\u0026lt;int\u0026gt; goodIndices(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); vector\u0026lt;int\u0026gt; L(n,1),R(n,1); //L[i]表示 nums[i]左侧（含） 非递增元素 的最长长度 //R[i]表示 nums[i]右侧（含） 非递减元素 的最长长度 for(int i=1;i\u0026lt;n;i++){ if(nums[i]\u0026lt;=nums[i-1]) L[i] = L[i-1]+1; } for(int i=n-2;i\u0026gt;=0;i--){ if(nums[i]\u0026lt;=nums[i+1]) R[i] = R[i+1]+1; } vector\u0026lt;int\u0026gt; res; for(int i=1;i\u0026lt;n-1;i++){ // cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;L[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;R[i]\u0026lt;\u0026lt;endl; if(L[i-1]\u0026gt;=k \u0026amp;\u0026amp; R[i+1]\u0026gt;=k) res.push_back(i); } return res; } }; 线段树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;deque\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;set\u0026gt; #include\u0026lt;numeric\u0026gt; using namespace std; #define ll long long #define ls(p) (p\u0026lt;\u0026lt;1) #define rs(p) (p\u0026lt;\u0026lt;1|1) const int MAXN = 1e5+5; struct node{ int lv,rv; int inc,dec; }T[MAXN\u0026lt;\u0026lt;2]; void push_up(int p){ T[p].lv = T[ls(p)].lv; T[p].rv = T[rs(p)].rv; if(T[ls(p)].inc \u0026amp;\u0026amp; T[rs(p)].inc \u0026amp;\u0026amp; T[ls(p)].rv\u0026lt;=T[rs(p)].lv){ T[p].inc = 1; }else T[p].inc = 0; if(T[ls(p)].dec \u0026amp;\u0026amp; T[rs(p)].dec \u0026amp;\u0026amp; T[ls(p)].rv\u0026gt;=T[rs(p)].lv){ T[p].dec = 1; }else T[p].dec = 0; } void build(int p, int l, int r, vector\u0026lt;int\u0026gt;\u0026amp; a){ if(l==r){ T[p].lv = T[p].rv = a[l-1]; T[p].dec = T[p].inc = 1; return; } int mid = (l+r)\u0026gt;\u0026gt;1; build(ls(p),l,mid,a); build(rs(p),mid+1,r,a); push_up(p); } node query(int p, int l, int r, int nl, int nr){ if(nl\u0026gt;r || nr\u0026lt;l) return {-1,-1,-1,-1}; if(nl\u0026lt;=l \u0026amp;\u0026amp; nr\u0026gt;=r) return T[p]; int mid=(l+r)\u0026gt;\u0026gt;1; node left = query(ls(p),l,mid,nl,nr); node right = query(rs(p),mid+1,r,nl,nr); if(left.lv==-1 \u0026amp;\u0026amp; right.lv!=-1) return right; if(left.lv!=-1 \u0026amp;\u0026amp; right.lv==-1) return left; if(left.lv==-1 \u0026amp;\u0026amp; right.lv==-1) return {-1,-1,-1,-1}; node res = {233,233,0,0}; res.lv = left.lv; res.rv = right.rv; if(left.inc \u0026amp;\u0026amp; right.inc \u0026amp;\u0026amp; left.rv\u0026lt;=right.lv){ res.inc = 1; }else res.inc = 0; if(left.dec \u0026amp;\u0026amp; right.dec \u0026amp;\u0026amp; left.rv\u0026gt;=right.lv){ res.dec = 1; }else res.dec = 0; return res; } class Solution { public: vector\u0026lt;int\u0026gt; goodIndices(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); build(1,1,n,nums); vector\u0026lt;int\u0026gt; res; for(int i=k+1;i\u0026lt;=n-k;i++){ node L = query(1,1,n,i-k,i-1); node R = query(1,1,n,i+1,i+k); if(L.dec \u0026amp;\u0026amp; R.inc) res.push_back(i-1); } return res; } }; 【并查集+离线】好路径的数目 题目 给你一棵 n 个节点的树（连通无向无环的图），节点编号从 0 到 n - 1 且恰好有 n - 1 条边。\n给你一个长度为 n 下标从 0 开始的整数数组 vals ，分别表示每个节点的值。同时给你一个二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边。\n一条 好路径 需要满足以下条件：\n开始节点和结束节点的值 相同 。 开始节点和结束节点中间的所有节点值都 小于等于 开始节点的值（也就是说开始节点的值应该是路径上所有节点的最大值）。 请你返回不同好路径的数目。\n注意，一条路径和它反向的路径算作 同一 路径。比方说， 0 -\u0026gt; 1 与 1 -\u0026gt; 0 视为同一条路径。单个节点也视为一条合法路径。\n示例 1：\n1 2 3 4 5 6 输入：vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]] 输出：6 解释：总共有 5 条单个节点的好路径。 还有 1 条好路径：1 -\u0026gt; 0 -\u0026gt; 2 -\u0026gt; 4 。 （反方向的路径 4 -\u0026gt; 2 -\u0026gt; 0 -\u0026gt; 1 视为跟 1 -\u0026gt; 0 -\u0026gt; 2 -\u0026gt; 4 一样的路径） 注意 0 -\u0026gt; 2 -\u0026gt; 3 不是一条好路径，因为 vals[2] \u0026gt; vals[0] 。 示例 2：\n1 2 3 4 输入：vals = [1,1,2,2,3], edges = [[0,1],[1,2],[2,3],[2,4]] 输出：7 解释：总共有 5 条单个节点的好路径。 还有 2 条好路径：0 -\u0026gt; 1 和 2 -\u0026gt; 3 。 示例 3：\n1 2 3 输入：vals = [1], edges = [] 输出：1 解释：这棵树只有一个节点，所以只有一条好路径。 提示：\nn == vals.length 1 \u0026lt;= n \u0026lt;= 3 * 104 0 \u0026lt;= vals[i] \u0026lt;= 105 edges.length == n - 1 edges[i].length == 2 0 \u0026lt;= ai, bi \u0026lt; n ai != bi edges 表示一棵合法的树。 解题思路 解法很有意思。化静为动。\n考虑重新构造出这棵树，按节点值从小到大的顺序，期间利用并查集维护联通性，以及每个联通块所含最大值及相应数目\n这样在构造过程中，使得每个联通块的代表元都是当前最大值，方便得出题目中所要求的“好路径”\n详见注释\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public: int numberOfGoodPaths(vector\u0026lt;int\u0026gt;\u0026amp; vals, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { int n = vals.size(); vector\u0026lt;int\u0026gt; fa(n),idx(n),cnt(n,1);//cnt[i] 表示i所在连通块最大值的个数 vector\u0026lt;int\u0026gt; G[n]; for(auto \u0026amp;x:edges){ G[x[0]].push_back(x[1]); G[x[1]].push_back(x[0]); } iota(fa.begin(),fa.end(),0); iota(idx.begin(),idx.end(),0); sort(idx.begin(),idx.end(),[\u0026amp;](int a,int b){ return vals[a]\u0026lt;vals[b]; }); function\u0026lt;int(int)\u0026gt; find = [\u0026amp;](int x)-\u0026gt;int{ return x==fa[x]?x:(fa[x]=find(fa[x])); }; int res = n;//至少有n条单个节点的好路径 for(int i=0;i\u0026lt;n;i++){//按节点值从小到大遍历 int u = idx[i]; int fu = find(u);//当前结点u所在连通块的代表元 for(auto \u0026amp;v: G[u]){ int fv = find(v);//u的邻居v 所在连通块的 代表元 if(fu == fv) continue;//已经处于同一连通块了，已经被计算过了 //fu的val值小 fv的val值大时 不考虑将v和u连通，只考虑u和比它小的值，以满足“好路径”的定义 //记录了双向图，待后面遍历到大-\u0026gt;小时再连通 if(vals[fv]\u0026gt;vals[fu]) continue; if(vals[fv] == vals[fu]){//两个连通块中的最大val值相等，可以构成好路径 res += cnt[fv] * cnt[fu];//乘法原理计数 cnt[fu] += cnt[fv]; } fa[fv] = fu;// 让val值小的 指向 val值大的 } } return res; } }; ","date":"2022-09-30T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC312%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220930_hu8402227015925098772.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC312%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第312场周赛总结"},{"content":"又掉大分\n【简单数学】最小偶倍数 题目 给你一个正整数 n ，返回 2 和 n 的最小公倍数（正整数）。\n示例 1：\n1 2 3 输入：n = 5 输出：10 解释：5 和 2 的最小公倍数是 10 。 示例 2：\n1 2 3 输入：n = 6 输出：6 解释：6 和 2 的最小公倍数是 6 。注意数字会是它自身的倍数。 提示：\n1 \u0026lt;= n \u0026lt;= 150 解题思路 最小公倍数 = 总乘积/最大公倍数\n代码 1 2 3 4 5 6 7 8 class Solution { public: int smallestEvenMultiple(int n) { int all = 2*n; int gc = __gcd(2,n); return all/gc; } }; 【枚举】最长的字母序连续子字符串的长度 题目 字母序连续字符串 是由字母表中连续字母组成的字符串。换句话说，字符串 \u0026quot;abcdefghijklmnopqrstuvwxyz\u0026quot; 的任意子字符串都是 字母序连续字符串 。\n例如，\u0026quot;abc\u0026quot; 是一个字母序连续字符串，而 \u0026quot;acb\u0026quot; 和 \u0026quot;za\u0026quot; 不是。 给你一个仅由小写英文字母组成的字符串 s ，返回其 最长 的 字母序连续子字符串 的长度。\n示例 1：\n1 2 3 4 输入：s = \u0026#34;abacaba\u0026#34; 输出：2 解释：共有 4 个不同的字母序连续子字符串 \u0026#34;a\u0026#34;、\u0026#34;b\u0026#34;、\u0026#34;c\u0026#34; 和 \u0026#34;ab\u0026#34; 。 \u0026#34;ab\u0026#34; 是最长的字母序连续子字符串。 示例 2：\n1 2 3 输入：s = \u0026#34;abcde\u0026#34; 输出：5 解释：\u0026#34;abcde\u0026#34; 是最长的字母序连续子字符串。 提示：\n1 \u0026lt;= s.length \u0026lt;= 10^5 s 由小写英文字母组成 解题思路 简单枚举即可，答案最大是26\n总能把问题想复杂\nWA了一发，忘记i应该从26开始枚举，而不是数组长度\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; class Solution { public: string str; int n; bool C(int k){ bool res = false; for(int i=0;i\u0026lt;=n-k;i++){ int len = 1; for(int j=1;j\u0026lt;k;j++){ if(str[i+j]==str[i+j-1]+1) {len++;} else { res = false; break; } } if(len\u0026gt;=k) return true; } return false; } int longestContinuousSubstring(string s) { str = s; n = s.size(); // cout\u0026lt;\u0026lt;C(26)\u0026lt;\u0026lt;endl; for(int i=26;i\u0026gt;=1;i--){ if(C(i)) return i; } return 0; } }; 偷学代码 这样写不更简单？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int longestContinuousSubstring(string s) { int n = s.size(); int ans = 0; for (int i = 0; i \u0026lt; n; i++) { int t = 0; for (int j = 0; i + j \u0026lt; n; j++) { if (s[i + j] - s[i] == j) t++; else break; } ans = max(ans, t); } return ans; } }; 【二叉树的遍历】反转二叉树的奇数层 题目 给你一棵 完美 二叉树的根节点 root ，请你反转这棵树中每个 奇数 层的节点值。\n例如，假设第 3 层的节点值是 [2,1,3,4,7,11,29,18] ，那么反转后它应该变成 [18,29,11,7,4,3,1,2] 。 反转后，返回树的根节点。\n完美 二叉树需满足：二叉树的所有父节点都有两个子节点，且所有叶子节点都在同一层。\n节点的 层数 等于该节点到根节点之间的边数。\n示例 1：\n1 2 3 4 5 输入：root = [2,3,5,8,13,21,34] 输出：[2,5,3,8,13,21,34] 解释： 这棵树只有一个奇数层。 在第 1 层的节点分别是 3、5 ，反转后为 5、3 。 示例 2：\n1 2 3 4 输入：root = [7,13,11] 输出：[7,11,13] 解释： 在第 1 层的节点分别是 13、11 ，反转后为 11、13 。 示例 3：\n1 2 3 4 5 输入：root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2] 输出：[0,2,1,0,0,0,0,2,2,2,2,1,1,1,1] 解释：奇数层由非零值组成。 在第 1 层的节点分别是 1、2 ，反转后为 2、1 。 在第 3 层的节点分别是 1、1、1、1、2、2、2、2 ，反转后为 2、2、2、2、1、1、1、1 。 提示：\n树中的节点数目在范围 [1, 2^14] 内 0 \u0026lt;= Node.val \u0026lt;= 10^5 root 是一棵 完美 二叉树 解题思路 层序遍历二叉树即可\nWA了一发是 取队列的首位元素加了引用，然后pop掉了，手真贱啊我\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* reverseOddLevels(TreeNode* root) { deque\u0026lt;TreeNode*\u0026gt; dq; dq.push_back(root); int dep = 0; vector\u0026lt;int\u0026gt; a; while(!dq.empty()){ int sz = dq.size(); if(dep\u0026amp;1) { a.clear(); for(auto \u0026amp;node: dq){ a.push_back(node-\u0026gt;val); } } int j = a.size(); // cout\u0026lt;\u0026lt;j\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;sz;i++){ auto u = dq.front(); if(u-\u0026gt;left) dq.push_back(u-\u0026gt;left); if(u-\u0026gt;right) dq.push_back(u-\u0026gt;right); dq.pop_front(); if(dep\u0026amp;1){ u-\u0026gt;val = a[--j]; } } dep++; // cout\u0026lt;\u0026lt;dep\u0026lt;\u0026lt;endl; } return root; } }; 偷学代码 按题意 dfs 即可。首先一遍 dfs 记录每一层从左到右的值，第二遍 dfs 替换奇数层的值即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec; void dfs1(TreeNode *node, int d) { if (node == nullptr) return; if (vec.size() \u0026lt;= d) vec.push_back(vector\u0026lt;int\u0026gt;()); vec[d].push_back(node-\u0026gt;val); dfs1(node-\u0026gt;left, d + 1); dfs1(node-\u0026gt;right, d + 1); } void dfs2(TreeNode *node, int d) { if (node == nullptr) return; if (d \u0026amp; 1) node-\u0026gt;val = vec[d].back(), vec[d].pop_back(); dfs2(node-\u0026gt;left, d + 1); dfs2(node-\u0026gt;right, d + 1); } public: TreeNode* reverseOddLevels(TreeNode* root) { dfs1(root, 0); dfs2(root, 0); return root; } }; 【Trie】字符串的前缀分数和 题目 给你一个长度为 n 的数组 words ，该数组由 非空 字符串组成。\n定义字符串 word 的 分数 等于以 word 作为 前缀 的 words[i] 的数目。\n例如，如果 words = [\u0026quot;a\u0026quot;, \u0026quot;ab\u0026quot;, \u0026quot;abc\u0026quot;, \u0026quot;cab\u0026quot;] ，那么 \u0026quot;ab\u0026quot; 的分数是 2 ，因为 \u0026quot;ab\u0026quot; 是 \u0026quot;ab\u0026quot; 和 \u0026quot;abc\u0026quot; 的一个前缀。 返回一个长度为 n 的数组 answer ，其中 answer[i] 是 words[i] 的每个非空前缀的分数 总和 。\n**注意：**字符串视作它自身的一个前缀。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 输入：words = [\u0026#34;abc\u0026#34;,\u0026#34;ab\u0026#34;,\u0026#34;bc\u0026#34;,\u0026#34;b\u0026#34;] 输出：[5,4,3,2] 解释：对应每个字符串的答案如下： - \u0026#34;abc\u0026#34; 有 3 个前缀：\u0026#34;a\u0026#34;、\u0026#34;ab\u0026#34; 和 \u0026#34;abc\u0026#34; 。 - 2 个字符串的前缀为 \u0026#34;a\u0026#34; ，2 个字符串的前缀为 \u0026#34;ab\u0026#34; ，1 个字符串的前缀为 \u0026#34;abc\u0026#34; 。 总计 answer[0] = 2 + 2 + 1 = 5 。 - \u0026#34;ab\u0026#34; 有 2 个前缀：\u0026#34;a\u0026#34; 和 \u0026#34;ab\u0026#34; 。 - 2 个字符串的前缀为 \u0026#34;a\u0026#34; ，2 个字符串的前缀为 \u0026#34;ab\u0026#34; 。 总计 answer[1] = 2 + 2 = 4 。 - \u0026#34;bc\u0026#34; 有 2 个前缀：\u0026#34;b\u0026#34; 和 \u0026#34;bc\u0026#34; 。 - 2 个字符串的前缀为 \u0026#34;b\u0026#34; ，1 个字符串的前缀为 \u0026#34;bc\u0026#34; 。 总计 answer[2] = 2 + 1 = 3 。 - \u0026#34;b\u0026#34; 有 1 个前缀：\u0026#34;b\u0026#34;。 - 2 个字符串的前缀为 \u0026#34;b\u0026#34; 。 总计 answer[3] = 2 。 示例 2：\n1 2 3 4 5 输入：words = [\u0026#34;abcd\u0026#34;] 输出：[4] 解释： \u0026#34;abcd\u0026#34; 有 4 个前缀 \u0026#34;a\u0026#34;、\u0026#34;ab\u0026#34;、\u0026#34;abc\u0026#34; 和 \u0026#34;abcd\u0026#34;。 每个前缀的分数都是 1 ，总计 answer[0] = 1 + 1 + 1 + 1 = 4 。 提示：\n1 \u0026lt;= words.length \u0026lt;= 1000 1 \u0026lt;= words[i].length \u0026lt;= 1000 words[i] 由小写英文字母组成 解题思路 前缀树模板题了属于是\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;deque\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; const int MAXN = 4e6+6; int p[MAXN][26]; int cnt[MAXN]; int root; int tot; void insert(string s){ int u = root; for(int i=0;i\u0026lt;s.size();i++){ if(!p[u][s[i]-\u0026#39;a\u0026#39;]) p[u][s[i]-\u0026#39;a\u0026#39;] = ++tot; u = p[u][s[i]-\u0026#39;a\u0026#39;]; cnt[u]++; } } int query(string s){ int u = root; int all = 0; for(int i=0;i\u0026lt;s.size();i++){ if(!p[u][s[i]-\u0026#39;a\u0026#39;]) return -1; u = p[u][s[i]-\u0026#39;a\u0026#39;]; all +=cnt[u]; } return all; } class Solution { public: vector\u0026lt;int\u0026gt; sumPrefixScores(vector\u0026lt;string\u0026gt;\u0026amp; words) { root = 0; tot = 0; memset(p,0,sizeof(p)); memset(cnt,0,sizeof(cnt)); for(auto \u0026amp;s : words) insert(s); vector\u0026lt;int\u0026gt; res; for(auto \u0026amp;x: words){ res.push_back(query(x)); } return res; } }; ","date":"2022-09-24T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC311%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220924_hu17982764512120414633.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC311%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第311场周赛总结"},{"content":"\n【模拟】统计共同度过的日子数 题目 Alice 和 Bob 计划分别去罗马开会。\n给你四个字符串 arriveAlice ，leaveAlice ，arriveBob 和 leaveBob 。Alice 会在日期 arriveAlice 到 leaveAlice 之间在城市里（日期为闭区间），而 Bob 在日期 arriveBob 到 leaveBob 之间在城市里（日期为闭区间）。每个字符串都包含 5 个字符，格式为 \u0026quot;MM-DD\u0026quot; ，对应着一个日期的月和日。\n请你返回 Alice和 Bob 同时在罗马的天数。\n你可以假设所有日期都在 同一个 自然年，而且 不是 闰年。每个月份的天数分别为：[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] 。\n示例 1：\n1 2 3 输入：arriveAlice = \u0026#34;08-15\u0026#34;, leaveAlice = \u0026#34;08-18\u0026#34;, arriveBob = \u0026#34;08-16\u0026#34;, leaveBob = \u0026#34;08-19\u0026#34; 输出：3 解释：Alice 从 8 月 15 号到 8 月 18 号在罗马。Bob 从 8 月 16 号到 8 月 19 号在罗马，他们同时在罗马的日期为 8 月 16、17 和 18 号。所以答案为 3 。 示例 2：\n1 2 3 输入：arriveAlice = \u0026#34;10-01\u0026#34;, leaveAlice = \u0026#34;10-31\u0026#34;, arriveBob = \u0026#34;11-01\u0026#34;, leaveBob = \u0026#34;12-31\u0026#34; 输出：0 解释：Alice 和 Bob 没有同时在罗马的日子，所以我们返回 0 。 提示：\n所有日期的格式均为 \u0026quot;MM-DD\u0026quot; 。 Alice 和 Bob 的到达日期都 早于或等于 他们的离开日期。 题目测试用例所给出的日期均为 非闰年 的有效日期。 解题思路 这种模拟题用C++模拟挺费时的，尤其是在浏览器上码代码\n求两个区间[x1,y1]，[x2,y2]的重叠部分，可以用min(y1,y2)-max(x1,x2)，看是否大于0\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) { int a[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; int sum[13] ={0}; for(int i=1;i\u0026lt;=12;i++) sum[i] = sum[i-1]+a[i-1]; // for(int i=1;i\u0026lt;=12;i++) cout\u0026lt;\u0026lt;sum[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;cout\u0026lt;\u0026lt;endl; int a1 = (arriveAlice[0]-\u0026#39;0\u0026#39;)*10+(arriveAlice[1]-\u0026#39;0\u0026#39;); int a2 = (leaveAlice[0]-\u0026#39;0\u0026#39;)*10+(leaveAlice[1]-\u0026#39;0\u0026#39;); int b1 = (arriveAlice[3]-\u0026#39;0\u0026#39;)*10+(arriveAlice[4]-\u0026#39;0\u0026#39;); int b2 = (leaveAlice[3]-\u0026#39;0\u0026#39;)*10+(leaveAlice[4]-\u0026#39;0\u0026#39;); int x1 = sum[a1-1]+b1,y1=sum[a2-1]+b2; // cout\u0026lt;\u0026lt;x1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y1\u0026lt;\u0026lt;endl; a1 = (arriveBob[0]-\u0026#39;0\u0026#39;)*10+(arriveBob[1]-\u0026#39;0\u0026#39;); a2 = (leaveBob[0]-\u0026#39;0\u0026#39;)*10+(leaveBob[1]-\u0026#39;0\u0026#39;); b1 = (arriveBob[3]-\u0026#39;0\u0026#39;)*10+(arriveBob[4]-\u0026#39;0\u0026#39;); b2 = (leaveBob[3]-\u0026#39;0\u0026#39;)*10+(leaveBob[4]-\u0026#39;0\u0026#39;); int x2 = sum[a1-1]+b1,y2=sum[a2-1]+b2; // cout\u0026lt;\u0026lt;x2\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y2\u0026lt;\u0026lt;endl; int res = 0; // vector\u0026lt;int\u0026gt; vis(380,0); // for(int i=x1;i\u0026lt;=y1;i++) vis[i]++; // for(int i=x2;i\u0026lt;=y2;i++) vis[i]++; // for(int i=1;i\u0026lt;=365;i++) if(vis[i]\u0026gt;=2) res++; return max(0,min(y2,y1)-max(x2,x1)+1); } }; 【贪心】运动员和训练师的最大匹配数 题目 给你一个下标从 0 开始的整数数组 players ，其中 players[i] 表示第 i 名运动员的 能力 值，同时给你一个下标从 0 开始的整数数组 trainers ，其中 trainers[j] 表示第 j 名训练师的 训练能力值 。\n如果第 i 名运动员的能力值 小于等于 第 j 名训练师的能力值，那么第 i 名运动员可以 匹配 第 j 名训练师。除此以外，每名运动员至多可以匹配一位训练师，每位训练师最多可以匹配一位运动员。\n请你返回满足上述要求 players 和 trainers 的 最大 匹配数。\n示例 1：\n1 2 3 4 5 6 7 输入：players = [4,7,9], trainers = [8,2,5,8] 输出：2 解释： 得到两个匹配的一种方案是： - players[0] 与 trainers[0] 匹配，因为 4 \u0026lt;= 8 。 - players[1] 与 trainers[3] 匹配，因为 7 \u0026lt;= 8 。 可以证明 2 是可以形成的最大匹配数。 示例 2：\n1 2 3 4 5 输入：players = [1,1,1], trainers = [10] 输出：1 解释： 训练师可以匹配所有 3 个运动员 每个运动员至多只能匹配一个训练师，所以最大答案是 1 。 提示：\n1 \u0026lt;= players.length, trainers.length \u0026lt;= 10^5 1 \u0026lt;= players[i], trainers[j] \u0026lt;= 10^9 解题思路 对运动员按能力值从小到大排序，肯定先对能力值小的运行员选择训练师，训练师的选择也是尽可能的选小的，可以利用双指针或者堆进行维护\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int matchPlayersAndTrainers(vector\u0026lt;int\u0026gt;\u0026amp; players, vector\u0026lt;int\u0026gt;\u0026amp; trainers) { int n = players.size(); sort(players.begin(),players.end()); priority_queue\u0026lt;int,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt;\u0026gt; pq; for(auto \u0026amp;x: trainers) pq.push(x); int res=0; for(int i=0;i\u0026lt;n;i++){ while(!pq.empty() \u0026amp;\u0026amp; pq.top()\u0026lt;players[i]) pq.pop(); if(pq.empty()) break; pq.pop();res++; } return res; } }; 【双指针】按位或最大的最小子数组长度 题目 给你一个长度为 n 下标从 0 开始的数组 nums ，数组中所有数字均为非负整数。对于 0 到 n - 1 之间的每一个下标 i ，你需要找出 nums 中一个 最小 非空子数组，它的起始位置为 i （包含这个位置），同时有 最大 的 按位或运算值 。\n换言之，令 $B_{ij}$ 表示子数组 nums[i...j] 的按位或运算的结果，你需要找到一个起始位置为 i 的最小子数组，这个子数组的按位或运算的结果等于 $max(B_{ik})$ ，其中 i \u0026lt;= k \u0026lt;= n - 1 。 一个数组的按位或运算值是这个数组里所有数字按位或运算的结果。\n请你返回一个大小为 n 的整数数组 answer，其中 answer[i]是开始位置为 i ，按位或运算结果最大，且 最短 子数组的长度。\n子数组 是数组里一段连续非空元素组成的序列。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 输入：nums = [1,0,2,1,3] 输出：[3,3,2,2,1] 解释： 任何位置开始，最大按位或运算的结果都是 3 。 - 下标 0 处，能得到结果 3 的最短子数组是 [1,0,2] 。 - 下标 1 处，能得到结果 3 的最短子数组是 [0,2,1] 。 - 下标 2 处，能得到结果 3 的最短子数组是 [2,1] 。 - 下标 3 处，能得到结果 3 的最短子数组是 [1,3] 。 - 下标 4 处，能得到结果 3 的最短子数组是 [3] 。 所以我们返回 [3,3,2,2,1] 。 示例 2：\n1 2 3 4 5 6 输入：nums = [1,2] 输出：[2,1] 解释： 下标 0 处，能得到最大按位或运算值的最短子数组长度为 2 。 下标 1 处，能得到最大按位或运算值的最短子数组长度为 1 。 所以我们返回 [2,1] 。 提示：\nn == nums.length 1 \u0026lt;= n \u0026lt;= 10^5 0 \u0026lt;= nums[i] \u0026lt;= 10^9 解题思路 赛时想到的思路是 倒序处理每一个数\n对于最后一个数，答案肯定是1\n维护倒序遍历过程中的最大或运算值maxv，记录尾指针tail，利用双指针维护拥有最大或运算值的结尾。\n什么时候尾指针tail可以减小呢，当减去尾指针元素的贡献时，maxv不会缩小则可以减小\nWA了一发是写错了一个条件判断\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public: vector\u0026lt;int\u0026gt; smallestSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; res(n,0); res[n-1] = 1;//最后一个元素的答案必定是1 int maxv = nums[n-1]; int curv = nums[n-1]; int tail = n-1; vector\u0026lt;int\u0026gt; a(32,0); for(int i=0;i\u0026lt;32;i++){ if((curv \u0026gt;\u0026gt; i)\u0026amp;1) a[i]++; } auto getv = [\u0026amp;]()-\u0026gt;int{ int v = 0; for(int i=0;i\u0026lt;32;i++){ if(a[i]\u0026gt;0) v += (1\u0026lt;\u0026lt;i); } return v; }; for(int i=n-2;i\u0026gt;=0;i--){ for(int j=0;j\u0026lt;32;j++) if((nums[i]\u0026gt;\u0026gt;j)\u0026amp;1) a[j]++; curv = getv(); maxv = max(maxv, curv); while(tail\u0026gt;i){ for(int j=0;j\u0026lt;32;j++) if((nums[tail]\u0026gt;\u0026gt;j)\u0026amp;1) a[j]--; if(getv() \u0026lt; maxv ){ for(int j=0;j\u0026lt;32;j++) if((nums[tail]\u0026gt;\u0026gt;j)\u0026amp;1) a[j]++; break; } tail--; } res[i] = tail-i+1; } return res; } }; 【思维+枚举】完成所有交易的初始最少钱数 题目 给你一个下标从 0 开始的二维整数数组 transactions，其中transactions[i] = [costi, cashbacki] 。\n数组描述了若干笔交易。其中每笔交易必须以 某种顺序 恰好完成一次。在任意一个时刻，你有一定数目的钱 money ，为了完成交易 i ，money \u0026gt;= costi 这个条件必须为真。执行交易后，你的钱数 money 变成 money - costi + cashbacki 。\n请你返回 任意一种 交易顺序下，你都能完成所有交易的最少钱数 money 是多少。\n示例 1：\n1 2 3 4 5 输入：transactions = [[2,1],[5,0],[4,2]] 输出：10 解释： 刚开始 money = 10 ，交易可以以任意顺序进行。 可以证明如果 money \u0026lt; 10 ，那么某些交易无法进行。 示例 2：\n1 2 3 4 5 6 输入：transactions = [[3,0],[0,3]] 输出：3 解释： - 如果交易执行的顺序是 [[3,0],[0,3]] ，完成所有交易需要的最少钱数是 3 。 - 如果交易执行的顺序是 [[0,3],[3,0]] ，完成所有交易需要的最少钱数是 0 。 所以，刚开始钱数为 3 ，任意顺序下交易都可以全部完成。 提示：\n1 \u0026lt;= transactions.length \u0026lt;= 10^5 transactions[i].length == 2 0 \u0026lt;= costi, cashbacki \u0026lt;= 10^9 解题思路 对于每个交易[cost, cashback]，假定交易后的钱数为y，那么根据题意有，交易前的钱数x\u0026gt;=y+cost-cashback，为了满足最小，x应当取y+cost-castback。当然，上述是在cost\u0026gt;=cashback的情况下。那如果cost\u0026lt;cashback呢，这时候，x应当满足x\u0026gt;=max(cost,y)。\n题中所求的是所有情况下，都要能完成交易的最少初始钱数。\n倒过来进行考虑，枚举第i个交易作为最后一个交易，此时最后交易前的钱数y = cost_i，逆推过去，对于其他的交易，如果cost\u0026gt;=cashback，y应该增大，累加即可，如果cost\u0026lt;cashback，应该令其不影响y，取0即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: long long minimumMoney(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; transactions) { int n = transactions.size(); vector\u0026lt;long long\u0026gt; ini(n,0), diff(n,0); long long sum=0; for(int i=0;i\u0026lt;n;i++) { ini[i] = transactions[i][0]; diff[i] = transactions[i][0] - transactions[i][1]; diff[i] = max(1ll*0,diff[i]); sum += diff[i]; } long long res = 0; for(int i=0;i\u0026lt;n;i++){//以第i件商品做最后一件 long long cur = sum-diff[i] + ini[i]; res = max({res, cur, ini[i]}); } return res; } }; ","date":"2022-09-23T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC87%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220923_hu15621467526608397465.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC87%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第87场双周赛总结"},{"content":"\n久违的掉大分\n【模拟】出现最频繁的偶数元素 题目 给你一个整数数组 nums ，返回出现最频繁的偶数元素。\n如果存在多个满足条件的元素，只需要返回 最小 的一个。如果不存在这样的元素，返回 -1 。\n示例 1：\n1 2 3 4 5 输入：nums = [0,1,2,2,4,4,1] 输出：2 解释： 数组中的偶数元素为 0、2 和 4 ，在这些元素中，2 和 4 出现次数最多。 返回最小的那个，即返回 2 。 示例 2：\n1 2 3 输入：nums = [4,4,4,9,2,4] 输出：4 解释：4 是出现最频繁的偶数元素。 示例 3：\n1 2 3 输入：nums = [29,47,21,41,13,37,25,7] 输出：-1 解释：不存在偶数元素。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 2000 0 \u0026lt;= nums[i] \u0026lt;= 10^5 解题思路 按题意模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAXN = 105; class Solution { public: int mostFrequentEven(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); map\u0026lt;int,int\u0026gt; tab; for(auto \u0026amp;x: nums){ tab[x]++; } int cnt=0,res=-1; for(auto \u0026amp;x:tab){ if(x.first\u0026amp;1) continue; if(x.second\u0026gt;cnt){ cnt=x.second; res = x.first; } } return res; } }; 【贪心】子字符串的最优划分 题目 给你一个字符串 s ，请你将该字符串划分成一个或多个 子字符串 ，并满足每个子字符串中的字符都是 唯一 的。也就是说，在单个子字符串中，字母的出现次数都不超过 一次 。\n满足题目要求的情况下，返回 最少 需要划分多少个子字符串*。*\n注意，划分后，原字符串中的每个字符都应该恰好属于一个子字符串。\n示例 1：\n1 2 3 4 5 输入：s = \u0026#34;abacaba\u0026#34; 输出：4 解释： 两种可行的划分方法分别是 (\u0026#34;a\u0026#34;,\u0026#34;ba\u0026#34;,\u0026#34;cab\u0026#34;,\u0026#34;a\u0026#34;) 和 (\u0026#34;ab\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;ca\u0026#34;,\u0026#34;ba\u0026#34;) 。 可以证明最少需要划分 4 个子字符串。 示例 2：\n1 2 3 4 输入：s = \u0026#34;ssssss\u0026#34; 输出：6 解释： 只存在一种可行的划分方法 (\u0026#34;s\u0026#34;,\u0026#34;s\u0026#34;,\u0026#34;s\u0026#34;,\u0026#34;s\u0026#34;,\u0026#34;s\u0026#34;,\u0026#34;s\u0026#34;) 。 提示：\n1 \u0026lt;= s.length \u0026lt;= 10^5 s 仅由小写英文字母组成 解题思路 每次出现重复字母时再新起一个划分\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Solution { public: int partitionString(string s) { int n = s.size(); int res=0; map\u0026lt;char,int\u0026gt; tab; for(int i=0;i\u0026lt;n;i++){ if(!tab.count(s[i])){ tab[s[i]]=i; }else{ res++; tab.clear(); tab[s[i]]=i; } } if(!tab.empty()) res++; return res; } }; 【二分/贪心+优先队列/差分数组】将区间分为最少组数 题目 给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示 闭 区间 [lefti, righti] 。\n你需要将 intervals 划分为一个或者多个区间 组 ，每个区间 只 属于一个组，且同一个组中任意两个区间 不相交 。\n请你返回 最少 需要划分成多少个组。\n如果两个区间覆盖的范围有重叠（即至少有一个公共数字），那么我们称这两个区间是 相交 的。比方说区间 [1, 5] 和 [5, 8] 相交。\n示例 1：\n1 2 3 4 5 6 7 输入：intervals = [[5,10],[6,8],[1,5],[2,3],[1,10]] 输出：3 解释：我们可以将区间划分为如下的区间组： - 第 1 组：[1, 5] ，[6, 8] 。 - 第 2 组：[2, 3] ，[5, 10] 。 - 第 3 组：[1, 10] 。 可以证明无法将区间划分为少于 3 个组。 示例 2：\n1 2 3 输入：intervals = [[1,3],[5,6],[8,10],[11,13]] 输出：1 解释：所有区间互不相交，所以我们可以把它们全部放在一个组内。 提示：\n1 \u0026lt;= intervals.length \u0026lt;= 10^5 intervals[i].length == 2 1 \u0026lt;= lefti \u0026lt;= righti \u0026lt;= 10^6 解题思路 经典贪心。但是没印象。\n赛时用的二分。将区间排序（第一维升序，第二维升序），考虑划分成k个组是否ok。对于第i个区间，在k个组中找到第一个结尾最小且不冲突的区间，若不存在则不ok，若存在，则将第i个区间放在该组后面。\n一开始想错了，还以为这个也能二分，最后就是二分套二分，但很显然不是，然后想到了用线段树维护每个组的最小结尾，并记录相应的id。\n然后还RE了一发，是因为自定义排序那儿，手误把a[1]\u0026lt;b[1]打成了b[0]\u0026lt;b[1]。\n其实，这根本用不到二分，按上面的想，如果不存在合法的组，直接新建一个组即可。\n更进一步，直接用一个优先队列维护即可。\n另外一种思路是转换成上下车模型，每个区间看成一个人，他在 left 时刻上车，right+1 时刻下车，最后答案为同时在车上的人数的最大值。这可以用差分数组实现\n代码 二分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include\u0026lt;bits/stdc++.h\u0026gt; #define ls(p) (p\u0026lt;\u0026lt;1) #define rs(p) (p\u0026lt;\u0026lt;1|1) using namespace std; const int MAXN = 1e5+5; struct node{ int minv,idx; }T[MAXN\u0026lt;\u0026lt;2]; void push_up(int p){ T[p].minv = min(T[ls(p)].minv, T[rs(p)].minv); T[p].idx = T[ls(p)].minv\u0026lt;=T[rs(p)].minv?T[ls(p)].idx:T[rs(p)].idx; } void build(int p, int l, int r){ if(l==r){ T[p].minv = 0; T[p].idx=l; return ; } int mid=(l+r)\u0026gt;\u0026gt;1; build(ls(p),l,mid); build(rs(p),mid+1,r); push_up(p); } void update(int p, int l, int r, int lr, int val){ if(l==r \u0026amp;\u0026amp; l==lr){ T[p].minv = val; return; } int mid=(l+r)\u0026gt;\u0026gt;1; if(lr\u0026lt;=mid) update(ls(p),l,mid,lr,val); else update(rs(p),mid+1,r,lr,val); push_up(p); } int query(int p, int l, int r, int val){ if(T[p].minv\u0026gt;=val) return -1; if(l==r) return T[p].idx; int mid=(l+r)\u0026gt;\u0026gt;1; if(T[ls(p)].minv\u0026lt;val) return query(ls(p),l,mid,val); else return query(rs(p),mid+1,r,val); } class Solution { public: int minGroups(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { int n = intervals.size(); sort(intervals.begin(), intervals.end(),[\u0026amp;](vector\u0026lt;int\u0026gt;\u0026amp; a, vector\u0026lt;int\u0026gt;\u0026amp;b){ if(a[0]!=a[1]) return a[0]\u0026lt;b[0]; return a[1]\u0026lt;b[1]; }); auto C =[\u0026amp;](int k)-\u0026gt;bool{ build(1,1,k); for(int i=0;i\u0026lt;n;i++){ int idx = query(1,1,k,intervals[i][0]); if(idx==-1) return false; update(1,1,k,idx,intervals[i][1]); } return true; }; int left=1,right=n+1; while(left\u0026lt;right){ int mid=(left+right)\u0026gt;\u0026gt;1; if(C(mid)) right = mid; else left = mid+1; } return right; // return 0; } }; 优先队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int minGroups(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { sort(intervals.begin(),intervals.end(),[](auto \u0026amp;a,auto \u0026amp;b){ if(a[0]!=b[0]) return a[0]\u0026lt;b[0]; return a[1]\u0026lt;b[1]; }); priority_queue\u0026lt;int,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt;\u0026gt; pq; for(auto \u0026amp;inter: intervals){ if(!pq.empty() \u0026amp;\u0026amp; pq.top()\u0026lt;inter[0]) pq.pop(); pq.emplace(inter[1]); } return pq.size(); } }; 差分 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int minGroups(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;intervals) { map\u0026lt;int, int\u0026gt; diff; for (auto \u0026amp;p : intervals) ++diff[p[0]], --diff[p[1] + 1]; int ans = 0, sum = 0; for (auto \u0026amp;[_, d] : diff) ans = max(ans, sum += d); return ans; } }; 【线段树优化DP】最长递增子序列 II 题目 给你一个整数数组 nums 和一个整数 k 。\n找到 nums 中满足以下要求的最长子序列：\n子序列 严格递增 子序列中相邻元素的差值 不超过 k 。 请你返回满足上述要求的 最长子序列 的长度。\n子序列 是从一个数组中删除部分元素后，剩余元素不改变顺序得到的数组。\n示例 1：\n1 2 3 4 5 6 输入：nums = [4,2,1,4,3,4,5,8,15], k = 3 输出：5 解释： 满足要求的最长子序列是 [1,3,4,5,8] 。 子序列长度为 5 ，所以我们返回 5 。 注意子序列 [1,3,4,5,8,15] 不满足要求，因为 15 - 8 = 7 大于 3 。 示例 2：\n1 2 3 4 5 输入：nums = [7,4,5,1,8,12,4,7], k = 5 输出：4 解释： 满足要求的最长子序列是 [4,5,8,12] 。 子序列长度为 4 ，所以我们返回 4 。 示例 3：\n1 2 3 4 5 输入：nums = [1,5], k = 1 输出：1 解释： 满足要求的最长子序列是 [1] 。 子序列长度为 1 ，所以我们返回 1 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i], k \u0026lt;= 10^5 解题思路 普通LIS的常规解法是$O(n^2)$的dp，有一种$O(n\\ logn)$的解法是基于二分的dp。\n碰到这题往二分那种思路想了，即dp[i]表示长度为i的最小元素，结果没整出来\n赛后才了解到，还能用线段树实现$O(n\\ logn)$复杂度的普通LIS。\n对于这题，令dp[i][j]表示前i个数且末尾元素为j的合法LIS的最长长度，\n那么以j结尾的合法LIS的前一个数字的值域应在[j-k, j-1]范围内 dp[i][j] = max{ dp[i-1][j-k\u0026hellip;j-1] }+1，\n第一维可以省略\n利用线段树维护这个dp数组\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 const int MAXN = 1e5+5; #define ls(p) (p\u0026lt;\u0026lt;1) #define rs(p) (p\u0026lt;\u0026lt;1|1) struct node{ int maxv; }T[MAXN\u0026lt;\u0026lt;2]; void push_up(int p){ T[p].maxv = max(T[ls(p)].maxv, T[rs(p)].maxv); } void build(int p, int l, int r){ if(l==r){ T[p].maxv = 0; return; } int mid = (l+r)\u0026gt;\u0026gt;1; build(ls(p),l,mid); build(rs(p),mid+1,r); push_up(p); } void update(int p,int l,int r,int nl,int nr,int v){ if(nl\u0026lt;=l \u0026amp;\u0026amp; nr\u0026gt;=r){ T[p].maxv = v; return; } int mid=(l+r)\u0026gt;\u0026gt;1; if(nl\u0026lt;=mid) update(ls(p),l,mid,nl,nr,v); if(nr\u0026gt;mid) update(rs(p),mid+1,r,nl,nr,v); push_up(p); } int query(int p,int l,int r,int nl,int nr){ if(nl\u0026lt;=l \u0026amp;\u0026amp; nr\u0026gt;=r) return T[p].maxv; int mid=(l+r)\u0026gt;\u0026gt;1; int res=0; if(nl\u0026lt;=mid) res=max(res,query(ls(p),l,mid,nl,nr)); if(nr\u0026gt;mid) res=max(res,query(rs(p),mid+1,r,nl,nr)); return res; } class Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); //dp[j] 前i个数以j结尾的LIS长度，省略第一维 vector\u0026lt;int\u0026gt; dp(MAXN,0); int m = 1e5; build(1,1,m); dp[nums[0]]++; update(1,1,m,nums[0],nums[0],1); for(int i=1;i\u0026lt;n;i++){ // nums[i]-k \u0026lt;= pre \u0026lt; nums[i] if(nums[i]==1){ update(1,1,m,nums[i],nums[i],1); continue; } int left; if(nums[i]-k\u0026lt;=1) left=1; else left = nums[i]-k; int pv = query(1,1,m,left,nums[i]-1); update(1,1,m,nums[i],nums[i],pv+1); } return query(1,1,m,1,m); } }; ","date":"2022-09-16T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC310%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220916_hu16624249537443371537.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC310%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第310场周赛总结"},{"content":"\n【模拟】检查相同字母间的距离 题目 给你一个下标从 0 开始的字符串 s ，该字符串仅由小写英文字母组成，s 中的每个字母都 恰好 出现 两次 。另给你一个下标从 0 开始、长度为 26 的的整数数组 distance 。\n字母表中的每个字母按从 0 到 25 依次编号（即，'a' -\u0026gt; 0, 'b' -\u0026gt; 1, 'c' -\u0026gt; 2, \u0026hellip; , 'z' -\u0026gt; 25）。\n在一个 匀整 字符串中，第 i 个字母的两次出现之间的字母数量是 distance[i] 。如果第 i 个字母没有在 s 中出现，那么 distance[i] 可以 忽略 。\n如果 s 是一个 匀整 字符串，返回 true ；否则，返回 false 。\n示例 1：\n1 2 3 4 5 6 7 8 输入：s = \u0026#34;abaccb\u0026#34;, distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] 输出：true 解释： - \u0026#39;a\u0026#39; 在下标 0 和下标 2 处出现，所以满足 distance[0] = 1 。 - \u0026#39;b\u0026#39; 在下标 1 和下标 5 处出现，所以满足 distance[1] = 3 。 - \u0026#39;c\u0026#39; 在下标 3 和下标 4 处出现，所以满足 distance[2] = 0 。 注意 distance[3] = 5 ，但是由于 \u0026#39;d\u0026#39; 没有在 s 中出现，可以忽略。 因为 s 是一个匀整字符串，返回 true 。 示例 2：\n1 2 3 4 5 输入：s = \u0026#34;aa\u0026#34;, distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] 输出：false 解释： - \u0026#39;a\u0026#39; 在下标 0 和 1 处出现，所以两次出现之间的字母数量为 0 。 但是 distance[0] = 1 ，s 不是一个匀整字符串。 提示：\n2 \u0026lt;= s.length \u0026lt;= 52 s 仅由小写英文字母组成 s 中的每个字母恰好出现两次 distance.length == 26 0 \u0026lt;= distance[i] \u0026lt;= 50 解题思路 按题意模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Solution { public: bool checkDistances(string s, vector\u0026lt;int\u0026gt;\u0026amp; distance) { int n = s.size(); map\u0026lt;int,int\u0026gt; tab; for(int i = 0; i\u0026lt;n;i++){ if(!tab.count(s[i]-\u0026#39;a\u0026#39;)) tab[s[i]-\u0026#39;a\u0026#39;] = i; else{ if(i-tab[s[i]-\u0026#39;a\u0026#39;]-1!=distance[s[i]-\u0026#39;a\u0026#39;]) return false; } } return true; } }; 【动态规划/组合数学】恰好移动 k 步到达某一位置的方法数目 题目 给你两个 正 整数 startPos 和 endPos 。最初，你站在 无限 数轴上位置 startPos 处。在一步移动中，你可以向左或者向右移动一个位置。\n给你一个正整数 k ，返回从 startPos 出发、恰好 移动 k 步并到达 endPos 的 不同 方法数目。由于答案可能会很大，返回对 109 + 7 取余 的结果。\n如果所执行移动的顺序不完全相同，则认为两种方法不同。\n注意：数轴包含负整数。\n示例 1：\n1 2 3 4 5 6 7 输入：startPos = 1, endPos = 2, k = 3 输出：3 解释：存在 3 种从 1 到 2 且恰好移动 3 步的方法： - 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 2. - 1 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; 2. - 1 -\u0026gt; 0 -\u0026gt; 1 -\u0026gt; 2. 可以证明不存在其他方法，所以返回 3 。 示例 2：\n1 2 3 输入：startPos = 2, endPos = 5, k = 10 输出：0 解释：不存在从 2 到 5 且恰好移动 10 步的方法。 提示：\n1 \u0026lt;= startPos, endPos, k \u0026lt;= 1000 解题思路 一开始想用记忆化搜索，没调对，赶快直接动规了\n由于可能出现负数坐标，做个向右的偏移\n令dp[i][j]表示到达坐标i，且走的步数为j的方案数\n状态转移有：dp[i][j] = dp[i-1][j-1]+dp[i+1][j-1]\n其实也可以直接用组合数学进行求解：\n经过k步从startPos到endPos，最短距离为x = endPos-startPos\n如果k\u0026lt;x，那么肯定走不到\n如果(k-x)\u0026amp;1，即超过x奇数步，同样也肯定走不到\n以组合数学的角度上看，需要x+(k-x)/2步是正方向，需要(k-x)/2步是反方向，如此才能保证恰好走到目的地\n即$C_k^{k-(endPos-startPos)/2}$\n代码 动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int MOD = 1e9+7; class Solution { public: int numberOfWays(int startPos, int endPos, int k) { //向右偏移2000 ll dp[5000][1005]; memset(dp,0,sizeof(dp)); dp[startPos+2000][0] = 1; for(int i=1;i\u0026lt;=k;i++){ for(int j=1;j\u0026lt;5000;j++){ if(dp[j][i-1]){ dp[j-1][i] = (dp[j][i-1]+ dp[j-1][i])%MOD; dp[j+1][i] = (dp[j][i-1]+ dp[j+1][i])%MOD; } } } return dp[endPos+2000][k]%MOD; } }; 组合数学 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int MOD = 1e9+7; ll c[1005][1005]; int tmp=[]()-\u0026gt;int{ c[0][0]=c[1][0]=c[1][1]=1; for(int i=1;i\u0026lt;=1000;i++){ c[i][0]=1; for(int j=1;j\u0026lt;=1000;j++) c[i][j] = (c[i-1][j]+c[i-1][j-1])%MOD; } return 0; }(); class Solution { public: int numberOfWays(int startPos, int endPos, int k) { int x = endPos-startPos; if(k\u0026lt;x) return 0; if((k-x)\u0026amp;1) return 0; return c[k][(k-x)/2]; } }; 【二分/滑动窗口】最长优雅子数组 题目 给你一个由 正 整数组成的数组 nums 。\n如果 nums 的子数组中位于 不同 位置的每对元素按位 **与（AND）**运算的结果等于 0 ，则称该子数组为 优雅 子数组。\n返回 最长 的优雅子数组的长度。\n子数组 是数组中的一个 连续 部分。\n**注意：**长度为 1 的子数组始终视作优雅子数组。\n示例 1：\n1 2 3 4 5 6 7 输入：nums = [1,3,8,48,10] 输出：3 解释：最长的优雅子数组是 [3,8,48] 。子数组满足题目条件： - 3 AND 8 = 0 - 3 AND 48 = 0 - 8 AND 48 = 0 可以证明不存在更长的优雅子数组，所以返回 3 。 示例 2：\n1 2 3 输入：nums = [3,1,5,11,13] 输出：1 解释：最长的优雅子数组长度为 1 ，任何长度为 1 的子数组都满足题目条件。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^9 解题思路 赛时用的二分\n利用前缀和判断是否存在长度为k的优雅子数组\n（其实优雅子数组的长度不会超过30）\n优雅数组中的所有数要满足32位上，每一位最多只能有1个1\n代码 二分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int MOD = 1e9+7; using namespace std; class Solution { public: int longestNiceSubarray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int sum[n+1][32]; memset(sum,0,sizeof(sum)); for(int i=1;i\u0026lt;=n;i++){ for(int j=0;j\u0026lt;32;j++){ if((nums[i-1]\u0026gt;\u0026gt;j)\u0026amp;1) sum[i][j] = sum[i-1][j]+1; else sum[i][j] = sum[i-1][j]; } } function\u0026lt;bool(int)\u0026gt; C =[\u0026amp;](int k)-\u0026gt;bool{ for(int i=1;i+k-1\u0026lt;=n;i++){ bool res = true; for(int j=0;j\u0026lt;32;j++){ if(sum[i+k-1][j]-sum[i-1][j]\u0026gt;1) { res = false;break; } } if(res) return true; } return false; }; int l=1,r=n+1; while(l\u0026lt;r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(C(mid)) l=mid+1; else r=mid; } return l-1; } }; 偷学代码 滑动窗口 如果一个区间是优雅的，那么它的子区间肯定也是优雅的（因为二进制位中出现 11 的次数不会增多），因此可以使用 two pointers 解决。\nright每次右移都判断下都用nums[right]和[left, right)之间的数字从right - 1开始到left做相与判断，如果不为0，则让left记录最后一个相与为0的位置。记录下此次right - left + 1的值，如此类推，用res记录每次循环的最大窗口值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int longestNiceSubarray(int* nums, int numsSize) { int left = 0; int right = 0; int res = 0; while (right \u0026lt; numsSize) { int cur = nums[right]; for (int i = right - 1; i \u0026gt;= left; --i) { if ((nums[i] \u0026amp; cur) != 0) { left = i + 1; } } res = fmax(res, right - left + 1); right++; } return res; } 【模拟】会议室III 题目 给你一个整数 n ，共有编号从 0 到 n - 1 的 n 个会议室。\n给你一个二维整数数组 meetings ，其中 meetings[i] = [starti, endi] 表示一场会议将会在 半闭 时间区间 [starti, endi) 举办。所有 starti 的值 互不相同 。\n会议将会按以下方式分配给会议室：\n每场会议都会在未占用且编号 最小 的会议室举办。 如果没有可用的会议室，会议将会延期，直到存在空闲的会议室。延期会议的持续时间和原会议持续时间 相同 。 当会议室处于未占用状态时，将会优先提供给原 开始 时间更早的会议。 返回举办最多次会议的房间 编号 。如果存在多个房间满足此条件，则返回编号 最小 的房间。\n半闭区间 [a, b) 是 a 和 b 之间的区间，包括 a 但 不包括 b 。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 输入：n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]] 输出：0 解释： - 在时间 0 ，两个会议室都未占用，第一场会议在会议室 0 举办。 - 在时间 1 ，只有会议室 1 未占用，第二场会议在会议室 1 举办。 - 在时间 2 ，两个会议室都被占用，第三场会议延期举办。 - 在时间 3 ，两个会议室都被占用，第四场会议延期举办。 - 在时间 5 ，会议室 1 的会议结束。第三场会议在会议室 1 举办，时间周期为 [5,10) 。 - 在时间 10 ，两个会议室的会议都结束。第四场会议在会议室 0 举办，时间周期为 [10,11) 。 会议室 0 和会议室 1 都举办了 2 场会议，所以返回 0 。 示例 2：\n1 2 3 4 5 6 7 8 9 10 11 输入：n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]] 输出：1 解释： - 在时间 1 ，所有三个会议室都未占用，第一场会议在会议室 0 举办。 - 在时间 2 ，会议室 1 和 2 未占用，第二场会议在会议室 1 举办。 - 在时间 3 ，只有会议室 2 未占用，第三场会议在会议室 2 举办。 - 在时间 4 ，所有三个会议室都被占用，第四场会议延期举办。 - 在时间 5 ，会议室 2 的会议结束。第四场会议在会议室 2 举办，时间周期为 [5,10) 。 - 在时间 6 ，所有三个会议室都被占用，第五场会议延期举办。 - 在时间 10 ，会议室 1 和 2 的会议结束。第五场会议在会议室 1 举办，时间周期为 [10,12) 。 会议室 1 和会议室 2 都举办了 2 场会议，所以返回 1 。 提示：\n1 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= meetings.length \u0026lt;= 10^5 meetings[i].length == 2 0 \u0026lt;= starti \u0026lt; endi \u0026lt;= 5 * 10^5 starti 的所有值 互不相同 解题思路 由于n比较小，可直接遍历一遍找满足条件的会议室\nWA了一发是因为一开始题意没理解好\n如果n比较大，可以利用线段树\n代码 暴力 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int MOD = 1e9+7; using namespace std; class Solution { public: int mostBooked(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; meetings) { vector\u0026lt;ll\u0026gt; a(n, 0);//a[i] 第i个会议室的结束时间 vector\u0026lt;int\u0026gt; cnt(n, 0); sort(meetings.begin(),meetings.end(),[\u0026amp;](vector\u0026lt;int\u0026gt;\u0026amp; x,vector\u0026lt;int\u0026gt;\u0026amp; y){ return x[0]\u0026lt;y[0]; }); int m = meetings.size(); for(int i=0;i\u0026lt;m;i++){ int idx=-1; ll minv = LONG_LONG_MAX; for(int j=0;j\u0026lt;n;j++){ if(a[j]\u0026lt;minv){ minv = a[j]; idx = j; } }//可以先找一轮结束时间最早的 for(int j=0;j\u0026lt;n;j++){ if(a[j]\u0026lt;=meetings[i][0]){ idx = j;break; } }//如果前面有结束时间小于当前时间的话，取代 if(a[idx]\u0026lt;=meetings[i][0]){ a[idx] = meetings[i][1]; }else{ a[idx] = a[idx]+(meetings[i][1]-meetings[i][0]); } cnt[idx]++; // cout\u0026lt;\u0026lt;idx\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;a[idx]\u0026lt;\u0026lt;endl; } int idx=-1,maxv=INT_MIN; for(int i=0;i\u0026lt;n;i++){ if(cnt[i]\u0026gt;maxv){ maxv = cnt[i]; idx=i; } } return idx; } }; 线段树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 const int MAXN = 1e2+5; #define ll long long #define ls(p) (p\u0026lt;\u0026lt;1) #define rs(p) (p\u0026lt;\u0026lt;1|1) struct node{ ll minv; int idx; }T[MAXN\u0026lt;\u0026lt;2]; void push_up(int p){ T[p].minv = min(T[ls(p)].minv, T[rs(p)].minv); T[p].idx = T[ls(p)].minv\u0026lt;=T[rs(p)].minv?T[ls(p)].idx:T[rs(p)].idx; } void build(int p, int l, int r){ if(l==r){ T[p].minv = 0; T[p].idx = l; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(ls(p),l,mid); build(rs(p),mid+1,r); push_up(p); } void update(int p, int l, int r, int lr, pair\u0026lt;int,int\u0026gt; k){ if(l==r \u0026amp;\u0026amp; l==lr){ if(k.first\u0026lt;=T[p].minv) T[p].minv += k.second-k.first; else T[p].minv = k.second; return; } int mid=(l+r)\u0026gt;\u0026gt;1; if(lr\u0026lt;=mid) update(ls(p),l,mid,lr,k); else update(rs(p),mid+1,r,lr,k); push_up(p); } int query(int p, int l, int r, int k){//找第一个值小于等于k的位置 if(T[p].minv\u0026gt;k) return -1; if(l==r) return l; int mid = (l+r)\u0026gt;\u0026gt;1; if(T[ls(p)].minv\u0026lt;=k){ return query(ls(p),l,mid,k); }else return query(rs(p),mid+1,r,k); } class Solution { public: int mostBooked(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; meetings) { int m = meetings.size(); vector\u0026lt;int\u0026gt; cnt(n+1,0); sort(meetings.begin(),meetings.end(),[\u0026amp;](vector\u0026lt;int\u0026gt;\u0026amp; x,vector\u0026lt;int\u0026gt;\u0026amp; y){ return x[0]\u0026lt;y[0]; }); build(1,1,n); for(int i=0;i\u0026lt;m;i++){ int idx=-1; if(T[1].minv\u0026gt;meetings[i][0]){ idx=T[1].idx; }else{ idx = query(1,1,n,meetings[i][0]); } cnt[idx]++; update(1,1,n,idx,make_pair(meetings[i][0],meetings[i][1])); } int res=0,id=0; for(int i=1;i\u0026lt;=n;i++){ if(cnt[i]\u0026gt;res){ res=cnt[i]; id=i-1; } // cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;cnt[i]\u0026lt;\u0026lt;endl; } return id; } }; ","date":"2022-09-10T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC309%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220910_hu6629778652041897633.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC309%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第309场周赛总结"},{"content":"\n【枚举】和相等的子数组 题目 给你一个下标从 0 开始的整数数组 nums ，判断是否存在 两个 长度为 2 的子数组且它们的 和 相等。注意，这两个子数组起始位置的下标必须 不相同 。\n如果这样的子数组存在，请返回 true，否则返回 false 。\n子数组 是一个数组中一段连续非空的元素组成的序列。\n示例 1：\n1 2 3 输入：nums = [4,2,4] 输出：true 解释：元素为 [4,2] 和 [2,4] 的子数组有相同的和 6 。 示例 2：\n1 2 3 输入：nums = [1,2,3,4,5] 输出：false 解释：没有长度为 2 的两个子数组和相等。 示例 3：\n1 2 3 4 输入：nums = [0,0,0] 输出：true 解释：子数组 [nums[0],nums[1]] 和 [nums[1],nums[2]] 的和相等，都为 0 。 注意即使子数组的元素相同，这两个子数组也视为不相同的子数组，因为它们在原数组中的起始位置不同。 提示：\n2 \u0026lt;= nums.length \u0026lt;= 1000 -10^9 \u0026lt;= nums[i] \u0026lt;= 10^9 解题思路 记录出现过的值即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Solution { public: bool findSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); map\u0026lt;long long,int\u0026gt; tab; for(int i=0;i\u0026lt;n-1;i++){ long long cur = nums[i]+nums[i+1]; if(tab.count(cur)) return true; tab[cur]++; } return false; } }; 【思维】严格回文的数字 题目 如果一个整数 n 在 b 进制下（b 为 2 到 n - 2 之间的所有整数）对应的字符串 全部 都是 回文的 ，那么我们称这个数 n 是 严格回文 的。\n给你一个整数 n ，如果 n 是 严格回文 的，请返回 true ，否则返回 false 。\n如果一个字符串从前往后读和从后往前读完全相同，那么这个字符串是 回文的 。\n示例 1：\n1 2 3 4 5 6 输入：n = 9 输出：false 解释：在 2 进制下：9 = 1001 ，是回文的。 在 3 进制下：9 = 100 ，不是回文的。 所以，9 不是严格回文数字，我们返回 false 。 注意在 4, 5, 6 和 7 进制下，n = 9 都不是回文的。 示例 2：\n1 2 3 4 输入：n = 4 输出：false 解释：我们只考虑 2 进制：4 = 100 ，不是回文的。 所以我们返回 false 。 提示：\n4 \u0026lt;= n \u0026lt;= 10^5 解题思路 直觉上来说，这种回文的难度太大了，应该不存在哈哈\n数字 4 在二进制下不是回文的。对于 n ≥ 5，它们的 (n−2) 进制表示都是 12，因此也都不是回文的。直接返回 false 即可\n代码 1 2 3 4 5 6 class Solution { public: bool isStrictlyPalindromic(int n) { return false; } }; 【枚举】被列覆盖的最多行数 题目 给你一个下标从 0 开始的 m x n 二进制矩阵 mat 和一个整数 cols ，表示你需要选出的列数。\n如果一行中，所有的 1 都被你选中的列所覆盖，那么我们称这一行 被覆盖 了。\n请你返回在选择 cols 列的情况下，被覆盖 的行数 最大 为多少。\n示例 1：\n1 2 3 4 5 输入：mat = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], cols = 2 输出：3 解释： 如上图所示，覆盖 3 行的一种可行办法是选择第 0 和第 2 列。 可以看出，不存在大于 3 行被覆盖的方案，所以我们返回 3 。 示例 2：\n1 2 3 4 5 输入：mat = [[1],[0]], cols = 1 输出：2 解释： 选择唯一的一列，两行都被覆盖了，原因是整个矩阵都被覆盖了。 所以我们返回 2 。 提示：\nm == mat.length n == mat[i].length 1 \u0026lt;= m, n \u0026lt;= 12 mat[i][j] 要么是 0 要么是 1 。 1 \u0026lt;= cols \u0026lt;= n 解题思路 NP hard\n只能枚举做了\n复杂度$O(2^n\\times nm)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Solution { public: int maximumRows(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; mat, int cols) { int n = mat.size(), m = mat[0].size(); vector\u0026lt;int\u0026gt; a(m, 0); for(int i=m-1,j=0;j\u0026lt;cols;i--,j++) a[i]=1; int res=0; do{ // for(auto \u0026amp;x: a) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;;cout\u0026lt;\u0026lt;endl; int cur = 0; for(int i=0;i\u0026lt;n;i++){ int all = 0, tmp = 0; for(int j=0;j\u0026lt;m;j++){ if(mat[i][j]==1) all++; if(mat[i][j]==1 \u0026amp;\u0026amp; a[j]==1) tmp++; } if(tmp==all) cur++; } res = max(res, cur); }while(next_permutation(a.begin(),a.end())); return res; } }; 偷学代码（二进制枚举） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: int maximumRows(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; mat, int cols) { int m = mat.size(); int n = mat[0].size(); int ans = 0; vector\u0026lt;int\u0026gt; mask(m); for (int i = 0; i \u0026lt; m; i++) { /* 每一行1的位置, 用二进制表示 */ for (int j = 0; j \u0026lt; n; j++) { mask[i] |= mat[i][j] \u0026lt;\u0026lt; j; } } for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); i++) { if (__builtin_popcount(i) == cols) { /* 选了cols列 */ int cnt = 0; for (int j = 0; j \u0026lt; m; j++) { if ((mask[j] \u0026amp; i) == mask[j]) { /* j行是二进制枚举的子集 */ cnt++; } } ans = max(ans, cnt); } } return ans; } }; 【二分+线段树+前缀和】预算内的最多机器人数目 题目 你有 n 个机器人，给你两个下标从 0 开始的整数数组 chargeTimes 和 runningCosts ，两者长度都为 n 。第 i 个机器人充电时间为 chargeTimes[i] 单位时间，花费 runningCosts[i] 单位时间运行。再给你一个整数 budget 。\n运行 k 个机器人 总开销 是 max(chargeTimes) + k * sum(runningCosts) ，其中 max(chargeTimes) 是这 k 个机器人中最大充电时间，sum(runningCosts) 是这 k 个机器人的运行时间之和。\n请你返回在 不超过 budget 的前提下，你 最多 可以 连续 运行的机器人数目为多少。\n示例 1：\n1 2 3 4 5 6 输入：chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25 输出：3 解释： 可以在 budget 以内运行所有单个机器人或者连续运行 2 个机器人。 选择前 3 个机器人，可以得到答案最大值 3 。总开销是 max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 ，小于 25 。 可以看出无法在 budget 以内连续运行超过 3 个机器人，所以我们返回 3 。 示例 2：\n1 2 3 输入：chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19 输出：0 解释：即使运行任何一个单个机器人，还是会超出 budget，所以我们返回 0 。 提示：\nchargeTimes.length == runningCosts.length == n 1 \u0026lt;= n \u0026lt;= 5 * 10^4 1 \u0026lt;= chargeTimes[i], runningCosts[i] \u0026lt;= 10^5 1 \u0026lt;= budget \u0026lt;= 10^15 解题思路 如果运行连续k个机器人是可行的话，那么运行连续k-1个机器人也肯定不会超预算\n如果运行连续k个机器人是不可行的话，那么运行连续k+1个机器人也肯定会超预算\n考虑二分答案\n需要判断连续k个机器人是否可行\n利用前缀和维护sum(runningCosts)\n利用线段树（或其他rmq数据结构）维护max(chargeTimes)\n上述利用线段树的时间复杂度为$O(n\\ log(n))$\n总时间复杂度为$O(n\\ log^2(n))$\nWA了一发是因为线段树的节点数量忘记\u0026laquo;2了，看来还是要备板子了。。不然速度还是提不上来，可能还会犯小错误。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAXN = 5e4+5; #define ll long long #define ls(p) (p\u0026lt;\u0026lt;1) #define rs(p) (p\u0026lt;\u0026lt;1|1) struct node{ int maxv; }T[MAXN]; void push_up(int p){ T[p].maxv = max(T[ls(p)].maxv, T[rs(p)].maxv); } void build(int p, int l, int r, vector\u0026lt;int\u0026gt; \u0026amp;a){ if(l==r){ T[p].maxv = a[l-1]; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(ls(p),l,mid,a); build(rs(p),mid+1,r,a); push_up(p); } int query(int p, int l, int r, int nl, int nr){ if(nl\u0026lt;=l \u0026amp;\u0026amp; nr\u0026gt;=r) return T[p].maxv; int res = 0; int mid = (l+r)\u0026gt;\u0026gt;1; if(nl\u0026lt;=mid) res = max(res, query(ls(p),l,mid,nl,nr)); if(nr\u0026gt;mid) res = max(res, query(rs(p),mid+1,r,nl,nr)); return res; } class Solution { public: int maximumRobots(vector\u0026lt;int\u0026gt;\u0026amp; chargeTimes, vector\u0026lt;int\u0026gt;\u0026amp; runningCosts, long long budget) { int n = chargeTimes.size(); vector\u0026lt;ll\u0026gt; sum(n+1, 0); for(int i=1;i\u0026lt;=n;i++) sum[i] = sum[i-1]+runningCosts[i-1]; build(1,1,n,chargeTimes); function\u0026lt;bool(int)\u0026gt; C=[\u0026amp;](int k)-\u0026gt;bool{ for(int i=1;i+k-1\u0026lt;=n;i++){ ll run = (sum[i+k-1]-sum[i-1])*1ll*k; ll ma = query(1,1,n,i,i+k-1); ll cur = ma+run; if(cur\u0026lt;=budget) return true; } return false; }; int l=1,r = n+1; while(l\u0026lt;r){ int mid = (l+r)\u0026gt;\u0026gt;1; if(C(mid)) l=mid+1; else r=mid; } return l-1; } }; ","date":"2022-09-09T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC86%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220909_hu3727393499558978241.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC86%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第86场双周赛总结"},{"content":"\n【排序+贪心+前缀和+二分】和有限的最长子序列 题目 给你一个长度为 n 的整数数组 nums ，和一个长度为 m 的整数数组 queries 。\n返回一个长度为 m 的数组 answer ，其中 answer[i] 是 nums 中 元素之和小于等于 queries[i] 的 子序列 的 最大 长度 。\n子序列 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。\n示例 1：\n1 2 3 4 5 6 输入：nums = [4,5,2,1], queries = [3,10,21] 输出：[2,3,4] 解释：queries 对应的 answer 如下： - 子序列 [2,1] 的和小于或等于 3 。可以证明满足题目要求的子序列的最大长度是 2 ，所以 answer[0] = 2 。 - 子序列 [4,5,1] 的和小于或等于 10 。可以证明满足题目要求的子序列的最大长度是 3 ，所以 answer[1] = 3 。 - 子序列 [4,5,2,1] 的和小于或等于 21 。可以证明满足题目要求的子序列的最大长度是 4 ，所以 answer[2] = 4 。 示例 2：\n1 2 3 输入：nums = [2,3,4,5], queries = [1] 输出：[0] 解释：空子序列是唯一一个满足元素和小于或等于 1 的子序列，所以 answer[0] = 0 。 提示：\nn == nums.length m == queries.length 1 \u0026lt;= n, m \u0026lt;= 1000 1 \u0026lt;= nums[i], queries[i] \u0026lt;= 10^6 解题思路 选取子序列，和顺序无关，可以考虑先排序\n元素之和小于等于一个数的最大长度，为了选的数更多，肯定先考虑选小的数\n求个前缀和\n在前缀和数组上找大于queries[i]的第一个位置idx，那么前idx-1个元素是小于等于queries[i]的最大长度\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: vector\u0026lt;int\u0026gt; answerQueries(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;int\u0026gt;\u0026amp; queries) { int n = nums.size(), m = queries.size(); vector\u0026lt;long long\u0026gt; sum(n+1,0); sort(nums.begin(),nums.end()); for(int i=1;i\u0026lt;=n;i++) sum[i] = sum[i-1]+nums[i-1]; vector\u0026lt;int\u0026gt; res; for(int i=0;i\u0026lt;m;i++){ int idx = upper_bound(sum.begin(),sum.end(),queries[i])-sum.begin(); res.push_back(idx-1); } return res; } }; 【模拟】从字符串中移除星号 题目 给你一个包含若干星号 * 的字符串 s 。\n在一步操作中，你可以：\n选中 s 中的一个星号。 移除星号 左侧 最近的那个 非星号 字符，并移除该星号自身。 返回移除 所有 星号之后的字符串**。**\n注意：\n生成的输入保证总是可以执行题面中描述的操作。 可以证明结果字符串是唯一的。 示例 1：\n1 2 3 4 5 6 7 输入：s = \u0026#34;leet**cod*e\u0026#34; 输出：\u0026#34;lecoe\u0026#34; 解释：从左到右执行移除操作： - 距离第 1 个星号最近的字符是 \u0026#34;leet**cod*e\u0026#34; 中的 \u0026#39;t\u0026#39; ，s 变为 \u0026#34;lee*cod*e\u0026#34; 。 - 距离第 2 个星号最近的字符是 \u0026#34;lee*cod*e\u0026#34; 中的 \u0026#39;e\u0026#39; ，s 变为 \u0026#34;lecod*e\u0026#34; 。 - 距离第 3 个星号最近的字符是 \u0026#34;lecod*e\u0026#34; 中的 \u0026#39;d\u0026#39; ，s 变为 \u0026#34;lecoe\u0026#34; 。 不存在其他星号，返回 \u0026#34;lecoe\u0026#34; 。 示例 2：\n1 2 3 输入：s = \u0026#34;erase*****\u0026#34; 输出：\u0026#34;\u0026#34; 解释：整个字符串都会被移除，所以返回空字符串。 提示：\n1 \u0026lt;= s.length \u0026lt;= 10^5 s 由小写英文字母和星号 * 组成 s 可以执行上述操作 解题思路 利用栈模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: string removeStars(string s) { int n = s.size(); stack\u0026lt;char\u0026gt; stk; string res; for(int i=0;i\u0026lt;n;i++){ if(s[i]!=\u0026#39;*\u0026#39;) stk.push(s[i]); else if(!stk.empty()) stk.pop(); } while(!stk.empty()) { res+=stk.top(); stk.pop(); } reverse(res.begin(),res.end()); return res; } }; 【模拟】收集垃圾的最少总时间 题目 给你一个下标从 0 开始的字符串数组 garbage ，其中 garbage[i] 表示第 i 个房子的垃圾集合。garbage[i] 只包含字符 'M' ，'P' 和 'G' ，但可能包含多个相同字符，每个字符分别表示一单位的金属、纸和玻璃。垃圾车收拾 一 单位的任何一种垃圾都需要花费 1 分钟。\n同时给你一个下标从 0 开始的整数数组 travel ，其中 travel[i] 是垃圾车从房子 i 行驶到房子 i + 1 需要的分钟数。\n城市里总共有三辆垃圾车，分别收拾三种垃圾。每辆垃圾车都从房子 0 出发，按顺序 到达每一栋房子。但它们 不是必须 到达所有的房子。\n任何时刻只有 一辆 垃圾车处在使用状态。当一辆垃圾车在行驶或者收拾垃圾的时候，另外两辆车 不能 做任何事情。\n请你返回收拾完所有垃圾需要花费的 最少 总分钟数。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 输入：garbage = [\u0026#34;G\u0026#34;,\u0026#34;P\u0026#34;,\u0026#34;GP\u0026#34;,\u0026#34;GG\u0026#34;], travel = [2,4,3] 输出：21 解释： 收拾纸的垃圾车： 1. 从房子 0 行驶到房子 1 2. 收拾房子 1 的纸垃圾 3. 从房子 1 行驶到房子 2 4. 收拾房子 2 的纸垃圾 收拾纸的垃圾车总共花费 8 分钟收拾完所有的纸垃圾。 收拾玻璃的垃圾车： 1. 收拾房子 0 的玻璃垃圾 2. 从房子 0 行驶到房子 1 3. 从房子 1 行驶到房子 2 4. 收拾房子 2 的玻璃垃圾 5. 从房子 2 行驶到房子 3 6. 收拾房子 3 的玻璃垃圾 收拾玻璃的垃圾车总共花费 13 分钟收拾完所有的玻璃垃圾。 由于没有金属垃圾，收拾金属的垃圾车不需要花费任何时间。 所以总共花费 8 + 13 = 21 分钟收拾完所有垃圾。 示例 2：\n1 2 3 4 5 6 7 输入：garbage = [\u0026#34;MMM\u0026#34;,\u0026#34;PGM\u0026#34;,\u0026#34;GP\u0026#34;], travel = [3,10] 输出：37 解释： 收拾金属的垃圾车花费 7 分钟收拾完所有的金属垃圾。 收拾纸的垃圾车花费 15 分钟收拾完所有的纸垃圾。 收拾玻璃的垃圾车花费 15 分钟收拾完所有的玻璃垃圾。 总共花费 7 + 15 + 15 = 37 分钟收拾完所有的垃圾。 提示：\n2 \u0026lt;= garbage.length \u0026lt;= 10^5 garbage[i] 只包含字母 'M' ，'P' 和 'G' 。 1 \u0026lt;= garbage[i].length \u0026lt;= 10 travel.length == garbage.length - 1 1 \u0026lt;= travel[i] \u0026lt;= 100 解题思路 模拟每辆垃圾车运行的过程，遍历一遍即可。\n找到最后打扫的位置。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int garbageCollection(vector\u0026lt;string\u0026gt;\u0026amp; garbage, vector\u0026lt;int\u0026gt;\u0026amp; travel) { int n = garbage.size(); vector\u0026lt;int\u0026gt; res(3,0); vector\u0026lt;int\u0026gt; tmp(3,0); auto fun = [\u0026amp;](char ch, int k)-\u0026gt;void{ for(int i=0;i\u0026lt;n;i++){ int cnt=0; for(auto \u0026amp;x: garbage[i]) if(x==ch) cnt++; if(cnt\u0026gt;0) { tmp[k]+=cnt, res[k]=tmp[k]; } if(i!=n-1) tmp[k] += travel[i]; } }; fun(\u0026#39;G\u0026#39;,0); fun(\u0026#39;P\u0026#39;,1); fun(\u0026#39;M\u0026#39;,2); return res[0]+res[1]+res[2]; } }; 【拓扑排序+构造】给定条件下构造矩阵 题目 给你一个 正 整数 k ，同时给你：\n一个大小为 n 的二维整数数组 rowConditions ，其中 rowConditions[i] = [abovei, belowi] 和 一个大小为 m 的二维整数数组 colConditions ，其中 colConditions[i] = [lefti, righti] 。 两个数组里的整数都是 1 到 k 之间的数字。\n你需要构造一个 k x k 的矩阵，1 到 k 每个数字需要 恰好出现一次 。剩余的数字都是 0 。\n矩阵还需要满足以下条件：\n对于所有 0 到 n - 1 之间的下标 i ，数字 abovei 所在的 行 必须在数字 belowi 所在行的上面。 对于所有 0 到 m - 1 之间的下标 i ，数字 lefti 所在的 列 必须在数字 righti 所在列的左边。 返回满足上述要求的 任意 矩阵。如果不存在答案，返回一个空的矩阵。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 输入：k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]] 输出：[[3,0,0],[0,0,1],[0,2,0]] 解释：上图为一个符合所有条件的矩阵。 行要求如下： - 数字 1 在第 1 行，数字 2 在第 2 行，1 在 2 的上面。 - 数字 3 在第 0 行，数字 2 在第 2 行，3 在 2 的上面。 列要求如下： - 数字 2 在第 1 列，数字 1 在第 2 列，2 在 1 的左边。 - 数字 3 在第 0 列，数字 2 在第 1 列，3 在 2 的左边。 注意，可能有多种正确的答案。 示例 2：\n1 2 3 4 输入：k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]] 输出：[] 解释：由前两个条件可以得到 3 在 1 的下面，但第三个条件是 3 在 1 的上面。 没有符合条件的矩阵存在，所以我们返回空矩阵。 提示：\n2 \u0026lt;= k \u0026lt;= 400 1 \u0026lt;= rowConditions.length, colConditions.length \u0026lt;= 10^4 rowConditions[i].length == colConditions[i].length == 2 1 \u0026lt;= abovei, belowi, lefti, righti \u0026lt;= k abovei != belowi lefti != righti 解题思路 行和列之间没有约束，只有行和行之间，列和列之间有约束\n利用拓扑排序找出满足约束的位置\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public: int n; vector\u0026lt;int\u0026gt; fun(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; vec){ vector\u0026lt;int\u0026gt; G[n+1]; vector\u0026lt;int\u0026gt; indegree(n+1,0); for(auto \u0026amp;x: vec){ G[x[0]].push_back(x[1]); indegree[x[1]]++; } vector\u0026lt;int\u0026gt; res; queue\u0026lt;int\u0026gt; q; for(int i=1;i\u0026lt;=n-1;i++) if(indegree[i]==0) q.push(i); if(q.empty()) return {}; while(!q.empty()){ int u = q.front(); q.pop(); res.push_back(u); for(auto \u0026amp;v: G[u]){ if(--indegree[v]==0) q.push(v); } } if(res.size() == n-1) return res; return {}; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; buildMatrix(int k, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; rowConditions, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; colConditions) { n = k+1; vector\u0026lt;int\u0026gt; row = fun(rowConditions); vector\u0026lt;int\u0026gt; col = fun(colConditions); // for(auto \u0026amp;x: row) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;;cout\u0026lt;\u0026lt;endl; // for(auto \u0026amp;x: col) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;;cout\u0026lt;\u0026lt;endl; if(row.empty() || col.empty()) return {}; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(k, vector\u0026lt;int\u0026gt;(k,0)); vector\u0026lt;int\u0026gt; hang(k+1,0),lie(k+1,0);//数字i 的行 和列 for(int i=0;i\u0026lt;k;i++){ hang[row[i]] = i; } for(int i=0;i\u0026lt;k;i++){ lie[col[i]] = i; } for(int i=1;i\u0026lt;=k;i++){ res[hang[i]][lie[i]] = i; } return res; } }; ","date":"2022-09-02T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC308%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220902_hu17107352001805306317.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC308%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第308场周赛总结"},{"content":"\n【模拟】赢得比赛需要的最少训练时长 题目 你正在参加一场比赛，给你两个 正 整数 initialEnergy 和 initialExperience 分别表示你的初始精力和初始经验。\n另给你两个下标从 0 开始的整数数组 energy 和 experience，长度均为 n 。\n你将会 依次 对上 n 个对手。第 i 个对手的精力和经验分别用 energy[i] 和 experience[i] 表示。当你对上对手时，需要在经验和精力上都 严格 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。\n击败第 i 个对手会使你的经验 增加 experience[i]，但会将你的精力 减少 energy[i] 。\n在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 或者 将精力增加 1 。\n返回击败全部 n 个对手需要训练的 最少 小时数目。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 输入：initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1] 输出：8 解释：在 6 小时训练后，你可以将精力提高到 11 ，并且再训练 2 个小时将经验提高到 5 。 按以下顺序与对手比赛： - 你的精力与经验都超过第 0 个对手，所以获胜。 精力变为：11 - 1 = 10 ，经验变为：5 + 2 = 7 。 - 你的精力与经验都超过第 1 个对手，所以获胜。 精力变为：10 - 4 = 6 ，经验变为：7 + 6 = 13 。 - 你的精力与经验都超过第 2 个对手，所以获胜。 精力变为：6 - 3 = 3 ，经验变为：13 + 3 = 16 。 - 你的精力与经验都超过第 3 个对手，所以获胜。 精力变为：3 - 2 = 1 ，经验变为：16 + 1 = 17 。 在比赛前进行了 8 小时训练，所以返回 8 。 可以证明不存在更小的答案。 示例 2：\n1 2 3 输入：initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3] 输出：0 解释：你不需要额外的精力和经验就可以赢得比赛，所以返回 0 。 提示：\nn == energy.length == experience.length 1 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= initialEnergy, initialExperience, energy[i], experience[i] \u0026lt;= 100 解题思路 对于精力来说，不可恢复，所以可预先求出来，看是否需要补充\n对于经验来说，可以在战斗过程中增加，不够再补\nWA了两发，细节没处理好\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int minNumberOfHours(int initialEnergy, int initialExperience, vector\u0026lt;int\u0026gt;\u0026amp; energy, vector\u0026lt;int\u0026gt;\u0026amp; experience) { int n = energy.size(); int sum = accumulate(energy.begin(),energy.end(),0); int res = 0; if(initialEnergy \u0026lt;= sum) res+= sum+1-initialEnergy; // cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; int s = 0,x = initialExperience;//需要补的经验 当前经验 for(int i=0;i\u0026lt;n;i++){ if(x \u0026gt; experience[i]){ x += experience[i]; }else{ s += experience[i]+1-x; x += experience[i]+1-x + experience[i]; } } // cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl; return res+s; } }; 【贪心】最大回文数字 题目 给你一个仅由数字（0 - 9）组成的字符串 num 。\n请你找出能够使用 num 中数字形成的 最大回文 整数，并以字符串形式返回。该整数不含 前导零 。\n注意：\n你 无需 使用 num 中的所有数字，但你必须使用 至少 一个数字。 数字可以重新排序。 示例 1：\n1 2 3 4 5 输入：num = \u0026#34;444947137\u0026#34; 输出：\u0026#34;7449447\u0026#34; 解释： 从 \u0026#34;444947137\u0026#34; 中选用数字 \u0026#34;4449477\u0026#34;，可以形成回文整数 \u0026#34;7449447\u0026#34; 。 可以证明 \u0026#34;7449447\u0026#34; 是能够形成的最大回文整数。 示例 2：\n1 2 3 4 5 输入：num = \u0026#34;00009\u0026#34; 输出：\u0026#34;9\u0026#34; 解释： 可以证明 \u0026#34;9\u0026#34; 能够形成的最大回文整数。 注意返回的整数不应含前导零。 提示：\n1 \u0026lt;= num.length \u0026lt;= 10^5 num 由数字（0 - 9）组成 解题思路 先获取每个数字的个数，然后从大到小构造\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: string largestPalindromic(string num) { int n = num.size(); map\u0026lt;int,int\u0026gt; tab; for(auto \u0026amp;x: num){ tab[x-\u0026#39;0\u0026#39;]++; } string res; for(int i=9;i\u0026gt;=0;i--){ while(tab[i]\u0026gt;=2){ if(res.empty() \u0026amp;\u0026amp; i==0) break; res+=\u0026#39;0\u0026#39;+i; tab[i]-=2; } } string tmp = res; reverse(tmp.begin(),tmp.end()); for(int i=9;i\u0026gt;=0;i--){ if(tab[i]\u0026gt;=1){ res+=i+\u0026#39;0\u0026#39;; break; } } res += tmp; return res; } }; 【BFS】感染二叉树需要的总时间 题目 给你一棵二叉树的根节点 root ，二叉树中节点的值 互不相同 。另给你一个整数 start 。在第 0 分钟，感染 将会从值为 start 的节点开始爆发。\n每分钟，如果节点满足以下全部条件，就会被感染：\n节点此前还没有感染。 节点与一个已感染节点相邻。 返回感染整棵树需要的分钟数*。*\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：root = [1,5,3,null,4,10,6,9,2], start = 3 输出：4 解释：节点按以下过程被感染： - 第 0 分钟：节点 3 - 第 1 分钟：节点 1、10、6 - 第 2 分钟：节点5 - 第 3 分钟：节点 4 - 第 4 分钟：节点 9 和 2 感染整棵树需要 4 分钟，所以返回 4 。 示例 2：\n1 2 3 输入：root = [1], start = 1 输出：0 解释：第 0 分钟，树中唯一一个节点处于感染状态，返回 0 。 提示：\n树中节点的数目在范围 [1, 10^5] 内 1 \u0026lt;= Node.val \u0026lt;= 10^5 每个节点的值 互不相同 树中必定存在值为 start 的节点 解题思路 相当于求图中到一点的最远距离，先构造图，再常规BFS即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ const int MAXN = 1e5+5; class Solution { public: vector\u0026lt;int\u0026gt; G[MAXN]; int amountOfTime(TreeNode* root, int start) { vector\u0026lt;int\u0026gt; d(MAXN,-1); queue\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; que; function\u0026lt;void(TreeNode*)\u0026gt; f =[\u0026amp;](TreeNode* t){ if(t==nullptr) return; if(t-\u0026gt;val==start){ d[t-\u0026gt;val]=0; que.emplace(0, t-\u0026gt;val); } if(t-\u0026gt;left){ G[t-\u0026gt;val].push_back(t-\u0026gt;left-\u0026gt;val); G[t-\u0026gt;left-\u0026gt;val].push_back(t-\u0026gt;val); f(t-\u0026gt;left); } if(t-\u0026gt;right){ G[t-\u0026gt;val].push_back(t-\u0026gt;right-\u0026gt;val); G[t-\u0026gt;right-\u0026gt;val].push_back(t-\u0026gt;val); f(t-\u0026gt;right); } }; f(root); while(que.size()){ int sz = que.size(); for(int i=0;i\u0026lt;sz;i++){ auto [dis, u] = que.front(); que.pop(); for(auto \u0026amp;v: G[u]){ if(d[v]\u0026gt;-1) continue; d[v] = dis+1; que.emplace(d[v], v); } } } int res=0; for(int i=0;i\u0026lt;MAXN;i++){ res = max(res, d[i]); } return res; } }; 【思维+最小堆】找出数组的第 K 大和 题目 给你一个整数数组 nums 和一个 正 整数 k 。你可以选择数组的任一 子序列 并且对其全部元素求和。\n数组的 第 k 大和 定义为：可以获得的第 k 个 最大 子序列和（子序列和允许出现重复）\n返回数组的 第 k 大和 。\n子序列是一个可以由其他数组删除某些或不删除元素排生而来的数组，且派生过程不改变剩余元素的顺序。\n注意： 空子序列的和视作 0 。\n示例 1：\n1 2 3 4 5 输入：nums = [2,4,-2], k = 5 输出：2 解释：所有可能获得的子序列和列出如下，按递减顺序排列： - 6、4、4、2、2、0、0、-2 数组的第 5 大和是 2 。 示例 2：\n1 2 3 输入：nums = [1,-2,3,4,-10,12], k = 16 输出：10 解释：数组的第 16 大和是 10 。 提示：\nn == nums.length 1 \u0026lt;= n \u0026lt;= 10^5 -10^9 \u0026lt;= nums[i] \u0026lt;= 10^9 1 \u0026lt;= k \u0026lt;= min(2000, 2^n) 解题思路 数组的第一大和显然是所有非负数的和sum。\n注意到k的数据范围，最大不超过2000\n那么求数组的第K大和，也就是求第K小和，然后sum减去即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #define ll long long class Solution { public: long long kSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); ll sum = 0; for(auto \u0026amp;x: nums){ if(x\u0026gt;=0) sum+=x; else x=-x; } if(k==1) return sum;//第一大，所有非负数的和 sort(nums.begin(),nums.end()); priority_queue\u0026lt; pair\u0026lt;ll,int\u0026gt;,vector\u0026lt;pair\u0026lt;ll,int\u0026gt;\u0026gt;,greater\u0026lt;pair\u0026lt;ll,int\u0026gt;\u0026gt;\u0026gt; pq; k-=2;//空子序列的和最大，什么都不用减。 //求第k大和，即最大和减去前k-1小和 pq.emplace(nums[0],0); while(k--){ auto [su, id] = pq.top(); pq.pop(); if(id+1\u0026gt;=n) continue; pq.emplace(su-nums[id]+nums[id+1],id+1); pq.emplace(su+nums[id+1],id+1); } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;pq.top().first\u0026lt;\u0026lt;endl; return sum-pq.top().first; } }; ","date":"2022-08-27T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC307%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220827_hu15793428758916734192.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC307%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第307场周赛总结"},{"content":"\n【前缀和/滑动窗口】得到 K 个黑块的最少涂色次数 题目 给你一个长度为 n 下标从 0 开始的字符串 blocks ，blocks[i] 要么是 'W' 要么是 'B' ，表示第 i 块的颜色。字符 'W' 和 'B' 分别表示白色和黑色。\n给你一个整数 k ，表示想要 连续 黑色块的数目。\n每一次操作中，你可以选择一个白色块将它 涂成 黑色块。\n请你返回至少出现 一次 连续 k 个黑色块的 最少 操作次数。\n示例 1：\n1 2 3 4 5 6 7 输入：blocks = \u0026#34;WBBWWBBWBW\u0026#34;, k = 7 输出：3 解释： 一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。 得到 blocks = \u0026#34;BBBBBBBWBW\u0026#34; 。 可以证明无法用少于 3 次操作得到 7 个连续的黑块。 所以我们返回 3 。 示例 2：\n1 2 3 4 5 输入：blocks = \u0026#34;WBWBBBW\u0026#34;, k = 2 输出：0 解释： 不需要任何操作，因为已经有 2 个连续的黑块。 所以我们返回 0 。 提示：\nn == blocks.length 1 \u0026lt;= n \u0026lt;= 100 blocks[i] 要么是 'W' ，要么是 'B' 。 1 \u0026lt;= k \u0026lt;= n 解题思路 所求为长度为k的区间内黑色块的最多的个数\n赛时用的是前缀和维护黑色块的数目\n也可以用滑动窗口\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int minimumRecolors(string blocks, int k) { int n = blocks.size(); vector\u0026lt;int\u0026gt; sum(n+1,0); for(int i=1;i\u0026lt;=n;i++){ sum[i] = sum[i-1] + (blocks[i-1]==\u0026#39;B\u0026#39;?1:0); } int maxs = 0; for(int i=1;i+k-1\u0026lt;=n;i++){ maxs = max(maxs, sum[i+k-1]-sum[i-1]); } if(maxs\u0026gt;=k) return 0; else return k-maxs; } }; 【模拟/动态规划】二进制字符串重新安排顺序需要的时间 题目 给你一个二进制字符串 s 。在一秒之中，所有 子字符串 \u0026quot;01\u0026quot; 同时 被替换成 \u0026quot;10\u0026quot; 。这个过程持续进行到没有 \u0026quot;01\u0026quot; 存在。\n请你返回完成这个过程所需要的秒数。\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：s = \u0026#34;0110101\u0026#34; 输出：4 解释： 一秒后，s 变成 \u0026#34;1011010\u0026#34; 。 再过 1 秒后，s 变成 \u0026#34;1101100\u0026#34; 。 第三秒过后，s 变成 \u0026#34;1110100\u0026#34; 。 第四秒后，s 变成 \u0026#34;1111000\u0026#34; 。 此时没有 \u0026#34;01\u0026#34; 存在，整个过程花费 4 秒。 所以我们返回 4 。 示例 2：\n1 2 3 4 5 输入：s = \u0026#34;11100\u0026#34; 输出：0 解释： s 中没有 \u0026#34;01\u0026#34; 存在，整个过程花费 0 秒。 所以我们返回 0 。 提示：\n1 \u0026lt;= s.length \u0026lt;= 1000 s[i] 要么是 '0' ，要么是 '1' 。 解题思路 数据量小，可以用$O(n^2)$的模拟做。\n此外，这题还存在$O(n)$的解法\n思考时，我们可以把 01→ 10 的替换看成是 1 向左移动。每一秒，如果 1 的左面是 0，则会向左移动一步。注意连续的 1 不能同时向左移动。\n从左到右遍历字符串：\n如果 1 的左侧没有 0，则无需移动。\n如果 11 的左侧存在 cnt(cnt \u0026gt; 0) 个 0，则至少需要 cnt 秒来移动；同时，如果这个 1 的左侧还存在 1，那么它至少需要比左侧那个 1 多一秒才能到达最终位置。\n这是因为，当左侧的 1 刚到达最终位置的时刻，右侧的 1 一定不会移动到最终位置，而是至少与前面的 1 间隔一个 0，因为连续的 11 无法同时向左移动，从而无法同时到达最终位置。\n代码 模拟 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int secondsToRemoveOccurrences(string s) { int n = s.size(); int step = 0; while(1){ bool flag = true; for(int i=0;i\u0026lt;n;){ if(s[i]==\u0026#39;0\u0026#39; \u0026amp;\u0026amp; i!=n-1 \u0026amp;\u0026amp; s[i+1]==\u0026#39;1\u0026#39;) s[i]=\u0026#39;1\u0026#39;,s[i+1]=\u0026#39;0\u0026#39;,i+=2, flag = false; else i++; } if(flag) break; step++; } return step; } }; 动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int secondsToRemoveOccurrences(string s) { int n = s.size(); //dp[i] 前i个字符完成安排顺序后所需要的时间 vector\u0026lt;int\u0026gt; dp(n,0); int pre0 = s[0]==\u0026#39;0\u0026#39;?1:0; for(int i=1;i\u0026lt;n;i++){ if(s[i]==\u0026#39;0\u0026#39;) dp[i] = dp[i-1], pre0++; else if(pre0) dp[i] = max(pre0, dp[i-1]+1); } return dp[n-1]; } }; 【差分数组】字母移位 II 题目 给你一个小写英文字母组成的字符串 s 和一个二维整数数组 shifts ，其中 shifts[i] = [starti, endi, directioni] 。对于每个 i ，将 s 中从下标 starti 到下标 endi （两者都包含）所有字符都进行移位运算，如果 directioni = 1 将字符向后移位，如果 directioni = 0 将字符向前移位。\n将一个字符 向后 移位的意思是将这个字符用字母表中 下一个 字母替换（字母表视为环绕的，所以 'z' 变成 'a'）。类似的，将一个字符 向前 移位的意思是将这个字符用字母表中 前一个 字母替换（字母表是环绕的，所以 'a' 变成 'z' ）。\n请你返回对 s 进行所有移位操作以后得到的最终字符串。\n示例 1：\n1 2 3 4 5 输入：s = \u0026#34;abc\u0026#34;, shifts = [[0,1,0],[1,2,1],[0,2,1]] 输出：\u0026#34;ace\u0026#34; 解释：首先，将下标从 0 到 1 的字母向前移位，得到 s = \u0026#34;zac\u0026#34; 。 然后，将下标从 1 到 2 的字母向后移位，得到 s = \u0026#34;zbd\u0026#34; 。 最后，将下标从 0 到 2 的字符向后移位，得到 s = \u0026#34;ace\u0026#34; 。 示例 2:\n1 2 3 4 输入：s = \u0026#34;dztz\u0026#34;, shifts = [[0,0,0],[1,1,1]] 输出：\u0026#34;catz\u0026#34; 解释：首先，将下标从 0 到 0 的字母向前移位，得到 s = \u0026#34;cztz\u0026#34; 。 最后，将下标从 1 到 1 的字符向后移位，得到 s = \u0026#34;catz\u0026#34; 。 提示：\n1 \u0026lt;= s.length, shifts.length \u0026lt;= 5 * 10^4 shifts[i].length == 3 0 \u0026lt;= starti \u0026lt;= endi \u0026lt; s.length 0 \u0026lt;= directioni \u0026lt;= 1 s 只包含小写英文字母。 解题思路 区间修改+单点查询 可用差分数组\n最后单点查询的时候再判断总共移位的情况\nRE了一发是忽略了ASCII码值的范围是[0,127]，而\u0026rsquo;a\u0026rsquo;=97，\u0026lsquo;z\u0026rsquo;=122，\u0026lsquo;z\u0026rsquo;+26\u0026gt;127超出了char的范围\n1 2 3 4 if(a[i]\u0026gt;0){//赛时写成这样了，可惜 s[i]+=a[i]; if(s[i]\u0026gt;\u0026#39;z\u0026#39;) s[i]=\u0026#39;a\u0026#39;+s[i]-\u0026#39;z\u0026#39;-1; } 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: string shiftingLetters(string s, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; shifts) { int n = s.size(); vector\u0026lt;int\u0026gt; d(n+1, 0), a(n,0); for(auto \u0026amp;x: shifts){ int st=x[0],e=x[1],dir=x[2]; if(dir==1){//向后移 d[st]+=1,d[e+1]-=1; }else{//向前移 d[st]+=-1,d[e+1]-=-1; } } int now=0; for(int i=0;i\u0026lt;n;i++){ now+=d[i]; a[i]=(now%26+26)%26; // cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; if(a[i]\u0026gt;0){ while(a[i]){ s[i]++; if(s[i]\u0026gt;\u0026#39;z\u0026#39;) s[i]=\u0026#39;a\u0026#39;; a[i]--; } } } // cout\u0026lt;\u0026lt;endl; return s; } }; 【倒序+线段树/并查集】删除操作后的最大子段和 题目 给你两个下标从 0 开始的整数数组 nums 和 removeQueries ，两者长度都为 n 。对于第 i 个查询，nums 中位于下标 removeQueries[i] 处的元素被删除，将 nums 分割成更小的子段。\n一个 子段 是 nums 中连续 正 整数形成的序列。子段和 是子段中所有元素的和。\n请你返回一个长度为 n 的整数数组 answer ，其中 answer[i]是第 i 次删除操作以后的 最大 子段和。\n注意： 一个下标至多只会被删除一次。\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1] 输出：[14,7,2,2,0] 解释：用 0 表示被删除的元素，答案如下所示： 查询 1 ：删除第 0 个元素，nums 变成 [0,2,5,6,1] ，最大子段和为子段 [2,5,6,1] 的和 14 。 查询 2 ：删除第 3 个元素，nums 变成 [0,2,5,0,1] ，最大子段和为子段 [2,5] 的和 7 。 查询 3 ：删除第 2 个元素，nums 变成 [0,2,0,0,1] ，最大子段和为子段 [2] 的和 2 。 查询 4 ：删除第 4 个元素，nums 变成 [0,2,0,0,0] ，最大子段和为子段 [2] 的和 2 。 查询 5 ：删除第 1 个元素，nums 变成 [0,0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。 所以，我们返回 [14,7,2,2,0] 。 示例 2：\n1 2 3 4 5 6 7 8 输入：nums = [3,2,11,1], removeQueries = [3,2,1,0] 输出：[16,5,3,0] 解释：用 0 表示被删除的元素，答案如下所示： 查询 1 ：删除第 3 个元素，nums 变成 [3,2,11,0] ，最大子段和为子段 [3,2,11] 的和 16 。 查询 2 ：删除第 2 个元素，nums 变成 [3,2,0,0] ，最大子段和为子段 [3,2] 的和 5 。 查询 3 ：删除第 1 个元素，nums 变成 [3,0,0,0] ，最大子段和为子段 [3] 的和 3 。 查询 5 ：删除第 0 个元素，nums 变成 [0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。 所以，我们返回 [16,5,3,0] 。 提示：\nn == nums.length == removeQueries.length 1 \u0026lt;= n \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^9 0 \u0026lt;= removeQueries[i] \u0026lt; n removeQueries 中所有数字 互不相同 。 解题思路 倒序操作，变成从空数组开始合并\n线段树维护每个区间的最大子段和，左子段和，右子段和，以及它们对应的长度\n还可以用并查集\n代码（线段树） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #define ll long long const int MAXN = 1e5+5; #define ls(p) (p\u0026lt;\u0026lt;1) #define rs(p) (p\u0026lt;\u0026lt;1|1) struct node{ ll lv,rv,v;//含左端点在内的最大子段和；含右端点在内的最大子段和；最大子段和 int lenl,lenr;//左端点开始的连续非零长度；右端点开始的连续非零长度 }T[MAXN\u0026lt;\u0026lt;2]; void push_up(int p, int l, int r){ int mid=(l+r)\u0026gt;\u0026gt;1; T[p].lenl = T[ls(p)].lenl + (T[ls(p)].lenl==(mid-l+1)?T[rs(p)].lenl:0); T[p].lenr = T[rs(p)].lenr + (T[rs(p)].lenr==(r-mid)?T[ls(p)].lenr:0); T[p].lv = T[ls(p)].lv + (T[ls(p)].lenl==(mid-l+1)?T[rs(p)].lv:0); T[p].rv = T[rs(p)].rv + (T[rs(p)].lenr==(r-mid)?T[ls(p)].rv:0); T[p].v = max({T[ls(p)].v, T[rs(p)].v, T[p].lv, T[p].rv, T[ls(p)].rv+T[rs(p)].lv}); } void update(int p, int l, int r, int nl, int nr, int k){ if(nl\u0026lt;=l \u0026amp;\u0026amp; nr\u0026gt;=r) { T[p].lv = T[p].rv = T[p].v = k; T[p].lenl=T[p].lenr=1; return ; } int mid=(l+r)\u0026gt;\u0026gt;1; if(nl\u0026lt;=mid) update(ls(p),l,mid,nl,nr,k); if(nr\u0026gt;mid) update(rs(p),mid+1,r,nl,nr,k); push_up(p,l,r); } ll query(int p, int l, int r, int nl, int nr){ if(nl\u0026lt;=l \u0026amp;\u0026amp; nr\u0026gt;=r) return T[p].v; return 0; } class Solution { public: vector\u0026lt;long long\u0026gt; maximumSegmentSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;int\u0026gt;\u0026amp; removeQueries) { memset(T,0,sizeof(T)); vector\u0026lt;ll\u0026gt; res; int n = removeQueries.size(); for(int i=n-1;i\u0026gt;=0;i--){ res.push_back(query(1,1,n,1,n)); update(1,1,n,removeQueries[i]+1,removeQueries[i]+1,nums[removeQueries[i]]); } reverse(res.begin(),res.end()); return res; } }; 偷学代码（并查集） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: vector\u0026lt;long long\u0026gt; maximumSegmentSum(vector\u0026lt;int\u0026gt; \u0026amp;nums, vector\u0026lt;int\u0026gt; \u0026amp;removeQueries) { int n = nums.size(); int fa[n + 1]; iota(fa, fa + n + 1, 0); long long sum[n + 1]; memset(sum, 0, sizeof(sum)); function\u0026lt;int(int)\u0026gt; find = [\u0026amp;](int x) -\u0026gt; int { return fa[x] == x ? x : fa[x] = find(fa[x]); }; vector\u0026lt;long long\u0026gt; ans(n); for (int i = n - 1; i \u0026gt; 0; --i) { int x = removeQueries[i]; int to = find(x + 1); fa[x] = to; // 合并 x 和 x+1 sum[to] += sum[x] + nums[x]; ans[i - 1] = max(ans[i], sum[to]); } return ans; } }; ","date":"2022-08-26T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC85%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220826_hu12990034475777929549.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC85%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第85场双周赛总结"},{"content":"前言 即将原数组本身当作哈希表，位置i对应值i或者i+1等\n在原数组上进行修改\n第i个数有两种情况进行位置交换，一个是主动比较与位置i的关系，另一个是被动比较，即后续的数主动比较引起的第i个数的位置交换。\n当主动比较有限制时，还可以有被动比较的机会进行更改。\n虽然第一个循环中嵌套了while，但是每一个while中就会有一个元素确定位置，在后续的遍历中确定位置元素的while就会被跳过。平均下来，每个数只需要看一次就可以了，while 循环体被执行很多次的情况不会每次都发生。这样的复杂度分析的方法叫做均摊复杂度分析，所以时间复杂度为O(N)。\n寻找重复数 题目 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。\n假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。\n你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。\n示例 1：\n输入：nums = [1,3,4,2,2] 输出：2 示例 2：\n输入：nums = [3,1,3,4,2] 输出：3\n提示：\n1 \u0026lt;= n \u0026lt;= 10^5\nnums.length == n + 1\n1 \u0026lt;= nums[i] \u0026lt;= n\nnums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次\n进阶：\n如何证明 nums 中至少存在一个重复的数字? 你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/find-the-duplicate-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 数组长度为n+1，下标为[0,n]，数字范围为[1,n]，设定哈希函数为f(x) = x + 1 ，即位置i处的数字应为i+1\n对于元素nums[i]，如果nums[i]==i+1，说明满足要求，不用修改\n否则，将nums[i]放到其应该待的位置：nums[i]-1，直到第i处的值也正确，或者已经找到了重复的数\n注意，这里采用的原地哈希，需要修改原数组，不符合题目要求，但时间复杂度为O(n)，以及O(1)的空间\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int findDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); for(int i=0;i\u0026lt;n;i++){ //if(nums[i] == i+1) continue; while(nums[i]!=i+1){ if(nums[i] == nums[nums[i]-1]) return nums[i];//重复了 swap(nums[i], nums[nums[i]-1]);//x应该被换到下标x-1处 } } // for(int i=0;i\u0026lt;n;i++){ // // cout\u0026lt;\u0026lt;nums[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; // if(nums[i]!=i+1) return nums[i]; // } return -1; } }; 丢失的数字 题目 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。\n示例 1：\n输入：nums = [3,0,1] 输出：2 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 2：\n输入：nums = [0,1] 输出：2 解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 3：\n输入：nums = [9,6,4,2,3,5,7,0,1] 输出：8 解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。 示例 4：\n输入：nums = [0] 输出：1 解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。\n提示：\nn == nums.length 1 \u0026lt;= n \u0026lt;= 10^4 0 \u0026lt;= nums[i] \u0026lt;= n nums 中的所有数字都 独一无二\n进阶：你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/missing-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 数组长度为n，数组下标为[0,n-1]，数字范围为[0,n]，设定哈希函数为f(x) = x，即位置i处的数字应为i\n如果nums[i]==i，肯定不用再改了；如果nums[i]==n，也不用改，因为原数组中没有它对应的位置，等待后续其他位置和它进行调换\n即如果nums[i]!=i 且 nums[i]\u0026lt;n 的话，就一直替换，将x放到位置x处\n最后[0,n-1]的位置上第一个没有对应数字的即是丢失的数字。如果都对应上了，说明丢了n。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int missingNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); //x 应该放的下标为x ，如果x为n，则先不动它，动其他的 for(int i=0;i\u0026lt;n;i++){ while(nums[i]!=i \u0026amp;\u0026amp; nums[i]\u0026lt;n){ swap(nums[i], nums[nums[i]]);//将x放到位置 x 处 } } for(int i=0;i\u0026lt;n;i++){//第一个位置上没有对应数字的即是丢失的数字 if(nums[i]!=i) return i; } return n; } }; 缺失的第一个正数 题目 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。\n请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。\n示例 1：\n输入：nums = [1,2,0] 输出：3 示例 2：\n输入：nums = [3,4,-1,1] 输出：2 示例 3：\n输入：nums = [7,8,9,11,12] 输出：1\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 5 * 10^5 -2^31 \u0026lt;= nums[i] \u0026lt;= 2^31 - 1\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/first-missing-positive 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 数组长度为n，数组下标为[0,n-1]，数的范围为[1,~],设定哈希函数为f(x) = x + 1 ，即位置i处的数字应为i+1\n对于大于等于n的数x，在数组中没有其正确的容身之处，先不改，等待其它正确的数将它替换过去。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int firstMissingPositive(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); //对于小于n的值x，放在位置x-1处 //即位置x，放的数值应该为x+1 for(int i=0;i\u0026lt;n;i++){ while(i+1 != nums[i] \u0026amp;\u0026amp; nums[i]\u0026lt;n \u0026amp;\u0026amp; nums[i]\u0026gt;0){ if(nums[i]==nums[nums[i]-1]) break; swap(nums[i], nums[nums[i]-1]); } } for(int i=0;i\u0026lt;n;i++){ if(i+1!=nums[i]) return i+1; } return n+1; } }; 找到所有数组中消失的数字 题目 给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。\n示例 1：\n输入：nums = [4,3,2,7,8,2,3,1] 输出：[5,6] 示例 2：\n输入：nums = [1,1] 输出：[2]\n提示：\nn == nums.length 1 \u0026lt;= n \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= n 进阶：你能在不使用额外空间且时间复杂度为 O(n) 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 数组长度为n，数组下标为[0,n-1]，数的范围为[1,~],设定哈希函数为f(x) = x + 1 ，即位置i处的数字应为i+1\n最后位置上没有对应数字即缺少该数字\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: vector\u0026lt;int\u0026gt; findDisappearedNumbers(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; res; for(int i=0;i\u0026lt;n;i++){ while(nums[i]!=i+1){ if(nums[i] == nums[nums[i]-1]) break; swap(nums[i], nums[nums[i]-1]); } } for(int i=0;i\u0026lt;n;i++){ if(nums[i]!=i+1) res.push_back(i+1); } return res; } }; ","date":"2022-08-20T00:00:00Z","image":"https://tetsuou.github.io/p/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C/post-bg-20220820_hu2013114214393441688.png","permalink":"https://tetsuou.github.io/p/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C/","title":"原地哈希"},{"content":"前言 先将数转为字符串s，记忆化搜索，枚举s的每一位\n一般有4个参数：pos, state, is_limit, is_num\npos 表示当前枚举到哪一位，必须的 state 表示枚举到当前位时，之前的位的一些状态，可以是已选取数字集合等等，不是必须的，视题中的限制而决定 is_limit 表示枚举到当前位时，之前的位是否达到了上限，比如n=1234，pos=3，此时is_limit=true表示前面枚举的是123。这一项决定枚举当前位的上限数字 is_num 表示枚举到当前位时，之前的位是否表示一个合法的数，用来处理前导0的情况。如果is_num=true，那么当前位可从0开始枚举；如果is_num=false，那么当前位要从1开始枚举(后续is_num为true），或者跳过（后续is_num仍为false) 1 2 3 4 5 6 7 //is_limit要初始化为true，不然后面都会为false //is_num初始化为false //is_limit为true时不会存在重复运算，不会重复访问一个状态 //is_num为false时前面都为空，也不会存在重复运算，也不需要记忆化 至少有1位重复的数字 题目 给定正整数 n，返回在 [1, n] 范围内具有 至少 1 位 重复数字的正整数的个数。\n示例 1：\n输入：n = 20 输出：1 解释：具有至少 1 位重复数字的正数（\u0026lt;= 20）只有 11 。 示例 2：\n输入：n = 100 输出：10 解释：具有至少 1 位重复数字的正数（\u0026lt;= 100）有 11，22，33，44，55，66，77，88，99 和 100 。 示例 3：\n输入：n = 1000 输出：262\n提示：\n1 \u0026lt;= n \u0026lt;= 10^9\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/numbers-with-repeated-digits 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 求含至少1位重复数字的正整数的个数，从反面更容易求，即求不含重复数字的正整数的个数x，那么结果即为n-x\nstate表示前面所填数字的集合，用位来记录\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: int numDupDigitsAtMostN(int n) { string num = to_string(n); int m = num.size(), dp[m][1\u0026lt;\u0026lt;10]; memset(dp,-1,sizeof(dp)); //从pos开始填数字，pos前面填的数字的集合是state，能构造出的不含重复数字的正整数的个数 //is_limit 表示前面填的数字是否都是n对应位上的，如果为true，那么当前位至多为int(num[i])，否则至多为9 //is_num 表示前面是否填了数字（是否跳过），如果为true，那么当前位可以从0开始，如果为false，那么可以跳过，或者从1开始填数字（不能前导0） function\u0026lt;int(int,int,bool,bool)\u0026gt; dfs = [\u0026amp;](int pos, int state, bool is_limit, bool is_num)-\u0026gt;int{ if(pos == m) return is_num; if(!is_limit \u0026amp;\u0026amp; is_num \u0026amp;\u0026amp; dp[pos][state]\u0026gt;=0) return dp[pos][state]; int res=0; //如果前面都没填，第i位明显不受限制，如n=123,第0位没填的话，第1位可填9 if(!is_num) res = dfs(pos+1,state,false,false);//可以跳过，不填数字 //根据is_num的值决定从0开始还是1开始，上界由is_limit决定 //枚举要填的数字 for(int d=1-is_num,up=is_limit?num[pos]-\u0026#39;0\u0026#39;:9;d\u0026lt;=up;d++){ if((state\u0026gt;\u0026gt;d \u0026amp;1)==0){//只有当前填的数字与之前填的数字没有重复时 才填 res += dfs(pos+1,state|(1\u0026lt;\u0026lt;d),is_limit\u0026amp;\u0026amp;d==up,true); } } if(!is_limit \u0026amp;\u0026amp; is_num) dp[pos][state] = res; return res; }; return n - dfs(0,0,true,false); //is_limit要初始化为true，不然后面都会为false //is_num初始化为false //is_limit为true时不会存在重复运算，不会重复访问一个状态 //is_num为false时前面都为空，也不会存在重复运算，也不需要记忆化 } }; 最大为 N 的数字组合 题目 给定一个按 非递减顺序 排列的数字数组 digits 。你可以用任意次数 digits[i] 来写的数字。例如，如果 digits = [\u0026lsquo;1\u0026rsquo;,\u0026lsquo;3\u0026rsquo;,\u0026lsquo;5\u0026rsquo;]，我们可以写数字，如 \u0026lsquo;13\u0026rsquo;, \u0026lsquo;551\u0026rsquo;, 和 \u0026lsquo;1351315\u0026rsquo;。\n返回 可以生成的小于或等于给定整数 n 的正整数的个数 。\n示例 1：\n输入：digits = [\u0026ldquo;1\u0026rdquo;,\u0026ldquo;3\u0026rdquo;,\u0026ldquo;5\u0026rdquo;,\u0026ldquo;7\u0026rdquo;], n = 100 输出：20 解释： 可写出的 20 个数字是： 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77. 示例 2：\n输入：digits = [\u0026ldquo;1\u0026rdquo;,\u0026ldquo;4\u0026rdquo;,\u0026ldquo;9\u0026rdquo;], n = 1000000000 输出：29523 解释： 我们可以写 3 个一位数字，9 个两位数字，27 个三位数字， 81 个四位数字，243 个五位数字，729 个六位数字， 2187 个七位数字，6561 个八位数字和 19683 个九位数字。 总共，可以使用D中的数字写出 29523 个整数。 示例 3:\n输入：digits = [\u0026ldquo;7\u0026rdquo;], n = 8 输出：1\n提示：\n1 \u0026lt;= digits.length \u0026lt;= 9\ndigits[i].length == 1\ndigits[i] 是从 \u0026lsquo;1\u0026rsquo; 到 \u0026lsquo;9\u0026rsquo; 的数\ndigits 中的所有值都 不同\ndigits 按 非递减顺序 排列\n1 \u0026lt;= n \u0026lt;= 10^9\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/numbers-at-most-n-given-digit-set 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 限制条件为只能用给定的数字\n用不到state\n注意，这题是需要is_num的，虽然给定的数字中不会出现0，如果没有is_num，将没办法跳过高位数字，若n=2345，那么千位必须要填一个数，实际上是可以跳过的，所以需要is_num位标记\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int atMostNGivenDigitSet(vector\u0026lt;string\u0026gt;\u0026amp; digits, int n) { auto s = to_string(n); int m = s.size(); vector\u0026lt;int\u0026gt; dp(m,-1); set\u0026lt;int\u0026gt; ok; for(auto \u0026amp;x: digits) ok.insert(stoi(x)); function\u0026lt;int(int,bool,bool)\u0026gt; f = [\u0026amp;](int pos, bool is_limit, bool is_num)-\u0026gt;int{ if(pos == m) return is_num; if(!is_limit \u0026amp;\u0026amp; is_num \u0026amp;\u0026amp; dp[pos]\u0026gt;=0) return dp[pos]; int res = 0; if(!is_num) res = f(pos+1, false, false); for(int d=1-is_num,up=is_limit?s[pos]-\u0026#39;0\u0026#39;:9;d\u0026lt;=up;d++){ if(ok.count(d)){//只用给定的数字 res += f(pos+1, is_limit \u0026amp;\u0026amp; d==up, true); } } if(!is_limit \u0026amp;\u0026amp; is_num) dp[pos] = res; return res; }; return f(0,true,false); } }; 2出现的次数 题目 编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。\n示例:\n输入: 25 输出: 9 解释: (2, 12, 20, 21, 22, 23, 24, 25)(注意 22 应该算作两次) 提示：\nn \u0026lt;= 10^9\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/number-of-2s-in-range-lcci 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 state位需要，记录前面2出现的次数即可\nis_num位不必须，就算考虑了前导0的情况，也不影响2出现的次数\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int numberOf2sInRange(int n) { auto s = to_string(n); int m = s.size(); int dp[m][m]; memset(dp,-1,sizeof(dp)); function\u0026lt;int(int,int,bool)\u0026gt; f = [\u0026amp;](int pos, int cnt2, bool is_limit)-\u0026gt;int{ if(pos == m) return cnt2; if(!is_limit \u0026amp;\u0026amp; dp[pos][cnt2]\u0026gt;=0) return dp[pos][cnt2]; int res = 0; int up = is_limit?s[pos]-\u0026#39;0\u0026#39;:9; for(int d=0;d\u0026lt;=up;d++){ res += f(pos+1, cnt2 + (d==2), is_limit\u0026amp;\u0026amp;d==up);//只有当前位是2时，2出现的次数+1 } if(!is_limit) dp[pos][cnt2] = res; return res; }; return f(0,0,true); } }; 不含连续1的非负整数 题目 给定一个正整数 n ，返回范围在 [0, n] 都非负整数中，其二进制表示不包含 连续的 1 的个数。\n示例 1:\n输入: n = 5 输出: 5 解释: 下面是带有相应二进制表示的非负整数\u0026lt;= 5： 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。 示例 2:\n输入: n = 1 输出: 2 示例 3:\n输入: n = 2 输出: 3\n提示:\n1 \u0026lt;= n \u0026lt;= 10^9\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 注意题中限制是二进制表示中的限制，故先求出其二进制表示\n求不包含连续1的情况\n可以先求包含连续1的情况，再拿n+1减\nstate是需要的，记录出现的连续的1的情况\nis_num不必需，不影响连续的1\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: int findIntegers(int n) { string s; //高位到低位的二进制表示 for(int i=31;i\u0026gt;=0;i--) s.push_back(((n\u0026gt;\u0026gt;i)\u0026amp;1)+\u0026#39;0\u0026#39;); int m = s.size(); int dp[m][4]; //state==2 前面的数中已经出现了连续的1 //state==1 前面的数中还没出现连续的1，但前一个数正好是1 //state==0 前面的数中还没出现连续的1，且前一个数也不是1 memset(dp,-1,sizeof(dp)); function\u0026lt;int(int,int,bool)\u0026gt; f = [\u0026amp;](int pos, int state, bool is_limit)-\u0026gt;int{ if(pos == m) { return state == 2; }; if(!is_limit \u0026amp;\u0026amp;dp[pos][state]\u0026gt;=0) return dp[pos][state]; int res = 0; int up = is_limit?s[pos]-\u0026#39;0\u0026#39;:1; for(int d = 0; d\u0026lt;=up; d++){ int nxt; //根据之前状态与当前位是否是1，决定下一状态 if(state==2 || (state==1 \u0026amp;\u0026amp; d==1)) nxt = 2; else if(d == 1) nxt = 1; else nxt = 0; res += f(pos+1, nxt, is_limit \u0026amp;\u0026amp; d==up); } if(!is_limit) dp[pos][state] = res; return res; }; //二进制表示中含连续的1的个数为f，所求即为n+1-f return n+1-f(0, 0, true); } }; 数字1的个数1 题目 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。\n示例 1：\n输入：n = 13 输出：6 示例 2：\n输入：n = 0 输出：0\n提示：\n0 \u0026lt;= n \u0026lt;= 10^9\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/number-of-digit-one 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 state记录数字1出现的个数即可\nis_num不必须，不影响1出现的个数\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int countDigitOne(int n) { auto s = to_string(n); int m = s.size(); int dp[m][m];//cnt: 数字1出现的个数 memset(dp,-1,sizeof(dp)); function\u0026lt;int(int,int,bool)\u0026gt; f = [\u0026amp;](int pos,int cnt,int is_limit)-\u0026gt;int{ if(pos == m) return cnt; if(!is_limit \u0026amp;\u0026amp; dp[pos][cnt]\u0026gt;=0) return dp[pos][cnt]; int res = 0; int up = is_limit?s[pos]-\u0026#39;0\u0026#39;:9; for(int d=0;d\u0026lt;=up;d++){ res += f(pos+1, cnt+(d==1), is_limit\u0026amp;\u0026amp;d==up); } if(!is_limit) dp[pos][cnt]=res; return res; }; return f(0,0,true); } }; ","date":"2022-08-19T00:00:00Z","image":"https://tetsuou.github.io/p/%E6%95%B0%E4%BD%8Ddp/post-bg-20220819_hu13021317095758420920.png","permalink":"https://tetsuou.github.io/p/%E6%95%B0%E4%BD%8Ddp/","title":"数位DP"},{"content":"\n【模拟】矩阵中的局部最大值 题目 给你一个大小为 n x n 的整数矩阵 grid 。\n生成一个大小为 (n - 2) x (n - 2) 的整数矩阵 maxLocal ，并满足：\nmaxLocal[i][j] 等于 grid 中以 i + 1 行和 j + 1 列为中心的 3 x 3 矩阵中的 最大值 。 换句话说，我们希望找出 grid 中每个 3 x 3 矩阵中的最大值。\n返回生成的矩阵。\n示例 1：\n1 2 3 4 输入：grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]] 输出：[[9,9],[8,6]] 解释：原矩阵和生成的矩阵如上图所示。 注意，生成的矩阵中，每个值都对应 grid 中一个相接的 3 x 3 矩阵的最大值。 示例 2：\n1 2 3 输入：grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]] 输出：[[2,2,2],[2,2,2],[2,2,2]] 解释：注意，2 包含在 grid 中每个 3 x 3 的矩阵中。 提示：\nn == grid.length == grid[i].length 3 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= grid[i][j] \u0026lt;= 100 解题思路 麻了，一开始用max 列表，报错了，还以为是c++版本没跟上，结束后才发现是 grid[i+1][j] 写成了grid[i+1, j]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: int fun(int i, int j,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid){ int res=0; res = max(res, grid[i-1][j-1]); res = max(res, grid[i-1][j]); res = max(res, grid[i-1][j+1]); res = max(res, grid[i][j-1]); res = max(res, grid[i][j]); res = max(res, grid[i][j+1]); res = max(res, grid[i+1][j-1]); res = max(res, grid[i+1][j]); res = max(res, grid[i+1][j+1]); return res; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; largestLocal(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(n-2, vector\u0026lt;int\u0026gt;(n-2,0)); for(int i=1;i\u0026lt;n-1;i++){ for(int j=1;j\u0026lt;n-1;j++){ // res[i-1][j-1] = max({grid[i][j],grid[i-1][j-1],grid[i-1][j],grid[i-1][j+1],grid[i][j-1],grid[i][j+1],grid[i+1][j-1],grid[i+1][j],grid[i+1][j+1]}); res[i-1][j-1] = fun(i,j,grid); } } return res; } }; 【模拟】边积分最高的节点 题目 给你一个有向图，图中有 n 个节点，节点编号从 0 到 n - 1 ，其中每个节点都 恰有一条 出边。\n图由一个下标从 0 开始、长度为 n 的整数数组 edges 表示，其中 edges[i] 表示存在一条从节点 i 到节点 edges[i] 的 有向 边。\n节点 i 的 边积分 定义为：所有存在一条指向节点 i 的边的节点的 编号 总和。\n返回 边积分 最高的节点。如果多个节点的 边积分 相同，返回编号 最小 的那个。\n示例 1：\n1 2 3 4 5 6 7 8 输入：edges = [1,0,0,0,0,7,7,5] 输出：7 解释： - 节点 1、2、3 和 4 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 + 3 + 4 = 10 。 - 节点 0 有一条指向节点 1 的边，节点 1 的边积分等于 0 。 - 节点 7 有一条指向节点 5 的边，节点 5 的边积分等于 7 。 - 节点 5 和 6 都有指向节点 7 的边，节点 7 的边积分等于 5 + 6 = 11 。 节点 7 的边积分最高，所以返回 7 。 示例 2：\n1 2 3 4 5 6 输入：edges = [2,0,0,2] 输出：0 解释： - 节点 1 和 2 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 = 3 。 - 节点 0 和 3 都有指向节点 2 的边，节点 2 的边积分等于 0 + 3 = 3 。 节点 0 和 2 的边积分都是 3 。由于节点 0 的编号更小，返回 0 。 提示：\nn == edges.length 2 \u0026lt;= n \u0026lt;= 10^5 0 \u0026lt;= edges[i] \u0026lt; n edges[i] != i 解题思路 麻了，第一发超int，第二发将记录数组改成了long long，但忘记将后面比较的也改成 long long， 又WA了\n太紧张了没发现\n用python重写交了\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution: def edgeScore(self, edges: List[int]) -\u0026gt; int: n = len(edges) a = [0 for i in range(0,n)] for i in range(0,n): a[edges[i]] += i; res = 0 maxv = 0 for i in range(0,n): if (a[i]\u0026gt;maxv): maxv = a[i] res = i ## print(a) return res 【DFS/贪心】根据模式串构造最小数字 题目 给你下标从 0 开始、长度为 n 的字符串 pattern ，它包含两种字符，'I' 表示 上升 ，'D' 表示 下降 。\n你需要构造一个下标从 0 开始长度为 n + 1 的字符串，且它要满足以下条件：\nnum 包含数字 '1' 到 '9' ，其中每个数字 至多 使用一次。 如果 pattern[i] == 'I' ，那么 num[i] \u0026lt; num[i + 1] 。 如果 pattern[i] == 'D' ，那么 num[i] \u0026gt; num[i + 1] 。 请你返回满足上述条件字典序 最小 的字符串 num。\n示例 1：\n1 2 3 4 5 6 7 8 输入：pattern = \u0026#34;IIIDIDDD\u0026#34; 输出：\u0026#34;123549876\u0026#34; 解释： 下标 0 ，1 ，2 和 4 处，我们需要使 num[i] \u0026lt; num[i+1] 。 下标 3 ，5 ，6 和 7 处，我们需要使 num[i] \u0026gt; num[i+1] 。 一些可能的 num 的值为 \u0026#34;245639871\u0026#34; ，\u0026#34;135749862\u0026#34; 和 \u0026#34;123849765\u0026#34; 。 \u0026#34;123549876\u0026#34; 是满足条件最小的数字。 注意，\u0026#34;123414321\u0026#34; 不是可行解因为数字 \u0026#39;1\u0026#39; 使用次数超过 1 次。 示例 2：\n1 2 3 4 5 输入：pattern = \u0026#34;DDD\u0026#34; 输出：\u0026#34;4321\u0026#34; 解释： 一些可能的 num 的值为 \u0026#34;9876\u0026#34; ，\u0026#34;7321\u0026#34; 和 \u0026#34;8742\u0026#34; 。 \u0026#34;4321\u0026#34; 是满足条件最小的数字。 提示：\n1 \u0026lt;= pattern.length \u0026lt;= 8 pattern 只包含字符 'I' 和 'D' 。 解题思路 看数据范围，直接DFS走起\n也可以用贪心\n代码 DFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public: string res; string pat; int n; vector\u0026lt;int\u0026gt; vis; void dfs(int i, string cur){ if(i == n+1){ res = min(res, cur); // cout\u0026lt;\u0026lt;cur\u0026lt;\u0026lt;endl; return; } for(int j=1;j\u0026lt;=9;j++){ if(vis[j]) continue; if(i\u0026gt;0){ if(pat[i-1]==\u0026#39;I\u0026#39;) { if(j \u0026lt; cur.back()-\u0026#39;0\u0026#39;) continue; }else if(pat[i-1]==\u0026#39;D\u0026#39;){ if(j \u0026gt; cur.back()-\u0026#39;0\u0026#39;) continue; } } cur.push_back(j+\u0026#39;0\u0026#39;); vis[j] = 1; dfs(i+1,cur); vis[j] = 0; cur.pop_back(); } } string smallestNumber(string pattern) { n = pattern.size(); pat = pattern; vis.assign(10,0); string emp; res = \u0026#34;999999999\u0026#34;; dfs(0,emp); // cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return res; } }; 贪心 把pattern 按照III⋯IDDD⋯D 分组，每组前一段是I，后一段是 D。\n遍历每一段，设当前段的长度为 x，我们应该把剩余最小的 x 个数字填到该段上（如果是第一段则填最小的 x+1个数字），从而保证字典序最小。\n举例说明，假如第一段为IIIDDD，构造方案如下：\n前 2 个 I 视作长度为 3 的上升段； 剩余的 I 和 D 视作长度为 4 的下降段； 最小的 3 个数给上升段，然后剩余最小的 4 个数给下降段； 构造结果为1237654。 按照该方案分组模拟即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: string smallestNumber(string pattern) { int i = 0, n = pattern.length(); char cur = \u0026#39;1\u0026#39;; string ans(n + 1, 0); while (i \u0026lt; n) { if (i \u0026amp;\u0026amp; pattern[i] == \u0026#39;I\u0026#39;) ++i; for (; i \u0026lt; n \u0026amp;\u0026amp; pattern[i] == \u0026#39;I\u0026#39;; ++i) ans[i] = cur++; int i0 = i; while (i \u0026lt; n \u0026amp;\u0026amp; pattern[i] == \u0026#39;D\u0026#39;) ++i; for (int j = i; j \u0026gt;= i0; --j) ans[j] = cur++; } return ans; } }; 【数位DP】统计特殊整数 题目 如果一个正整数每一个数位都是 互不相同 的，我们称它是 特殊整数 。\n给你一个 正 整数 n ，请你返回区间 [1, n] 之间特殊整数的数目。\n示例 1：\n1 2 3 输入：n = 20 输出：19 解释：1 到 20 之间所有整数除了 11 以外都是特殊整数。所以总共有 19 个特殊整数。 示例 2：\n1 2 3 输入：n = 5 输出：5 解释：1 到 5 所有整数都是特殊整数。 示例 3：\n1 2 3 4 输入：n = 135 输出：110 解释：从 1 到 135 总共有 110 个整数是特殊整数。 不特殊的部分数字为：22 ，114 和 131 。 提示：\n1 \u0026lt;= n \u0026lt;= 2 * 10^9 解题思路 经典数位DP，原题了属于是（1012题）\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int countSpecialNumbers(int n) { string num = to_string(n); int m = num.size(), dp[m][1\u0026lt;\u0026lt;10]; memset(dp,-1,sizeof(dp)); function\u0026lt;int(int,int,bool,bool)\u0026gt; dfs = [\u0026amp;](int pos, int state, bool is_limit, bool is_num)-\u0026gt;int{ if(pos == m) return is_num; if(!is_limit \u0026amp;\u0026amp; is_num \u0026amp;\u0026amp; dp[pos][state]\u0026gt;=0) return dp[pos][state]; int res=0; //如果前面都没填，第i位明显不受限制，如n=123,第0位没填的话，第1位可填9 if(!is_num) res = dfs(pos+1,state,false,false);//可以跳过，不填数字 //根据is_num的值决定从0开始还是1开始，上界由is_limit决定 //枚举要填的数字 for(int d=1-is_num,up=is_limit?num[pos]-\u0026#39;0\u0026#39;:9;d\u0026lt;=up;d++){ if((state\u0026gt;\u0026gt;d \u0026amp;1)==0){//只有当前填的数字与之前填的数字没有重复时 才填 res += dfs(pos+1,state|(1\u0026lt;\u0026lt;d),is_limit\u0026amp;\u0026amp;d==up,true); } } if(!is_limit \u0026amp;\u0026amp; is_num) dp[pos][state] = res; return res; }; return dfs(0,0,true,false); } }; ","date":"2022-08-18T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220818_hu16827073754605014370.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第306场周赛总结"},{"content":"\n【枚举】算术三元组的数目 题目 给你一个下标从 0 开始、严格递增 的整数数组 nums 和一个正整数 diff 。如果满足下述全部条件，则三元组 (i, j, k) 就是一个 算术三元组 ：\ni \u0026lt; j \u0026lt; k ， nums[j] - nums[i] == diff 且 nums[k] - nums[j] == diff 返回不同 算术三元组 的数目*。*\n示例 1：\n1 2 3 4 5 输入：nums = [0,1,4,6,7,10], diff = 3 输出：2 解释： (1, 2, 4) 是算术三元组：7 - 4 == 3 且 4 - 1 == 3 。 (2, 4, 5) 是算术三元组：10 - 7 == 3 且 7 - 4 == 3 。 示例 2：\n1 2 3 4 5 输入：nums = [4,5,6,7,8,9], diff = 2 输出：2 解释： (0, 2, 4) 是算术三元组：8 - 6 == 2 且 6 - 4 == 2 。 (1, 3, 5) 是算术三元组：9 - 7 == 2 且 7 - 5 == 2 。 提示：\n3 \u0026lt;= nums.length \u0026lt;= 200 0 \u0026lt;= nums[i] \u0026lt;= 200 1 \u0026lt;= diff \u0026lt;= 50 nums 严格 递增 解题思路 看到数据范围很小，直接就三层循环走起了\n其实可以利用单调性，一次遍历即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int arithmeticTriplets(vector\u0026lt;int\u0026gt;\u0026amp; nums, int diff) { int n = nums.size(); int res=0; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;n;j++){ for(int k=0;k\u0026lt;n;k++){ if(i\u0026lt;j \u0026amp;\u0026amp; j\u0026lt;k \u0026amp;\u0026amp; nums[j]-nums[i]==diff \u0026amp;\u0026amp; nums[k]-nums[j]==diff) res++; } } } return res; } }; 偷学代码 1 2 3 4 5 6 7 8 9 class Solution { public: int arithmeticTriplets(vector\u0026lt;int\u0026gt;\u0026amp; nums, int diff) { set\u0026lt;int\u0026gt;s(nums.begin(),nums.end()); int ret=0; for(int i:s)ret+=(s.count(i-diff)\u0026amp;\u0026amp;s.count(i+diff)); return ret; } }; 【DFS/BFS/并查集】受限条件下可到达节点的数目 题目 现有一棵由 n 个节点组成的无向树，节点编号从 0 到 n - 1 ，共有 n - 1 条边。\n给你一个二维整数数组 edges ，长度为 n - 1 ，其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条边。另给你一个整数数组 restricted 表示 受限 节点。\n在不访问受限节点的前提下，返回你可以从节点 0 到达的 最多 节点数目*。*\n注意，节点 0 不 会标记为受限节点。\n示例 1：\n1 2 3 4 输入：n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5] 输出：4 解释：上图所示正是这棵树。 在不访问受限节点的前提下，只有节点 [0,1,2,3] 可以从节点 0 到达。 示例 2：\n1 2 3 4 输入：n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1] 输出：3 解释：上图所示正是这棵树。 在不访问受限节点的前提下，只有节点 [0,5,6] 可以从节点 0 到达。 提示：\n2 \u0026lt;= n \u0026lt;= 10^5 edges.length == n - 1 edges[i].length == 2 0 \u0026lt;= ai, bi \u0026lt; n ai != bi edges 表示一棵有效的树 1 \u0026lt;= restricted.length \u0026lt; n 1 \u0026lt;= restricted[i] \u0026lt; n restricted 中的所有值 互不相同 解题思路 常规搜索，DFS/BFS均可\n也可以用并查集\n代码 BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: int reachableNodes(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, vector\u0026lt;int\u0026gt;\u0026amp; restricted) { vector\u0026lt;int\u0026gt; G[n]; for(auto \u0026amp;x: edges){ G[x[0]].push_back(x[1]); G[x[1]].push_back(x[0]); } vector\u0026lt;int\u0026gt; restr(n,0); for(auto \u0026amp;x: restricted){ restr[x] = 1; } vector\u0026lt;int\u0026gt; dis(n,-1); dis[0] = 0; queue\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; que; que.emplace(0,0); while(!que.empty()){ auto [u,d] = que.front(); que.pop(); for(auto \u0026amp;v: G[u]){ if(dis[v]\u0026gt;-1) continue; if(restr[v]) continue; dis[v] = d+1; que.emplace(v,dis[v]); } } int res=0; for(int i=0;i\u0026lt;n;i++){ if(dis[i]\u0026gt;-1) res++; } return res; } }; 并查集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const int MAXN = 1e5+5; int fa[MAXN],sz[MAXN]; int find(int x){ return x==fa[x]?x:(fa[x]=find(fa[x])); } void join(int x, int y){ int a = find(x); int b = find(y); if(a!=b){ if(sz[a]\u0026lt;sz[b]) swap(a,b); fa[b] = a; sz[a] += sz[b]; } } class Solution { public: int reachableNodes(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, vector\u0026lt;int\u0026gt;\u0026amp; restricted) { for(int i=0;i\u0026lt;n;i++){ fa[i] = i; sz[i] = 1; } vector\u0026lt;int\u0026gt; ban(n,0); for(auto \u0026amp;x: restricted) ban[x]=1; for(auto \u0026amp;vec: edges){ int u = vec[0], v = vec[1]; if(ban[u] || ban[v]) continue; join(u, v); } // for(int i=0;i\u0026lt;n;i++){ // cout\u0026lt;\u0026lt;fa[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; // } return sz[fa[0]]; } }; 【线性DP】检查数组是否存在有效划分 题目 给你一个下标从 0 开始的整数数组 nums ，你必须将数组划分为一个或多个 连续 子数组。\n如果获得的这些子数组中每个都能满足下述条件 之一 ，则可以称其为数组的一种 有效 划分：\n子数组 恰 由 2 个相等元素组成，例如，子数组 [2,2] 。 子数组 恰 由 3 个相等元素组成，例如，子数组 [4,4,4] 。 子数组 恰 由 3 个连续递增元素组成，并且相邻元素之间的差值为 1 。例如，子数组 [3,4,5] ，但是子数组 [1,3,5] 不符合要求。 如果数组 至少 存在一种有效划分，返回 true ，否则，返回 false 。\n示例 1：\n1 2 3 4 输入：nums = [4,4,4,5,6] 输出：true 解释：数组可以划分成子数组 [4,4] 和 [4,5,6] 。 这是一种有效划分，所以返回 true 。 示例 2：\n1 2 3 输入：nums = [1,1,1,2] 输出：false 解释：该数组不存在有效划分。 提示：\n2 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^6 解题思路 令dp[i][j]表示前i个数中，状态为j ， 是否有效，其中j=0表示最后两个元素相等，j=1表示最后3个元素相等，j=2表示最后3个元素连续递增且差值为1\n按情况讨论即可，很常规的一道线性DP\n也可以省略第二维，将3种情况合在一起考虑\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public: bool validPartition(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int dp[n][3]; memset(dp,0,sizeof(dp)); if(nums[1]==nums[0]) dp[1][0] = 1; for(int i=2;i\u0026lt;n;i++){ //2个连续 if(nums[i]!=nums[i-1]) dp[i][0] = 0; else{ if(dp[i-2][0] || dp[i-2][1] || dp[i-2][2]) dp[i][0] = 1; else dp[i][0]=0; } //3个连续相等 if(nums[i]!=nums[i-1] || nums[i-1]!=nums[i-2]) dp[i][1] = 0; else{ if(i-3\u0026lt;0 || dp[i-3][0] || dp[i-3][1] ||dp[i-3][2]) dp[i][1] = 1; else dp[i][1] = 0; } //3个连续递增 if(nums[i]!=nums[i-1]+1 || nums[i-1]!=nums[i-2]+1) dp[i][2] = 0; else{ if(i-3\u0026lt;0 || dp[i-3][0] || dp[i-3][1] ||dp[i-3][2]) dp[i][2] = 1; else dp[i][2] = 0; } } return dp[n-1][0] || dp[n-1][1] || dp[n-1][2]; } }; 【序列DP】最长理想子序列 题目 给你一个由小写字母组成的字符串 s ，和一个整数 k 。如果满足下述条件，则可以将字符串 t 视作是 理想字符串 ：\nt 是字符串 s 的一个子序列。 t 中每两个 相邻 字母在字母表中位次的绝对差值小于或等于 k 。 返回 最长 理想字符串的长度。\n字符串的子序列同样是一个字符串，并且子序列还满足：可以经由其他字符串删除某些字符（也可以不删除）但不改变剩余字符的顺序得到。\n**注意：**字母表顺序不会循环。例如，'a' 和 'z' 在字母表中位次的绝对差值是 25 ，而不是 1 。\n示例 1：\n1 2 3 4 输入：s = \u0026#34;acfgbd\u0026#34;, k = 2 输出：4 解释：最长理想字符串是 \u0026#34;acbd\u0026#34; 。该字符串长度为 4 ，所以返回 4 。 注意 \u0026#34;acfgbd\u0026#34; 不是理想字符串，因为 \u0026#39;c\u0026#39; 和 \u0026#39;f\u0026#39; 的字母表位次差值为 3 。 示例 2：\n1 2 3 输入：s = \u0026#34;abcd\u0026#34;, k = 3 输出：4 解释：最长理想字符串是 \u0026#34;abcd\u0026#34; ，该字符串长度为 4 ，所以返回 4 。 提示：\n1 \u0026lt;= s.length \u0026lt;= 10^5 0 \u0026lt;= k \u0026lt;= 25 s 由小写英文字母组成 解题思路 令dp[i][j]表示以前i个字符中，且最后一个字符为j+\u0026lsquo;a\u0026rsquo;的最长理想字符串的长度\n然后进行状态转移即可，很常规的一道序列DP\nWA了一发，直接返回dp[n-1][s.back()-\u0026lsquo;a\u0026rsquo;]了，应该返回max (dp[n-1][j])，j范围为[0,26)的\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int longestIdealString(string s, int k) { int n = s.size(); int dp[n][26]; memset(dp,0,sizeof(dp)); dp[0][s[0]-\u0026#39;a\u0026#39;] = 1; for(int i=1;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;26;j++){ dp[i][j] = dp[i-1][j]; } for(int j=0;j\u0026lt;26;j++){ if(abs(j-(s[i]-\u0026#39;a\u0026#39;))\u0026gt;k) continue; dp[i][s[i]-\u0026#39;a\u0026#39;] = max(dp[i][s[i]-\u0026#39;a\u0026#39;], dp[i-1][j]+1); } } int res=0; for(int j=0;j\u0026lt;26;j++){ res = max(res, dp[n-1][j]); } return res; } }; 偷学代码 也可以直接令dp[i]表示以字符i+\u0026lsquo;a\u0026rsquo;结尾的最长理想子序列的长度\n省去字符的序号这个维度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int longestIdealString(string s, int k) { vector\u0026lt;int\u0026gt; f(26); for (char c : s) { int x = c - \u0026#39;a\u0026#39;; int t = 0; for (int y = 0; y \u0026lt; 26; y++) if (abs(x - y) \u0026lt;= k) t = max(t, f[y] + 1); f[x] = max(f[x], t); } int ans = 0; for (int i = 0; i \u0026lt; 26; i++) ans = max(ans, f[i]); return ans; } }; ","date":"2022-08-12T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220812_hu4935108245437284634.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第305场周赛总结"},{"content":"\n【模拟】合并相似的物品 题目 给你两个二维整数数组 items1 和 items2 ，表示两个物品集合。每个数组 items 有以下特质：\nitems[i] = [valuei, weighti] 其中 valuei 表示第 i 件物品的 价值 ，weighti 表示第 i 件物品的 重量 。 items 中每件物品的价值都是 唯一的 。 请你返回一个二维数组 ret，其中 ret[i] = [valuei, weighti]， weighti 是所有价值为 valuei 物品的 重量之和 。\n注意：ret 应该按价值 升序 排序后返回。\n示例 1：\n1 2 3 4 5 6 7 输入：items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]] 输出：[[1,6],[3,9],[4,5]] 解释： value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 5 ，总重量为 1 + 5 = 6 。 value = 3 的物品再 items1 中 weight = 8 ，在 items2 中 weight = 1 ，总重量为 8 + 1 = 9 。 value = 4 的物品在 items1 中 weight = 5 ，总重量为 5 。 所以，我们返回 [[1,6],[3,9],[4,5]] 。 示例 2：\n1 2 3 4 5 6 7 输入：items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]] 输出：[[1,4],[2,4],[3,4]] 解释： value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 3 ，总重量为 1 + 3 = 4 。 value = 2 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 1 ，总重量为 3 + 1 = 4 。 value = 3 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。 所以，我们返回 [[1,4],[2,4],[3,4]] 。 示例 3：\n1 2 3 4 5 6 7 输入：items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]] 输出：[[1,7],[2,4],[7,1]] 解释： value = 1 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 4 ，总重量为 3 + 4 = 7 。 value = 2 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。 value = 7 的物品在 items2 中 weight = 1 ，总重量为 1 。 所以，我们返回 [[1,7],[2,4],[7,1]] 。 提示：\n1 \u0026lt;= items1.length, items2.length \u0026lt;= 1000 items1[i].length == items2[i].length == 2 1 \u0026lt;= valuei, weighti \u0026lt;= 1000 items1 中每个 valuei 都是 唯一的 。 items2 中每个 valuei 都是 唯一的 。 解题思路 简单模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; mergeSimilarItems(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; items1, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; items2) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res = items1; for(auto \u0026amp;x: items2){ int v = x[0],w=x[1]; int n = res.size(); for(int i=0;i\u0026lt;n;i++){ if(res[i][0]==v){ res[i][1]+=w; break; } if(i==n-1){ res.push_back({v,w}); } } } sort(res.begin(),res.end(),[\u0026amp;](vector\u0026lt;int\u0026gt;\u0026amp; a, vector\u0026lt;int\u0026gt; \u0026amp;b){ return a[0]\u0026lt;b[0]; }); return res; } }; 【思维+枚举】统计坏数对的数目 题目 给你一个下标从 0 开始的整数数组 nums 。如果 i \u0026lt; j 且 j - i != nums[j] - nums[i] ，那么我们称 (i, j) 是一个 坏数对 。\n请你返回 nums 中 坏数对 的总数目。\n示例 1：\n1 2 3 4 5 6 7 8 输入：nums = [4,1,3,3] 输出：5 解释：数对 (0, 1) 是坏数对，因为 1 - 0 != 1 - 4 。 数对 (0, 2) 是坏数对，因为 2 - 0 != 3 - 4, 2 != -1 。 数对 (0, 3) 是坏数对，因为 3 - 0 != 3 - 4, 3 != -1 。 数对 (1, 2) 是坏数对，因为 2 - 1 != 3 - 1, 1 != 2 。 数对 (2, 3) 是坏数对，因为 3 - 2 != 3 - 3, 1 != 0 。 总共有 5 个坏数对，所以我们返回 5 。 示例 2：\n1 2 3 输入：nums = [1,2,3,4,5] 输出：0 解释：没有坏数对。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^9 解题思路 如果按原式$j-i\\neq nums[j]-nums[i]$想的话，不好想\n考虑对原式进行变换：$j-nums[j] \\neq i-nums[i]$\n限定i\u0026lt;j，总数对数量为$n*(n-1)/2$\n那么坏数对的数量即为 总数对的数量 减去 非坏数对\n即统计每个$i-nums[i]$所对应的数目\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: long long countBadPairs(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); long long res = 1ll*n*(n-1)/2; map\u0026lt;int,int\u0026gt; tab; for(int i=0;i\u0026lt;n;i++){ tab[i-nums[i]]++; } for(auto \u0026amp;x: tab){ res -= 1ll*x.second*(x.second-1)/2; } return res; } }; 【模拟】任务调度器 II 题目 给你一个下标从 0 开始的正整数数组 tasks ，表示需要 按顺序 完成的任务，其中 tasks[i] 表示第 i 件任务的 类型 。\n同时给你一个正整数 space ，表示一个任务完成 后 ，另一个 相同 类型任务完成前需要间隔的 最少 天数。\n在所有任务完成前的每一天，你都必须进行以下两种操作中的一种：\n完成 tasks 中的下一个任务 休息一天 请你返回完成所有任务所需的 最少 天数。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 输入：tasks = [1,2,1,2,3,1], space = 3 输出：9 解释： 9 天完成所有任务的一种方法是： 第 1 天：完成任务 0 。 第 2 天：完成任务 1 。 第 3 天：休息。 第 4 天：休息。 第 5 天：完成任务 2 。 第 6 天：完成任务 3 。 第 7 天：休息。 第 8 天：完成任务 4 。 第 9 天：完成任务 5 。 可以证明无法少于 9 天完成所有任务。 示例 2：\n1 2 3 4 5 6 7 8 9 10 11 输入：tasks = [5,8,8,5], space = 2 输出：6 解释： 6 天完成所有任务的一种方法是： 第 1 天：完成任务 0 。 第 2 天：完成任务 1 。 第 3 天：休息。 第 4 天：休息。 第 5 天：完成任务 2 。 第 6 天：完成任务 3 。 可以证明无法少于 6 天完成所有任务。 提示：\n1 \u0026lt;= tasks.length \u0026lt;= 10^5 1 \u0026lt;= tasks[i] \u0026lt;= 10^9 1 \u0026lt;= space \u0026lt;= tasks.length 解题思路 读懂题目这题就很简单，任务按tasks列表中的顺序完成，遍历一遍即可\n注意数据范围可能超过int\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: long long taskSchedulerII(vector\u0026lt;int\u0026gt;\u0026amp; tasks, int space) { int n = tasks.size(); map\u0026lt;int,long long\u0026gt; tab;//tab[i]=j 工作i上一次完成的时间 long long time = 0; for(int i=0;i\u0026lt;n;i++){ if(!tab.count(tasks[i])){ time++; tab[tasks[i]] = time; }else{ time++; if(time-tab[tasks[i]]\u0026lt;=space){ time += space - (time-tab[tasks[i]]-1); tab[tasks[i]] = time; }else{ tab[tasks[i]] = time; } } // cout\u0026lt;\u0026lt;tasks[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;time\u0026lt;\u0026lt;endl; } return time; } }; 【贪心】将数组排序的最少替换次数 题目 给你一个下表从 0 开始的整数数组 nums 。每次操作中，你可以将数组中任何一个元素替换为 任意两个 和为该元素的数字。\n比方说，nums = [5,6,7] 。一次操作中，我们可以将 nums[1] 替换成 2 和 4 ，将 nums 转变成 [5,2,4,7] 。 请你执行上述操作，将数组变成元素按 非递减 顺序排列的数组，并返回所需的最少操作次数。\n示例 1：\n1 2 3 4 5 6 输入：nums = [3,9,3] 输出：2 解释：以下是将数组变成非递减顺序的步骤： - [3,9,3] ，将9 变成 3 和 6 ，得到数组 [3,3,6,3] - [3,3,6,3] ，将 6 变成 3 和 3 ，得到数组 [3,3,3,3,3] 总共需要 2 步将数组变成非递减有序，所以我们返回 2 。 示例 2：\n1 2 3 输入：nums = [1,2,3,4,5] 输出：0 解释：数组已经是非递减顺序，所以我们返回 0 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^9 解题思路 贪心的想，肯定从最后一个元素开始\n如果nums[i-1]\u0026lt;=nums[i] ，满足非递减顺序，第nums[i-1]个数不用拆分\n如果nums[i-1]\u0026gt;nums[i]，不满足非递减顺序，需要进行拆分，考虑如何进行拆分\n肯定是尽量使得拆分得到的最小数最大\n令已经排列好的后一个数为cur，当前考虑的数为nums[i]，已知nums[i]\u0026gt;cur\n如果nums[i]%cur==0，即nums[i]可以拆分成整数个cur，此时非递减数组中最小数仍然是cur\n否则，nums[i]拆分出的数中的最小值minv一定小于cur，此时要考虑将minv最大化\nnums[i]能拆分出nums[i]/cur个cur，还剩下一个值小于cur，即拆分出nums[i]/cur+1个数\n此时直接将nums[i]平均拆分nums[i]/cur+1份，这个值就是最大化的最小值\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: long long minimumReplacement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if(n==1) return 0; long long res = 0; int cur = 1e9+5; for(int i=n-1;i\u0026gt;=0;i--){ if(nums[i]\u0026lt;=cur){ cur = nums[i]; }else{ if(nums[i]%cur==0){ res += 1ll*nums[i]/cur-1; }else{ res += 1ll*nums[i]/cur; int tmp = nums[i]/(nums[i]/cur+1); cur=tmp; } } // cout\u0026lt;\u0026lt;nums[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;cur\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } return res; } }; ","date":"2022-08-11T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220811_hu6615767653593077283.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC84%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第84场双周赛总结"},{"content":"\n【思维】使数组中所有元素都等于零 题目 给你一个非负整数数组 nums 。在一步操作中，你必须：\n选出一个正整数 x ，x 需要小于或等于 nums 中 最小 的 非零 元素。 nums 中的每个正整数都减去 x。 返回使 nums 中所有元素都等于 0 需要的 最少 操作数。\n示例 1：\n1 2 3 4 5 6 输入：nums = [1,5,0,3,5] 输出：3 解释： 第一步操作：选出 x = 1 ，之后 nums = [0,4,0,2,4] 。 第二步操作：选出 x = 2 ，之后 nums = [0,2,0,0,2] 。 第三步操作：选出 x = 2 ，之后 nums = [0,0,0,0,0] 。 示例 2：\n1 2 3 输入：nums = [0] 输出：0 解释：nums 中的每个元素都已经是 0 ，所以不需要执行任何操作。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 100 解题思路 可以想到，对数组进行排序后，一次操作能使最小的那些数归0\n所以本质上是求数组中非不同非零数的个数\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int minimumOperations(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; a(101,0); for(auto \u0026amp;x: nums){ if(x\u0026gt;0) a[x]++; } int res=0; for(int i=1;i\u0026lt;=100;i++) { if(a[i]) res++; } return res; } }; 【贪心】分组的最大数量 题目 给你一个正整数数组 grades ，表示大学中一些学生的成绩。你打算将 所有 学生分为一些 有序 的非空分组，其中分组间的顺序满足以下全部条件：\n第 i 个分组中的学生总成绩 小于 第 (i + 1) 个分组中的学生总成绩，对所有组均成立（除了最后一组）。 第 i 个分组中的学生总数 小于 第 (i + 1) 个分组中的学生总数，对所有组均成立（除了最后一组）。 返回可以形成的 最大 组数。\n示例 1：\n1 2 3 4 5 6 7 输入：grades = [10,6,12,7,3,5] 输出：3 解释：下面是形成 3 个分组的一种可行方法： - 第 1 个分组的学生成绩为 grades = [12] ，总成绩：12 ，学生数：1 - 第 2 个分组的学生成绩为 grades = [6,7] ，总成绩：6 + 7 = 13 ，学生数：2 - 第 3 个分组的学生成绩为 grades = [10,3,5] ，总成绩：10 + 3 + 5 = 18 ，学生数：3 可以证明无法形成超过 3 个分组。 示例 2：\n1 2 3 输入：grades = [8,8] 输出：1 解释：只能形成 1 个分组，因为如果要形成 2 个分组的话，会导致每个分组中的学生数目相等。 提示：\n1 \u0026lt;= grades.length \u0026lt;= 10^5 1 \u0026lt;= grades[i] \u0026lt;= 10^5 解题思路 为了使组数最大，应该按这样的大小分： 1,2,3\u0026hellip;.,n\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int maximumGroups(vector\u0026lt;int\u0026gt;\u0026amp; grades) { int n = grades.size(); int tmp=0,maxv=0; for(int i=1;;i++){ tmp+=i; if(tmp\u0026gt;n){ maxv = i-1; break; } } // cout\u0026lt;\u0026lt;maxv\u0026lt;\u0026lt;endl; // sort(grades.begin(),grades.end()); return maxv; } }; 【无权值有向图最短距离】找到离给定两个节点最近的节点 题目 给你一个 n 个节点的 有向图 ，节点编号为 0 到 n - 1 ，每个节点 至多 有一条出边。\n有向图用大小为 n 下标从 0 开始的数组 edges 表示，表示节点 i 有一条有向边指向 edges[i] 。如果节点 i 没有出边，那么 edges[i] == -1 。\n同时给你两个节点 node1 和 node2 。\n请你返回一个从 node1 和 node2 都能到达节点的编号，使节点 node1 和节点 node2 到这个节点的距离 较大值最小化。如果有多个答案，请返回 最小 的节点编号。如果答案不存在，返回 -1 。\n注意 edges 可能包含环。\n示例 1：\n1 2 3 4 输入：edges = [2,2,3,-1], node1 = 0, node2 = 1 输出：2 解释：从节点 0 到节点 2 的距离为 1 ，从节点 1 到节点 2 的距离为 1 。 两个距离的较大值为 1 。我们无法得到一个比 1 更小的较大值，所以我们返回节点 2 。 示例 2：\n1 2 3 4 输入：edges = [1,2,-1], node1 = 0, node2 = 2 输出：2 解释：节点 0 到节点 2 的距离为 2 ，节点 2 到它自己的距离为 0 。 两个距离的较大值为 2 。我们无法得到一个比 2 更小的较大值，所以我们返回节点 2 。 提示：\nn == edges.length 2 \u0026lt;= n \u0026lt;= 10^5 -1 \u0026lt;= edges[i] \u0026lt; n edges[i] != i 0 \u0026lt;= node1, node2 \u0026lt; n 解题思路 每个节点至多有一条出边。边无权值，可利用BFS预先处理出到两个root的最短距离，然后遍历找最值即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public: int n; vector\u0026lt;int\u0026gt; fun(vector\u0026lt;int\u0026gt;\u0026amp; edges, int root){ vector\u0026lt;int\u0026gt; dis(n,-1); queue\u0026lt;int\u0026gt; que; que.push(root); dis[root]=0; while(!que.empty()){ int u = que.front(); que.pop(); int v = edges[u]; if(v!=-1 \u0026amp;\u0026amp; dis[v]==-1){ que.push(v); dis[v] = dis[u]+1; } } return dis; } int closestMeetingNode(vector\u0026lt;int\u0026gt;\u0026amp; edges, int node1, int node2) { n = edges.size(); vector\u0026lt;int\u0026gt; d1 = fun(edges,node1); vector\u0026lt;int\u0026gt; d2 = fun(edges,node2); int minv = INT_MAX; int res=-1; for(int i=0;i\u0026lt;n;i++){ if(d1[i]\u0026gt;=0 \u0026amp;\u0026amp; d2[i]\u0026gt;=0){ int tmp = max(d1[i],d2[i]); if(tmp\u0026lt;minv){ minv = tmp; res = i; } } } return res; } }; 【有向图最长环】图中的最长环 题目 给你一个 n 个节点的 有向图 ，节点编号为 0 到 n - 1 ，其中每个节点 至多 有一条出边。\n图用一个大小为 n 下标从 0 开始的数组 edges 表示，节点 i 到节点 edges[i] 之间有一条有向边。如果节点 i 没有出边，那么 edges[i] == -1 。\n请你返回图中的 最长 环，如果没有任何环，请返回 -1 。\n一个环指的是起点和终点是 同一个 节点的路径。\n示例 1：\n1 2 3 4 输入：edges = [3,3,4,2,3] 输出去：3 解释：图中的最长环是：2 -\u0026gt; 4 -\u0026gt; 3 -\u0026gt; 2 。 这个环的长度为 3 ，所以返回 3 。 示例 2：\n1 2 3 输入：edges = [2,-1,3,1] 输出：-1 解释：图中没有任何环。 提示：\nn == edges.length 2 \u0026lt;= n \u0026lt;= 10^5 -1 \u0026lt;= edges[i] \u0026lt; n edges[i] != i 拓扑排序找环 每个节点至多有一条出边，所以一个点最多在一个环内。先利用拓扑排序将不成环的点剔除掉，再找最长环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: int longestCycle(vector\u0026lt;int\u0026gt;\u0026amp; edges) { int n = edges.size(); vector\u0026lt;int\u0026gt; in(n,0),cycle(n,1); for(auto \u0026amp;x:edges) if(x\u0026gt;-1) in[x]++; vector\u0026lt;int\u0026gt; zero; for(int i=0;i\u0026lt;n;i++){ if(in[i]==0) zero.push_back(i); } while(!zero.empty()){ int u = zero.back(); zero.pop_back(); cycle[u] = 0; if(edges[u]\u0026gt;-1){ if(--in[edges[u]]==0) zero.push_back(edges[u]); } } int res = -1; for(int i=0;i\u0026lt;n;i++){ if(!cycle[i]) continue; int u = i, cur = 0; while(cycle[u]){ cur++; cycle[u] = 0; u = edges[u]; } res = max(res, cur); } return res; } }; 时间戳 具体来说，初始时间戳clock=1，首次访问一个点 x 时，记录访问这个点的时间 time[x]=clock，然后将 clock 加一。\n如果首次访问一个点，则记录当前时间startTime=clock，并尝试从这个点出发，看能否找到环。如果找到了一个之前访问过的点 x，且之前访问 xx 的时间不早于 startTime，则说明我们找到了一个新的环，此时的环长就是前后两次访问 x 的时间差，即 clock−time[x]。\n取所有环长的最大值作为答案。若没有找到环，则返回 −1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int longestCycle(vector\u0026lt;int\u0026gt; \u0026amp;edges) { int n = edges.size(), time[n], ans = -1; memset(time, 0, sizeof(time)); for (int i = 0, clock = 1; i \u0026lt; n; ++i) { if (time[i]) continue; for (int x = i, start_time = clock; x \u0026gt;= 0; x = edges[x]) { if (time[x]) { // 重复访问 if (time[x] \u0026gt;= start_time) // 找到了一个新的环 ans = max(ans, clock - time[x]); break; } time[x] = clock++; } } return ans; } }; ","date":"2022-08-06T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220806_hu7901614523359433827.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第304场周赛总结"},{"content":"\n【模拟】第一个出现两次的字母 题目 给你一个由小写英文字母组成的字符串 s ，请你找出并返回第一个出现 两次 的字母。\n注意：\n如果 a 的 第二次 出现比 b 的 第二次 出现在字符串中的位置更靠前，则认为字母 a 在字母 b 之前出现两次。 s 包含至少一个出现两次的字母。 示例 1：\n1 2 3 4 5 6 7 8 输入：s = \u0026#34;abccbaacz\u0026#34; 输出：\u0026#34;c\u0026#34; 解释： 字母 \u0026#39;a\u0026#39; 在下标 0 、5 和 6 处出现。 字母 \u0026#39;b\u0026#39; 在下标 1 和 4 处出现。 字母 \u0026#39;c\u0026#39; 在下标 2 、3 和 7 处出现。 字母 \u0026#39;z\u0026#39; 在下标 8 处出现。 字母 \u0026#39;c\u0026#39; 是第一个出现两次的字母，因为在所有字母中，\u0026#39;c\u0026#39; 第二次出现的下标是最小的。 示例 2：\n1 2 3 4 输入：s = \u0026#34;abcdd\u0026#34; 输出：\u0026#34;d\u0026#34; 解释： 只有字母 \u0026#39;d\u0026#39; 出现两次，所以返回 \u0026#39;d\u0026#39; 。 提示：\n2 \u0026lt;= s.length \u0026lt;= 100 s 由小写英文字母组成 s 包含至少一个重复字母 解题思路 简单模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 class Solution { public: char repeatedCharacter(string s) { vector\u0026lt;int\u0026gt; cnt(26,0); for(auto \u0026amp;x: s){ cnt[x-\u0026#39;a\u0026#39;]++; if(cnt[x-\u0026#39;a\u0026#39;]\u0026gt;=2) return x; } return \u0026#39;?\u0026#39;; } }; 【枚举+哈希】相等行列对 题目 给你一个下标从 0 开始、大小为 n x n 的整数矩阵 grid ，返回满足 Ri 行和 Cj 列相等的行列对 (Ri, Cj) 的数目*。*\n如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。\n示例 1：\n1 2 3 4 输入：grid = [[3,2,1],[1,7,6],[2,7,7]] 输出：1 解释：存在一对相等行列对： - (第 2 行，第 1 列)：[2,7,7] 示例 2：\n1 2 3 4 5 6 输入：grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]] 输出：3 解释：存在三对相等行列对： - (第 0 行，第 0 列)：[3,1,2,2] - (第 2 行, 第 2 列)：[2,4,2,2] - (第 3 行, 第 2 列)：[2,4,2,2] 提示：\nn == grid.length == grid[i].length 1 \u0026lt;= n \u0026lt;= 200 1 \u0026lt;= grid[i][j] \u0026lt;= 10^5 解题思路 数据范围不大，枚举比较\n利用哈希降时间复杂度\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #define ull unsigned long long const int B = 1e9+7; class Solution { public: int equalPairs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(); unordered_map\u0026lt;ull,int\u0026gt; row,col; for(int i=0;i\u0026lt;n;i++){ ull ha = 0; for(int j=0;j\u0026lt;n;j++){ ha = ha*B+grid[i][j]; } row[ha]++; } for(int i=0;i\u0026lt;n;i++){ ull ha=0; for(int j=0;j\u0026lt;n;j++){ ha = ha*B+grid[j][i]; } col[ha]++; } int res = 0; for(auto \u0026amp;[ha,cnt]: row){ if(col.count(ha)) res += cnt*col[ha]; } return res; } }; 【模拟】设计食物评分系统 题目 设计一个支持下述操作的食物评分系统：\n修改 系统中列出的某种食物的评分。 返回系统中某一类烹饪方式下评分最高的食物。 实现 FoodRatings 类：\nFoodRatings(String[] foods, String[] cuisines, int[] ratings)初始化系统。食物由 foods 、cuisines 和ratings描述，长度均为n\nfoods[i] 是第 i 种食物的名字。 cuisines[i] 是第 i 种食物的烹饪方式。 ratings[i] 是第 i 种食物的最初评分。 void changeRating(String food, int newRating) 修改名字为 food 的食物的评分。\nString highestRated(String cuisine) 返回指定烹饪方式 cuisine 下评分最高的食物的名字。如果存在并列，返回 字典序较小 的名字。\n注意，字符串 x 的字典序比字符串 y 更小的前提是：x 在字典中出现的位置在 y 之前，也就是说，要么 x 是 y 的前缀，或者在满足 x[i] != y[i] 的第一个位置 i 处，x[i] 在字母表中出现的位置在 y[i] 之前。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 输入 [\u0026#34;FoodRatings\u0026#34;, \u0026#34;highestRated\u0026#34;, \u0026#34;highestRated\u0026#34;, \u0026#34;changeRating\u0026#34;, \u0026#34;highestRated\u0026#34;, \u0026#34;changeRating\u0026#34;, \u0026#34;highestRated\u0026#34;] [[[\u0026#34;kimchi\u0026#34;, \u0026#34;miso\u0026#34;, \u0026#34;sushi\u0026#34;, \u0026#34;moussaka\u0026#34;, \u0026#34;ramen\u0026#34;, \u0026#34;bulgogi\u0026#34;], [\u0026#34;korean\u0026#34;, \u0026#34;japanese\u0026#34;, \u0026#34;japanese\u0026#34;, \u0026#34;greek\u0026#34;, \u0026#34;japanese\u0026#34;, \u0026#34;korean\u0026#34;], [9, 12, 8, 15, 14, 7]], [\u0026#34;korean\u0026#34;], [\u0026#34;japanese\u0026#34;], [\u0026#34;sushi\u0026#34;, 16], [\u0026#34;japanese\u0026#34;], [\u0026#34;ramen\u0026#34;, 16], [\u0026#34;japanese\u0026#34;]] 输出 [null, \u0026#34;kimchi\u0026#34;, \u0026#34;ramen\u0026#34;, null, \u0026#34;sushi\u0026#34;, null, \u0026#34;ramen\u0026#34;] 解释 FoodRatings foodRatings = new FoodRatings([\u0026#34;kimchi\u0026#34;, \u0026#34;miso\u0026#34;, \u0026#34;sushi\u0026#34;, \u0026#34;moussaka\u0026#34;, \u0026#34;ramen\u0026#34;, \u0026#34;bulgogi\u0026#34;], [\u0026#34;korean\u0026#34;, \u0026#34;japanese\u0026#34;, \u0026#34;japanese\u0026#34;, \u0026#34;greek\u0026#34;, \u0026#34;japanese\u0026#34;, \u0026#34;korean\u0026#34;], [9, 12, 8, 15, 14, 7]); foodRatings.highestRated(\u0026#34;korean\u0026#34;); // 返回 \u0026#34;kimchi\u0026#34; // \u0026#34;kimchi\u0026#34; 是分数最高的韩式料理，评分为 9 。 foodRatings.highestRated(\u0026#34;japanese\u0026#34;); // 返回 \u0026#34;ramen\u0026#34; // \u0026#34;ramen\u0026#34; 是分数最高的日式料理，评分为 14 。 foodRatings.changeRating(\u0026#34;sushi\u0026#34;, 16); // \u0026#34;sushi\u0026#34; 现在评分变更为 16 。 foodRatings.highestRated(\u0026#34;japanese\u0026#34;); // 返回 \u0026#34;sushi\u0026#34; // \u0026#34;sushi\u0026#34; 是分数最高的日式料理，评分为 16 。 foodRatings.changeRating(\u0026#34;ramen\u0026#34;, 16); // \u0026#34;ramen\u0026#34; 现在评分变更为 16 。 foodRatings.highestRated(\u0026#34;japanese\u0026#34;); // 返回 \u0026#34;ramen\u0026#34; // \u0026#34;sushi\u0026#34; 和 \u0026#34;ramen\u0026#34; 的评分都是 16 。 // 但是，\u0026#34;ramen\u0026#34; 的字典序比 \u0026#34;sushi\u0026#34; 更小。 提示：\n1 \u0026lt;= n \u0026lt;= 2 * 10^4 n == foods.length == cuisines.length == ratings.length 1 \u0026lt;= foods[i].length, cuisines[i].length \u0026lt;= 10 foods[i]、cuisines[i] 由小写英文字母组成 1 \u0026lt;= ratings[i] \u0026lt;= 10^8 foods 中的所有字符串 互不相同 在对 changeRating 的所有调用中，food 是系统中食物的名字。 在对 highestRated 的所有调用中，cuisine 是系统中 至少一种 食物的烹饪方式。 最多调用 changeRating 和 highestRated 总计 2 * 10^4 次 解题思路 和这周双周赛T3类似\nWA了一发和上次同样的原因，val为空时，没有将该键值对erase掉\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class FoodRatings { public: map\u0026lt;string,map\u0026lt;string,int\u0026gt;\u0026gt; tab; map\u0026lt;string,map\u0026lt;int,set\u0026lt;string\u0026gt;\u0026gt;\u0026gt; res; map\u0026lt;string,string\u0026gt; type; FoodRatings(vector\u0026lt;string\u0026gt;\u0026amp; foods, vector\u0026lt;string\u0026gt;\u0026amp; cuisines, vector\u0026lt;int\u0026gt;\u0026amp; ratings) { int n = foods.size(); for(int i=0;i\u0026lt;n;i++){ type[foods[i]] = cuisines[i]; tab[cuisines[i]][foods[i]] = ratings[i]; res[cuisines[i]][ratings[i]].insert(foods[i]); } } void changeRating(string food, int newRating) { string typ = type[food]; int bef = tab[typ][food]; tab[typ][food] = newRating; res[typ][bef].erase(food); if(res[typ][bef].empty()) res[typ].erase(bef); res[typ][newRating].insert(food); } string highestRated(string cuisine) { return *res[cuisine].rbegin()-\u0026gt;second.begin(); } }; /** * Your FoodRatings object will be instantiated and called as such: * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings); * obj-\u0026gt;changeRating(food,newRating); * string param_2 = obj-\u0026gt;highestRated(cuisine); */ 【思维】优质数对的数目 题目 给你一个下标从 0 开始的正整数数组 nums 和一个正整数 k 。\n如果满足下述条件，则数对 (num1, num2) 是 优质数对 ：\nnum1 和 num2 都 在数组 nums 中存在。 num1 OR num2 和 num1 AND num2 的二进制表示中值为 1 的位数之和大于等于 k ，其中 OR 是按位 或 操作，而 AND 是按位 与 操作。 返回 不同 优质数对的数目。\n如果 a != c 或者 b != d ，则认为 (a, b) 和 (c, d) 是不同的两个数对。例如，(1, 2) 和 (2, 1) 不同。\n注意： 如果 num1 在数组中至少出现 一次 ，则满足 num1 == num2 的数对 (num1, num2) 也可以是优质数对。\n示例 1：\n1 2 3 4 5 6 7 输入：nums = [1,2,3,1], k = 3 输出：5 解释：有如下几个优质数对： - (3, 3)：(3 AND 3) 和 (3 OR 3) 的二进制表示都等于 (11) 。值为 1 的位数和等于 2 + 2 = 4 ，大于等于 k = 3 。 - (2, 3) 和 (3, 2)： (2 AND 3) 的二进制表示等于 (10) ，(2 OR 3) 的二进制表示等于 (11) 。值为 1 的位数和等于 1 + 2 = 3 。 - (1, 3) 和 (3, 1)： (1 AND 3) 的二进制表示等于 (01) ，(1 OR 3) 的二进制表示等于 (11) 。值为 1 的位数和等于 1 + 2 = 3 。 所以优质数对的数目是 5 。 示例 2：\n1 2 3 输入：nums = [5,1,1], k = 10 输出：0 解释：该数组中不存在优质数对。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^9 1 \u0026lt;= k \u0026lt;= 60 解题思路 num1 or num2 和num1 and num2的二进制中值为1的位数之和 与\nnum1 和num2的二进制中值为1的位数之和 等价\n把二进制数看成集合，根据容斥原理$|A\\cup B|=|A|+|B|-|A\\cap B|$得\n$|A\\cup B|+|A\\cap B|=|A|+|B|$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: long long countExcellentPairs(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { vector\u0026lt;int\u0026gt; tab(66,0); sort(nums.begin(),nums.end()); int n = unique(nums.begin(),nums.end())-nums.begin(); for(int i=0;i\u0026lt;n;i++){ int cnt = __builtin_popcount(nums[i]); tab[cnt]++; } long long res = 0; vector\u0026lt;long long\u0026gt; sum(66,0); sum[0] = tab[0]; for(int i=1;i\u0026lt;66;i++) sum[i] = sum[i-1]+tab[i]; for(int i=0;i\u0026lt;66;i++){ int tar = k-i; int cn = sum[65]; if(tar\u0026gt;0) cn-=sum[tar-1]; res += 1ll*tab[i]*cn; } return res; } }; 偷学代码 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int cnt[64]; long long countExcellentPairs(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { sort(nums.begin(),nums.end()); nums.resize(unique(nums.begin(),nums.end())-nums.begin()); for(auto x:nums)cnt[__builtin_popcountll(x)]++; long long ans=0; for(int i=0;i\u0026lt;64;i++)for(int j=0;j\u0026lt;64;j++) if(i+j\u0026gt;=k)ans+=1ll*cnt[i]*cnt[j]; return ans; } }; ","date":"2022-07-29T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220729_hu7268891283014218736.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第303场周赛总结"},{"content":"\n【模拟】最好的扑克手牌 题目 给你一个整数数组 ranks 和一个字符数组 suit 。你有 5 张扑克牌，第 i 张牌大小为 ranks[i] ，花色为 suits[i] 。\n下述是从好到坏你可能持有的 手牌类型 ：\n\u0026quot;Flush\u0026quot;：同花，五张相同花色的扑克牌。 \u0026quot;Three of a Kind\u0026quot;：三条，有 3 张大小相同的扑克牌。 \u0026quot;Pair\u0026quot;：对子，两张大小一样的扑克牌。 \u0026quot;High Card\u0026quot;：高牌，五张大小互不相同的扑克牌。 请你返回一个字符串，表示给定的 5 张牌中，你能组成的 最好手牌类型 。\n**注意：**返回的字符串 大小写 需与题目描述相同。\n示例 1：\n1 2 3 输入：ranks = [13,2,3,1,9], suits = [\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;] 输出：\u0026#34;Flush\u0026#34; 解释：5 张扑克牌的花色相同，所以返回 \u0026#34;Flush\u0026#34; 。 示例 2：\n1 2 3 4 5 输入：ranks = [4,4,2,4,4], suits = [\u0026#34;d\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;] 输出：\u0026#34;Three of a Kind\u0026#34; 解释：第一、二和四张牌组成三张相同大小的扑克牌，所以得到 \u0026#34;Three of a Kind\u0026#34; 。 注意我们也可以得到 \u0026#34;Pair\u0026#34; ，但是 \u0026#34;Three of a Kind\u0026#34; 是更好的手牌类型。 有其他的 3 张牌也可以组成 \u0026#34;Three of a Kind\u0026#34; 手牌类型。 示例 3：\n1 2 3 4 输入：ranks = [10,10,2,12,9], suits = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;d\u0026#34;] 输出：\u0026#34;Pair\u0026#34; 解释：第一和第二张牌大小相同，所以得到 \u0026#34;Pair\u0026#34; 。 我们无法得到 \u0026#34;Flush\u0026#34; 或者 \u0026#34;Three of a Kind\u0026#34; 。 提示：\nranks.length == suits.length == 5 1 \u0026lt;= ranks[i] \u0026lt;= 13 'a' \u0026lt;= suits[i] \u0026lt;= 'd' 任意两张扑克牌不会同时有相同的大小和花色。 解题思路 简单模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: string bestHand(vector\u0026lt;int\u0026gt;\u0026amp; ranks, vector\u0026lt;char\u0026gt;\u0026amp; suits) { map\u0026lt;char,int\u0026gt; s; map\u0026lt;int,int\u0026gt; r; for(auto \u0026amp;x: ranks) r[x]++; for(auto \u0026amp;x: suits) s[x]++; if(s.size()==1) return \u0026#34;Flush\u0026#34;; for(auto \u0026amp;x: r){ if(x.second\u0026gt;=3) return \u0026#34;Three of a Kind\u0026#34;; } for(auto \u0026amp;x: r){ if(x.second==2) return \u0026#34;Pair\u0026#34;; } return \u0026#34;High Card\u0026#34;; } }; 【枚举】全 0 子数组的数目 题目 给你一个整数数组 nums ，返回全部为 0 的 子数组 数目。\n子数组 是一个数组中一段连续非空元素组成的序列。\n示例 1：\n1 2 3 4 5 6 输入：nums = [1,3,0,0,2,0,0,4] 输出：6 解释： 子数组 [0] 出现了 4 次。 子数组 [0,0] 出现了 2 次。 不存在长度大于 2 的全 0 子数组，所以我们返回 6 。 示例 2：\n1 2 3 4 5 6 7 输入：nums = [0,0,0,2,0,0] 输出：9 解释： 子数组 [0] 出现了 5 次。 子数组 [0,0] 出现了 3 次。 子数组 [0,0,0] 出现了 1 次。 不存在长度大于 3 的全 0 子数组，所以我们返回 9 。 示例 3：\n1 2 3 输入：nums = [2,10,2019] 输出：0 解释：没有全 0 子数组，所以我们返回 0 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 -109 \u0026lt;= nums[i] \u0026lt;= 10^9 解题思路 一段长度为n的全部元素为0的数组，拥有全部元素为0的子数组数目为：$\\frac{n(n+1)}{2}$\n所以统计全部元素为0的数组即可\nWA的一发是统计0段的时候出错了\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #define ll long long class Solution { public: long long zeroFilledSubarray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); ll res=0; int i,l=-1,r=0; for(i=0;i\u0026lt;n;i++){ if(nums[i]==0){ if(l==-1) l=i,r=i; else r=i; }else{ if(l!=-1){ int len=r-l+1; res += 1ll*len*(len+1)/2; l=-1; } } } if(nums[n-1]==0){ int len=n-1-l+1; res += 1ll*len*(len+1)/2; } return res; } }; 偷学代码 考虑每个以 0 结尾的子数组的个数。\n统计连续 0 组成的长度 c，每个 c 可以贡献 c 个子数组。\n0：以最后一个0为右端点的子数组，有1个\n00：以最后一个0为右端点的子数组，有2个\n000：以最后一个0为右端点的子数组，有3个\n\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: long long zeroFilledSubarray(vector\u0026lt;int\u0026gt; \u0026amp;nums) { long ans = 0L; int c = 0; for (int num : nums) if (num) c = 0; else ans += ++c; return ans; } }; 作者：endlesscheng 链接：https://leetcode.cn/problems/number-of-zero-filled-subarrays/solution/by-endlesscheng-men8/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 【模拟】设计数字容器系统 题目 设计一个数字容器系统，可以实现以下功能：\n在系统中给定下标处 插入 或者 替换 一个数字。 返回 系统中给定数字的最小下标。 请你实现一个 NumberContainers 类：\nNumberContainers() 初始化数字容器系统。 void change(int index, int number) 在下标 index 处填入 number 。如果该下标 index 处已经有数字了，那么用 number 替换该数字。 int find(int number) 返回给定数字 number 在系统中的最小下标。如果系统中没有 number ，那么返回 -1 。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 输入： [\u0026#34;NumberContainers\u0026#34;, \u0026#34;find\u0026#34;, \u0026#34;change\u0026#34;, \u0026#34;change\u0026#34;, \u0026#34;change\u0026#34;, \u0026#34;change\u0026#34;, \u0026#34;find\u0026#34;, \u0026#34;change\u0026#34;, \u0026#34;find\u0026#34;] [[], [10], [2, 10], [1, 10], [3, 10], [5, 10], [10], [1, 20], [10]] 输出： [null, -1, null, null, null, null, 1, null, 2] 解释： NumberContainers nc = new NumberContainers(); nc.find(10); // 没有数字 10 ，所以返回 -1 。 nc.change(2, 10); // 容器中下标为 2 处填入数字 10 。 nc.change(1, 10); // 容器中下标为 1 处填入数字 10 。 nc.change(3, 10); // 容器中下标为 3 处填入数字 10 。 nc.change(5, 10); // 容器中下标为 5 处填入数字 10 。 nc.find(10); // 数字 10 所在的下标为 1 ，2 ，3 和 5 。因为最小下标为 1 ，所以返回 1 。 nc.change(1, 20); // 容器中下标为 1 处填入数字 20 。注意，下标 1 处之前为 10 ，现在被替换为 20 。 nc.find(10); // 数字 10 所在下标为 2 ，3 和 5 。最小下标为 2 ，所以返回 2 。 提示：\n1 \u0026lt;= index, number \u0026lt;= 10^9 调用 change 和 find 的 总次数 不超过 10^5 次。 解题思路 每个下标不同，数字可能相同\nmap\u0026lt;int, set\u0026lt;int\u0026gt;\u0026gt; tab; 其key表示数字的值，value表示对应下标的集合\nmap\u0026lt;int, int\u0026gt; a; 其key表示下标，value表示对应下标的值\nWA了一发是由于tab的key对应集合为空的话，没有删除该键值对。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class NumberContainers { public: map\u0026lt;int,set\u0026lt;int\u0026gt;\u0026gt; tab; map\u0026lt;int,int\u0026gt; a; NumberContainers() { } void change(int index, int number) { if(!a.count(index)){ a[index] = number; tab[number].insert(index); }else{ int bef = a[index]; a[index] = number; tab[bef].erase(index); tab[number].insert(index); } } int find(int number) { if(!tab.count(number)) return -1; if(tab[number].empty()) return -1; return *tab[number].begin(); } }; /** * Your NumberContainers object will be instantiated and called as such: * NumberContainers* obj = new NumberContainers(); * obj-\u0026gt;change(index,number); * int param_2 = obj-\u0026gt;find(number); */ 【思维】不可能得到的最短骰子序列 题目 给你一个长度为 n 的整数数组 rolls 和一个整数 k 。你扔一个 k 面的骰子 n 次，骰子的每个面分别是 1 到 k ，其中第 i 次扔得到的数字是 rolls[i] 。\n请你返回 无法 从 rolls 中得到的 最短 骰子子序列的长度。\n扔一个 k 面的骰子 len 次得到的是一个长度为 len 的 骰子子序列 。\n注意 ，子序列只需要保持在原数组中的顺序，不需要连续。\n示例 1：\n1 2 3 4 5 6 输入：rolls = [4,2,1,2,3,3,2,4,1], k = 4 输出：3 解释：所有长度为 1 的骰子子序列 [1] ，[2] ，[3] ，[4] 都可以从原数组中得到。 所有长度为 2 的骰子子序列 [1, 1] ，[1, 2] ，... ，[4, 4] 都可以从原数组中得到。 子序列 [1, 4, 2] 无法从原数组中得到，所以我们返回 3 。 还有别的子序列也无法从原数组中得到。 示例 2：\n1 2 3 4 5 输入：rolls = [1,1,2,2], k = 2 输出：2 解释：所有长度为 1 的子序列 [1] ，[2] 都可以从原数组中得到。 子序列 [2, 1] 无法从原数组中得到，所以我们返回 2 。 还有别的子序列也无法从原数组中得到，但 [2, 1] 是最短的子序列。 示例 3：\n1 2 3 4 输入：rolls = [1,1,3,2,2,2,3,3], k = 4 输出：1 解释：子序列 [4] 无法从原数组中得到，所以我们返回 1 。 还有别的子序列也无法从原数组中得到，但 [4] 是最短的子序列。 提示：\nn == rolls.length 1 \u0026lt;= n \u0026lt;= 10^5 1 \u0026lt;= rolls[i] \u0026lt;= k \u0026lt;= 10^5 解题思路 遍历元素过程中维护一个set，每当set中元素种类数达到k时，说明可以得到的骰子子序列长度+1\n就是看可以产生res个这样的set，可以得到的骰子子序列最长长度就是res\n那么不能得到的最短骰子子序列长度即是res+1\n注意：当输入数据为[1,2,3,2,1]，3时，输出应该为2。此时，长度为2的骰子序列中，[3,3]未出现过\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int shortestSequence(vector\u0026lt;int\u0026gt;\u0026amp; rolls, int k) { set\u0026lt;int\u0026gt; st; int res=0; for(auto \u0026amp;x: rolls){ st.insert(x); if(st.size()==k){ st.clear(); res++; } } return res+1; } }; ","date":"2022-07-28T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC83%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220728_hu12785044786691708614.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC83%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第83场双周赛总结"},{"content":"\n【模拟】数组能形成多少数对 题目 给你一个下标从 0 开始的整数数组 nums 。在一步操作中，你可以执行以下步骤：\n从 nums 选出 两个 相等的 整数 从 nums 中移除这两个整数，形成一个 数对 请你在 nums 上多次执行此操作直到无法继续执行。\n返回一个下标从 0 开始、长度为 2 的整数数组 answer 作为答案，其中 answer[0] 是形成的数对数目，answer[1] 是对 nums 尽可能执行上述操作后剩下的整数数目。\n示例 1：\n1 2 3 4 5 6 7 输入：nums = [1,3,2,1,3,2,2] 输出：[3,1] 解释： nums[0] 和 nums[3] 形成一个数对，并从 nums 中移除，nums = [3,2,3,2,2] 。 nums[0] 和 nums[2] 形成一个数对，并从 nums 中移除，nums = [2,2,2] 。 nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [2] 。 无法形成更多数对。总共形成 3 个数对，nums 中剩下 1 个数字。 示例 2：\n1 2 3 4 输入：nums = [1,1] 输出：[1,0] 解释：nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [] 。 无法形成更多数对。总共形成 1 个数对，nums 中剩下 0 个数字。 示例 3：\n1 2 3 输入：nums = [0] 输出：[0,1] 解释：无法形成数对，nums 中剩下 1 个数字。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 100 解题思路 按题意模拟即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: vector\u0026lt;int\u0026gt; numberOfPairs(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int cnt=0,rst=nums.size(); int a[101]; memset(a,0,sizeof(a)); for(auto \u0026amp;x: nums){ a[x]++; if(a[x]\u0026gt;=2) cnt++,rst-=2,a[x]=0; } return {cnt,rst}; } }; 【枚举】数位和相等数对的最大和 题目 给你一个下标从 0 开始的数组 nums ，数组中的元素都是 正 整数。请你选出两个下标 i 和 j（i != j），且 nums[i] 的数位和 与 nums[j] 的数位和相等。\n请你找出所有满足条件的下标 i 和 j ，找出并返回 nums[i] + nums[j] 可以得到的 最大值 。\n示例 1：\n1 2 3 4 5 6 输入：nums = [18,43,36,13,7] 输出：54 解释：满足条件的数对 (i, j) 为： - (0, 2) ，两个数字的数位和都是 9 ，相加得到 18 + 36 = 54 。 - (1, 4) ，两个数字的数位和都是 7 ，相加得到 43 + 7 = 50 。 所以可以获得的最大和是 54 。 示例 2：\n1 2 3 输入：nums = [10,12,19,14] 输出：-1 解释：不存在满足条件的数对，返回 -1 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^9 解题思路 只有数位和相同的数才能相加，因此可统计不同数位和的数\nmultiset\u0026lt;int\u0026gt; G[101]; G[i]表示数位和为i的数的集合\nWA了一发是忽略了可能存在相同的数，一开始声明的是set，应该用multiset\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int maximumSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); multiset\u0026lt;int\u0026gt; G[101]; for(auto \u0026amp;x: nums){ int cur=0,num=x; while(x){ cur+=x%10; x/=10; } G[cur].insert(num); } int res = -1; for(int i=0;i\u0026lt;101;i++){ if(G[i].size()\u0026lt;=1) continue; int maxv = *G[i].rbegin(); auto it = ++G[i].rbegin(); int secv = *it; res = max(res, maxv+secv); } return res; } }; 【排序】裁剪数字后查询第 K 小的数字 题目 给你一个下标从 0 开始的字符串数组 nums ，其中每个字符串 长度相等 且只包含数字。\n再给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [ki, trimi] 。对于每个 queries[i] ，你需要：\n将 nums 中每个数字 裁剪 到剩下 最右边 trimi 个数位。 在裁剪过后的数字中，找到 nums 中第 ki 小数字对应的 下标 。如果两个裁剪后数字一样大，那么下标 更小 的数字视为更小的数字。 将 nums 中每个数字恢复到原本字符串。 请你返回一个长度与 queries 相等的数组 answer，其中 answer[i]是第 i 次查询的结果。\n提示：\n裁剪到剩下 x 个数位的意思是不断删除最左边的数位，直到剩下 x 个数位。 nums 中的字符串可能会有前导 0 。 示例 1：\n1 2 3 4 5 6 7 8 输入：nums = [\u0026#34;102\u0026#34;,\u0026#34;473\u0026#34;,\u0026#34;251\u0026#34;,\u0026#34;814\u0026#34;], queries = [[1,1],[2,3],[4,2],[1,2]] 输出：[2,2,1,0] 解释： 1. 裁剪到只剩 1 个数位后，nums = [\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;4\u0026#34;] 。最小的数字是 1 ，下标为 2 。 2. 裁剪到剩 3 个数位后，nums 没有变化。第 2 小的数字是 251 ，下标为 2 。 3. 裁剪到剩 2 个数位后，nums = [\u0026#34;02\u0026#34;,\u0026#34;73\u0026#34;,\u0026#34;51\u0026#34;,\u0026#34;14\u0026#34;] 。第 4 小的数字是 73 ，下标为 1 。 4. 裁剪到剩 2 个数位后，最小数字是 2 ，下标为 0 。 注意，裁剪后数字 \u0026#34;02\u0026#34; 值为 2 。 示例 2：\n1 2 3 4 5 6 输入：nums = [\u0026#34;24\u0026#34;,\u0026#34;37\u0026#34;,\u0026#34;96\u0026#34;,\u0026#34;04\u0026#34;], queries = [[2,1],[2,2]] 输出：[3,0] 解释： 1. 裁剪到剩 1 个数位，nums = [\u0026#34;4\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;4\u0026#34;] 。第 2 小的数字是 4 ，下标为 3 。 有两个 4 ，下标为 0 的 4 视为小于下标为 3 的 4 。 2. 裁剪到剩 2 个数位，nums 不变。第二小的数字是 24 ，下标为 0 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 100 1 \u0026lt;= nums[i].length \u0026lt;= 100 nums[i] 只包含数字。 所有 nums[i].length 的长度 相同 。 1 \u0026lt;= queries.length \u0026lt;= 100 queries[i].length == 2 1 \u0026lt;= ki \u0026lt;= nums.length 1 \u0026lt;= trimi \u0026lt;= nums[0].length 解题思路 看数据范围，选择暴力，即先求出最右边trimi个数位的数字数组，再对其进行排序，然后即可查询第K小的数字\nWA了第一发，画蛇添足的中间将字符串转换为数字后再排序，由于num.length可达100，stoi转int失败，其实用不着转int，按字典序排一样的。\nTLE了第二发，排序中使用了lambda函数，参数应该用引用形式\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: vector\u0026lt;int\u0026gt; smallestTrimmedNumbers(vector\u0026lt;string\u0026gt;\u0026amp; nums, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { int n = nums.size(); int m = nums[0].size(); vector\u0026lt;pair\u0026lt;string,int\u0026gt;\u0026gt; G[m+1];//G[i] 最右边i个数的数组 for(int k=0;k\u0026lt;n;k++){ string num = nums[k]; string str; for(int i=m;i\u0026gt;=1;i--){ str = num[i-1]+str; G[m-i+1].push_back(make_pair(str, k)); } // for(int i=1;i\u0026lt;=m;i++){ // str = num.substr(m-1-i+1,i); // G[i].push_back(make_pair(str, k)); // } } for(int i=1;i\u0026lt;=m;i++){ sort(G[i].begin(), G[i].end(), [\u0026amp;](pair\u0026lt;string,int\u0026gt;\u0026amp; a, pair\u0026lt;string,int\u0026gt;\u0026amp; b){ if(a.first!=b.first) return a.first\u0026lt;b.first; return a.second\u0026lt;b.second; }); } vector\u0026lt;int\u0026gt; res; for(auto \u0026amp;x: queries){ int k=x[0],trim=x[1]; res.push_back(G[trim][k-1].second); } return res; } }; 【数学】使数组可以被整除的最少删除次数 题目 给你两个正整数数组 nums 和 numsDivide 。你可以从 nums 中删除任意数目的元素。\n请你返回使 nums 中 最小 元素可以整除 numsDivide 中所有元素的 最少 删除次数。如果无法得到这样的元素，返回 -1 。\n如果 y % x == 0 ，那么我们说整数 x 整除 y 。\n示例 1：\n1 2 3 4 5 6 7 输入：nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15] 输出：2 解释： [2,3,2,4,3] 中最小元素是 2 ，它无法整除 numsDivide 中所有元素。 我们从 nums 中删除 2 个大小为 2 的元素，得到 nums = [3,4,3] 。 [3,4,3] 中最小元素为 3 ，它可以整除 numsDivide 中所有元素。 可以证明 2 是最少删除次数。 示例 2：\n1 2 3 4 5 输入：nums = [4,3,6], numsDivide = [8,2,6,10] 输出：-1 解释： 我们想 nums 中的最小元素可以整除 numsDivide 中的所有元素。 没有任何办法可以达到这一目的。 提示：\n1 \u0026lt;= nums.length, numsDivide.length \u0026lt;= 10^5 1 \u0026lt;= nums[i], numsDivide[i] \u0026lt;= 10^9 解题思路 水题。求出numsDivide的最大公约数\n然后每次删nums中的最小元素看是否满足条件\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int minOperations(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;int\u0026gt;\u0026amp; numsDivide) { int Gcd = numsDivide[0]; for(int i=1;i\u0026lt;numsDivide.size();i++) Gcd = __gcd(Gcd,numsDivide[i]); // cout\u0026lt;\u0026lt;Gcd\u0026lt;\u0026lt;endl; sort(nums.begin(),nums.end()); int res = -1; if(Gcd%nums[0]==0) { res = 0; return res; } int n = nums.size(),cur=0; for(int i=0;i\u0026lt;n;i++){ if(Gcd%nums[i]!=0) { cur++; }else{ return cur; } } return -1; } }; ","date":"2022-07-22T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC302%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220722_hu17363886187004542327.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC302%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第302场周赛总结"},{"content":"\n【贪心】装满杯子需要的最短总时长 题目 现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 2 杯 不同 类型的水或者 1 杯任意类型的水。\n给你一个下标从 0 开始、长度为 3 的整数数组 amount ，其中 amount[0]、amount[1] 和 amount[2] 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 最少 秒数。\n示例 1：\n1 2 3 4 5 6 7 8 输入：amount = [1,4,2] 输出：4 解释：下面给出一种方案： 第 1 秒：装满一杯冷水和一杯温水。 第 2 秒：装满一杯温水和一杯热水。 第 3 秒：装满一杯温水和一杯热水。 第 4 秒：装满一杯温水。 可以证明最少需要 4 秒才能装满所有杯子。 示例 2：\n1 2 3 4 5 6 7 8 9 10 输入：amount = [5,4,4] 输出：7 解释：下面给出一种方案： 第 1 秒：装满一杯冷水和一杯热水。 第 2 秒：装满一杯冷水和一杯温水。 第 3 秒：装满一杯冷水和一杯温水。 第 4 秒：装满一杯温水和一杯热水。 第 5 秒：装满一杯冷水和一杯热水。 第 6 秒：装满一杯冷水和一杯温水。 第 7 秒：装满一杯热水。 示例 3：\n1 2 3 输入：amount = [5,0,0] 输出：5 解释：每秒装满一杯冷水。 提示：\namount.length == 3 0 \u0026lt;= amount[i] \u0026lt;= 100 解题思路 赛时看数据规模直接模拟了，每次装待装容量最多的两种水即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int fillCups(vector\u0026lt;int\u0026gt;\u0026amp; amount) { int a=amount[0],b=amount[1],c=amount[2]; int res=0; while(1){ if(a==0\u0026amp;\u0026amp;b==0\u0026amp;\u0026amp;c==0) break; int maxv = max({a,b,c}); int minv = min({a,b,c}); int mid = (a+b+c)-maxv-minv; res++; maxv--; if(mid\u0026gt;0) mid--; a=maxv,b=mid,c=minv; } return res; } }; 偷学代码 肯定是最好每次都选两个。 分两种情况，一种是有一种水特别多，那么答案就是这种水的数量。\n否则，一定可以匹配到只剩一杯，或匹配完。\n1 2 3 4 5 6 7 8 9 class Solution { public: int fillCups(vector\u0026lt;int\u0026gt;\u0026amp; a) { sort(a.begin(),a.end()); int sum=a[0]+a[1]+a[2]; if(a[1]+a[0]\u0026gt;=a[2])sum=(sum+1)/2; else sum=a[2];return sum; } }; 【模拟】无限集中的最小数字 题目 现有一个包含所有正整数的集合 [1, 2, 3, 4, 5, ...] 。\n实现 SmallestInfiniteSet 类：\nSmallestInfiniteSet() 初始化 SmallestInfiniteSet 对象以包含 所有 正整数。 int popSmallest() 移除 并返回该无限集中的最小整数。 void addBack(int num) 如果正整数 num 不 存在于无限集中，则将一个 num 添加 到该无限集中。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 输入 [\u0026#34;SmallestInfiniteSet\u0026#34;, \u0026#34;addBack\u0026#34;, \u0026#34;popSmallest\u0026#34;, \u0026#34;popSmallest\u0026#34;, \u0026#34;popSmallest\u0026#34;, \u0026#34;addBack\u0026#34;, \u0026#34;popSmallest\u0026#34;, \u0026#34;popSmallest\u0026#34;, \u0026#34;popSmallest\u0026#34;] [[], [2], [], [], [], [1], [], [], []] 输出 [null, null, 1, 2, 3, null, 1, 4, 5] 解释 SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet(); smallestInfiniteSet.addBack(2); // 2 已经在集合中，所以不做任何变更。 smallestInfiniteSet.popSmallest(); // 返回 1 ，因为 1 是最小的整数，并将其从集合中移除。 smallestInfiniteSet.popSmallest(); // 返回 2 ，并将其从集合中移除。 smallestInfiniteSet.popSmallest(); // 返回 3 ，并将其从集合中移除。 smallestInfiniteSet.addBack(1); // 将 1 添加到该集合中。 smallestInfiniteSet.popSmallest(); // 返回 1 ，因为 1 在上一步中被添加到集合中， // 且 1 是最小的整数，并将其从集合中移除。 smallestInfiniteSet.popSmallest(); // 返回 4 ，并将其从集合中移除。 smallestInfiniteSet.popSmallest(); // 返回 5 ，并将其从集合中移除。 提示：\n1 \u0026lt;= num \u0026lt;= 1000 最多调用 popSmallest 和 addBack 方法 共计 1000 次 解题思路 模拟。大水题\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class SmallestInfiniteSet { public: set\u0026lt;int\u0026gt; tab; SmallestInfiniteSet() { for(int i=1;i\u0026lt;=2333;i++){ tab.insert(i); } } int popSmallest() { int res = *tab.begin(); tab.erase(res); return res; } void addBack(int num) { if(!tab.count(num)) tab.insert(num); } }; /** * Your SmallestInfiniteSet object will be instantiated and called as such: * SmallestInfiniteSet* obj = new SmallestInfiniteSet(); * int param_1 = obj-\u0026gt;popSmallest(); * obj-\u0026gt;addBack(num); */ 【思维】移动片段得到字符串 题目 给你两个字符串 start 和 target ，长度均为 n 。每个字符串 仅 由字符 'L'、'R' 和 '_' 组成，其中：\n字符 'L' 和 'R' 表示片段，其中片段 'L' 只有在其左侧直接存在一个 空位 时才能向 左 移动，而片段 'R' 只有在其右侧直接存在一个 空位 时才能向 右 移动。 字符 '_' 表示可以被 任意 'L' 或 'R' 片段占据的空位。 如果在移动字符串 start 中的片段任意次之后可以得到字符串 target ，返回 true ；否则，返回 false 。\n示例 1：\n1 2 3 4 5 6 7 输入：start = \u0026#34;_L__R__R_\u0026#34;, target = \u0026#34;L______RR\u0026#34; 输出：true 解释：可以从字符串 start 获得 target ，需要进行下面的移动： - 将第一个片段向左移动一步，字符串现在变为 \u0026#34;L___R__R_\u0026#34; 。 - 将最后一个片段向右移动一步，字符串现在变为 \u0026#34;L___R___R\u0026#34; 。 - 将第二个片段向右移动散步，字符串现在变为 \u0026#34;L______RR\u0026#34; 。 可以从字符串 start 得到 target ，所以返回 true 。 示例 2：\n1 2 3 4 输入：start = \u0026#34;R_L_\u0026#34;, target = \u0026#34;__LR\u0026#34; 输出：false 解释：字符串 start 中的 \u0026#39;R\u0026#39; 片段可以向右移动一步得到 \u0026#34;_RL_\u0026#34; 。 但是，在这一步之后，不存在可以移动的片段，所以无法从字符串 start 得到 target 。 示例 3：\n1 2 3 输入：start = \u0026#34;_R\u0026#34;, target = \u0026#34;R_\u0026#34; 输出：false 解释：字符串 start 中的片段只能向右移动，所以无法从字符串 start 得到 target 。 提示：\nn == start.length == target.length 1 \u0026lt;= n \u0026lt;= 10^5 start 和 target 由字符 'L'、'R' 和 '_' 组成 解题思路 首先L和R的个数要分别相等\n由于L和R不能互相穿过，所以相对位置要相等\nL只能往左移，R只能往右移\n相对位置相等时，start的L绝对位置一定不能小于target的L绝对位置，start的R绝对位置一定不能大于target的R绝对位置\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: bool canChange(string start, string target) { int n = start.size(); vector\u0026lt;pair\u0026lt;char,int\u0026gt;\u0026gt; s,t; for(int i=0;i\u0026lt;n;i++){ char ch=start[i]; if(ch==\u0026#39;L\u0026#39;){ s.push_back({\u0026#39;L\u0026#39;, i}); }else if(ch==\u0026#39;R\u0026#39;){ s.push_back({\u0026#39;R\u0026#39;, i}); } } for(int i=0;i\u0026lt;n;i++){ char ch=target[i]; if(ch==\u0026#39;L\u0026#39;){ t.push_back({\u0026#39;L\u0026#39;, i}); }else if(ch==\u0026#39;R\u0026#39;){ t.push_back({\u0026#39;R\u0026#39;, i}); } } int m = s.size(); if(t.size()!=m) return false; for(int i=0;i\u0026lt;m;i++){ if(s[i].first != t[i].first) return false; if(s[i].first==\u0026#39;L\u0026#39;){ if(s[i].second \u0026lt; t[i].second) return false; } else if(s[i].first==\u0026#39;R\u0026#39;){ if(s[i].second \u0026gt; t[i].second) return false; } } return true; } }; 【组合数学】统计理想数组的数目 题目 给你两个整数 n 和 maxValue ，用于描述一个 理想数组 。\n对于下标从 0 开始、长度为 n 的整数数组 arr ，如果满足以下条件，则认为该数组是一个 理想数组 ：\n每个 arr[i] 都是从 1 到 maxValue 范围内的一个值，其中 0 \u0026lt;= i \u0026lt; n 。 每个 arr[i] 都可以被 arr[i - 1] 整除，其中 0 \u0026lt; i \u0026lt; n 。 返回长度为 n 的 不同 理想数组的数目。由于答案可能很大，返回对 10^9 + 7 取余的结果。\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：n = 2, maxValue = 5 输出：10 解释：存在以下理想数组： - 以 1 开头的数组（5 个）：[1,1]、[1,2]、[1,3]、[1,4]、[1,5] - 以 2 开头的数组（2 个）：[2,2]、[2,4] - 以 3 开头的数组（1 个）：[3,3] - 以 4 开头的数组（1 个）：[4,4] - 以 5 开头的数组（1 个）：[5,5] 共计 5 + 2 + 1 + 1 + 1 = 10 个不同理想数组。 示例 2：\n1 2 3 4 5 6 7 8 9 10 输入：n = 5, maxValue = 3 输出：11 解释：存在以下理想数组： - 以 1 开头的数组（9 个）： - 不含其他不同值（1 个）：[1,1,1,1,1] - 含一个不同值 2（4 个）：[1,1,1,1,2], [1,1,1,2,2], [1,1,2,2,2], [1,2,2,2,2] - 含一个不同值 3（4 个）：[1,1,1,1,3], [1,1,1,3,3], [1,1,3,3,3], [1,3,3,3,3] - 以 2 开头的数组（1 个）：[2,2,2,2,2] - 以 3 开头的数组（1 个）：[3,3,3,3,3] 共计 9 + 1 + 1 = 11 个不同理想数组。 提示：\n2 \u0026lt;= n \u0026lt;= 10^4 1 \u0026lt;= maxValue \u0026lt;= 10^4 解题思路 考虑以x结尾的理想数组，x可以进行质因数分解 $x = q_1^{r_1}q_2^{r_2} \\cdots q_m^{r_m}$\n构造出一个理想数组等价为，先确定结尾x，再每次将$r_i$个$q_i$因子可重复地放入n个\u0026rsquo;盒子\u0026rsquo;中（长为n的数组的n个位置上）\n可重复组合$H_n^r = C_{n+r-1}^r$，可利用隔板法思考，即r个球和n-1个隔板进行组合，共C(r+n-1, r)种方案\n总共有m种小球，由乘法原理求最终结果\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #define ll long long const int MAXN = 1e4+16; const int MOD = 1e9+7; int c[MAXN][16]; vector\u0026lt;int\u0026gt; prime[MAXN]; void initc(){ c[0][0]=1; for(int i=1;i\u0026lt;MAXN;i++){ c[i][0]=1; for(int j=1;j\u0026lt;16;j++){ c[i][j] = (c[i-1][j]+c[i-1][j-1])%MOD; } } } void getprime(){//质因数分解 近似为O(maxn sqrt(maxn) sqrt(maxn)) prime[2].push_back(1);//2^1 prime[3].push_back(1);//3^1 for(int i=4;i\u0026lt;MAXN;i++){ int c=i; for(int j=2;j*j\u0026lt;=i;j++){ int cnt=0; while(c%j==0){ cnt++; c=c/j; } if(cnt\u0026gt;0) prime[i].push_back(cnt); } if(c\u0026gt;1) prime[i].push_back(1); } } int init = [](){ initc(); getprime(); return 0; }();//用lambda函数的方式在main函数外 执行一次 class Solution { public: int idealArrays(int n, int maxValue) { ll res=1;//all 1 for(int i=2;i\u0026lt;=maxValue;i++){ ll cur = 1; for(auto \u0026amp;r: prime[i]){//每个不同因子的数目为r个 cur = (cur*c[n-1+r][r])%MOD;//隔板法 n-1个板 r个小球 }//乘法原理乘起来 res = (res + cur)%MOD; } return res; } }; ","date":"2022-07-15T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC301%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220715_hu17405408393148474617.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC301%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第301场周赛总结"},{"content":"\n【递归】计算布尔二叉树的值 题目 给你一棵 完整二叉树 的根，这棵树有以下特征：\n叶子节点 要么值为 0 要么值为 1 ，其中 0 表示 False ，1 表示 True 。 非叶子节点 要么值为 2 要么值为 3 ，其中 2 表示逻辑或 OR ，3 表示逻辑与 AND 。 计算 一个节点的值方式如下：\n如果节点是个叶子节点，那么节点的 值 为它本身，即 True 或者 False 。 否则，计算 两个孩子的节点值，然后将该节点的运算符对两个孩子值进行 运算 。 返回根节点 root 的布尔运算值。\n完整二叉树 是每个节点有 0 个或者 2 个孩子的二叉树。\n叶子节点 是没有孩子的节点。\n示例 1：\n1 2 3 4 5 6 输入：root = [2,1,3,null,null,0,1] 输出：true 解释：上图展示了计算过程。 AND 与运算节点的值为 False AND True = False 。 OR 运算节点的值为 True OR False = True 。 根节点的值为 True ，所以我们返回 true 。 示例 2：\n1 2 3 输入：root = [0] 输出：false 解释：根节点是叶子节点，且值为 false，所以我们返回 false 。 提示：\n树中节点数目在 [1, 1000] 之间。 0 \u0026lt;= Node.val \u0026lt;= 3 每个节点的孩子数为 0 或 2 。 叶子节点的值为 0 或 1 。 非叶子节点的值为 2 或 3 。 解题思路 按题意递归模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool evaluateTree(TreeNode* root) { if(root==nullptr) return 0; bool res; if(root-\u0026gt;left==nullptr \u0026amp;\u0026amp; root-\u0026gt;right==nullptr){ res = root-\u0026gt;val; return res; } if(root-\u0026gt;val == 2){ res = evaluateTree(root-\u0026gt;left) | evaluateTree(root-\u0026gt;right); } else if(root-\u0026gt;val ==3){ res = evaluateTree(root-\u0026gt;left) \u0026amp; evaluateTree(root-\u0026gt;right); } return res; } }; 【二分 / 贪心+双指针】坐上公交的最晚时间 题目 给你一个下标从 0 开始长度为 n 的整数数组 buses ，其中 buses[i] 表示第 i 辆公交车的出发时间。同时给你一个下标从 0 开始长度为 m 的整数数组 passengers ，其中 passengers[j] 表示第 j 位乘客的到达时间。所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。\n给你一个整数 capacity ，表示每辆公交车 最多 能容纳的乘客数目。\n每位乘客都会搭乘下一辆有座位的公交车。如果你在 y 时刻到达，公交在 x 时刻出发，满足 y \u0026lt;= x 且公交没有满，那么你可以搭乘这一辆公交。最早 到达的乘客优先上车。\n返回你可以搭乘公交车的最晚到达公交站时间。你 不能 跟别的乘客同时刻到达。\n**注意：**数组 buses 和 passengers 不一定是有序的。\n示例 1：\n1 2 3 4 5 6 输入：buses = [10,20], passengers = [2,17,18,19], capacity = 2 输出：16 解释： 第 1 辆公交车载着第 1 位乘客。 第 2 辆公交车载着你和第 2 位乘客。 注意你不能跟其他乘客同一时间到达，所以你必须在第二位乘客之前到达。 示例 2：\n1 2 3 4 5 6 输入：buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2 输出：20 解释： 第 1 辆公交车载着第 4 位乘客。 第 2 辆公交车载着第 6 位和第 2 位乘客。 第 3 辆公交车载着第 1 位乘客和你。 提示：\nn == buses.length m == passengers.length 1 \u0026lt;= n, m, capacity \u0026lt;= 10^5 2 \u0026lt;= buses[i], passengers[i] \u0026lt;= 10^9 buses 中的元素 互不相同 。 passengers 中的元素 互不相同 。 解题思路 赛时有想尝试二分，但是当时觉得check函数不满足二段性，主要是受到了不能跟别的乘客同时刻到达的影响\n然后就去做第3题去了\n结束后看题解竟然可以二分\ncheck函数判断在k时刻能否搭上公交车，那么在k-1时刻也能搭上公交车；如果在k时刻不能搭上公交车，那么在k+1时刻也不能搭上公交车。（不用考虑和别的乘客同时刻到达的情况，就算同时刻到达，“把他挤下去”，先判断在这个时刻能不能搭上再说）\n中间搭车过程用双指针模拟即可，先到车站的先上车\n最后如果是已经存在的时刻，则向前减一，直到（且一定）存在一个不存在的时刻\n其实也用不到二分，直接用双指针模拟即可，搭上车的两种情况：1）还有空位的情况下，卡点上车；2）挤掉每一辆车的最后上车的那个人\n代码 二分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public: int latestTimeCatchTheBus(vector\u0026lt;int\u0026gt;\u0026amp; buses, vector\u0026lt;int\u0026gt;\u0026amp; passengers, int capacity) { int n = buses.size(); set\u0026lt;int\u0026gt; tab; for(auto \u0026amp;x: passengers) tab.insert(x); sort(buses.begin(),buses.end()); function\u0026lt;bool(int)\u0026gt; check = [\u0026amp;](int k){ vector\u0026lt;int\u0026gt; p(passengers.begin(),passengers.end()); p.push_back(k); sort(p.begin(),p.end()); int m = p.size(); for(int i=0,j=0;i\u0026lt;n;i++){ int rst = capacity; while(j\u0026lt;m \u0026amp;\u0026amp; p[j]\u0026lt;=buses[i] \u0026amp;\u0026amp; rst\u0026gt;0){ if(p[j]==k) return true;//k时间的能搭上公交车 rst--; j++; } } return false; };//在k时间是否可以搭上公交 int l=0,r=1e9+5; while(l\u0026lt;r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(check(mid)) l=mid+1; else r=mid; } int res = l-1; while(tab.count(res)) res--; return res; } }; 贪心+双指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int latestTimeCatchTheBus(vector\u0026lt;int\u0026gt;\u0026amp; buses, vector\u0026lt;int\u0026gt;\u0026amp; passengers, int capacity) { int n = buses.size(); int m = passengers.size(); set\u0026lt;int\u0026gt; tab; for(auto \u0026amp;x: passengers) tab.insert(x); sort(buses.begin(),buses.end()); sort(passengers.begin(),passengers.end()); int res=-1; for(int i=0,j=0;i\u0026lt;n;i++){ int rst = capacity; while(rst\u0026gt;0 \u0026amp;\u0026amp; j\u0026lt;m \u0026amp;\u0026amp; passengers[j]\u0026lt;=buses[i]){ res = passengers[j]; rst--; j++; } if(rst\u0026gt;0) res = max(res, buses[i]); } while(tab.count(res)) res--; return res; } }; 【贪心/二分】最小差值平方和 题目 给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，长度为 n 。\n数组 nums1 和 nums2 的 差值平方和 定义为所有满足 0 \u0026lt;= i \u0026lt; n 的 (nums1[i] - nums2[i])^2 之和。\n同时给你两个正整数 k1 和 k2 。你可以将 nums1 中的任意元素 +1 或者 -1 至多 k1 次。类似的，你可以将 nums2 中的任意元素 +1 或者 -1 至多 k2 次。\n请你返回修改数组 nums1 至多 k1 次且修改数组 nums2 至多 k2 次后的最小 差值平方和 。\n注意： 你可以将数组中的元素变成 负 整数。\n示例 1：\n1 2 3 4 输入：nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0 输出：579 解释：nums1 和 nums2 中的元素不能修改，因为 k1 = 0 和 k2 = 0 。 差值平方和为：(1 - 2)^2 + (2 - 10)^2 + (3 - 20)^2 + (4 - 19)^2 = 579 。 示例 2：\n1 2 3 4 5 6 7 8 输入：nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1 输出：43 解释：一种得到最小差值平方和的方式为： - 将 nums1[0] 增加一次。 - 将 nums2[2] 增加一次。 最小差值平方和为： (2 - 5)^2 + (4 - 8)^2 + (10 - 7)^2 + (12 - 9)^2 = 43 。 注意，也有其他方式可以得到最小差值平方和，但没有得到比 43 更小答案的方案。 提示：\nn == nums1.length == nums2.length 1 \u0026lt;= n \u0026lt;= 10^5 0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 10^5 0 \u0026lt;= k1, k2 \u0026lt;= 10^9 解题思路 先计算a[i] = abs(nums1[i] - nums2[i])，每次操作都是选定一个a[i]进行减一操作\n显然，每次减小最大的数的贡献最大，所以原题转化为：\n对a[i]\u0026gt;=0，进行k1+k2次操作，每次操作对a[i]-1，求a[i]的最小平方和\n所以每次将最高的山峰都消减至次高的山峰即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public: long long minSumSquareDiff(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k1, int k2) { int n = nums1.size(); int k = k1+k2; map\u0026lt;int,int,greater\u0026lt;int\u0026gt;\u0026gt; tab; for(int i=0;i\u0026lt;n;i++){ int cur = abs(nums1[i]-nums2[i]); tab[cur]++; } for(auto it=tab.begin();it!=tab.end();it++){ if(k==0) break; int u=it-\u0026gt;first, cnt = it-\u0026gt;second; auto nit = it;nit++; int nxt = (nit==tab.end())?0:(nit-\u0026gt;first); // cout\u0026lt;\u0026lt;u\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;nxt\u0026lt;\u0026lt;endl; int all = (u - nxt)*cnt; if(k\u0026gt;=all){ k -= all; tab.erase(u); tab[nxt] += cnt; }else{ int layer = k/cnt; int rst = k%cnt; if(layer\u0026gt;0){ tab.erase(u); tab[u-layer] += cnt; tab[u-layer] -= rst; tab[u-layer-1] +=rst; }else{ tab[u] -= rst; tab[u-1] += rst; } break; } } long long ans = 0; for(auto \u0026amp;x: tab){ ans += 1ll*x.first*x.first*x.second; //cout\u0026lt;\u0026lt;x.first\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;x.second\u0026lt;\u0026lt;endl; } return ans; } }; 二分 先判断是否可以在k步内变成0。\n利用二分判断差值数组的每个a[i]的最小目标值u，即a[i] \u0026lt;= u\n再看是否有剩余的k\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #define ll long long class Solution { public: long long minSumSquareDiff(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k1, int k2) { int n = nums1.size(); vector\u0026lt;int\u0026gt; a(n); ll sum=0, k=k1+k2; for(int i=0;i\u0026lt;n;i++){ a[i] = abs(nums1[i]-nums2[i]); sum += (a[i]-0); } if(sum\u0026lt;=k) return 0; function\u0026lt;bool(int)\u0026gt; check = [\u0026amp;](int p){ int rst = k; for(int i=0;i\u0026lt;n;i++){ if(a[i]\u0026lt;=p) continue; rst -= a[i]-p; if(rst\u0026lt;0) return false; } return true; };//令每个a[i]\u0026lt;=p 是否ok int l=0,r=1e5+5; while(l\u0026lt;r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(check(mid)) r=mid; else l=mid+1; } int u = r;//最小可以使每个a[i]\u0026lt;=u ，还要看是否有剩余的k int rst = k; for(int i=0;i\u0026lt;n;i++){ if(a[i]\u0026lt;=u) continue; rst -= a[i]-u; a[i] = u; } if(rst){//如果还有剩余的k，一定小于u的数量，每个减一 for(int i=0;i\u0026lt;n;i++){ if(a[i]\u0026lt;u) continue; a[i]--; rst--; if(rst==0) break; } } ll res=0; for(int i=0;i\u0026lt;n;i++){ res = (res + a[i]*1ll*a[i]); } return res; } }; 【单调栈+思维】元素值大于变化阈值的子数组 题目 给你一个整数数组 nums 和一个整数 threshold 。\n找到长度为 k 的 nums 子数组，满足数组中 每个 元素都 大于 threshold / k 。\n请你返回满足要求的 任意 子数组的 大小 。如果没有这样的子数组，返回 -1 。\n子数组 是数组中一段连续非空的元素序列。\n示例 1：\n1 2 3 4 输入：nums = [1,3,4,3,1], threshold = 6 输出：3 解释：子数组 [3,4,3] 大小为 3 ，每个元素都大于 6 / 3 = 2 。 注意这是唯一合法的子数组。 示例 2：\n1 2 3 4 5 6 输入：nums = [6,5,6,5,8], threshold = 7 输出：1 解释：子数组 [8] 大小为 1 ，且 8 \u0026gt; 7 / 1 = 7 。所以返回 1 。 注意子数组 [6,5] 大小为 2 ，每个元素都大于 7 / 2 = 3.5 。 类似的，子数组 [6,5,6] ，[6,5,6,5] ，[6,5,6,5,8] 都是符合条件的子数组。 所以返回 2, 3, 4 和 5 都可以。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i], threshold \u0026lt;= 10^9 解题思路 要使得数组中每个元素都大于threshold/k，即数组中的最小值大于threshold/k\n对于k\u0026rsquo; \u0026gt; k, 有threshold/k\u0026rsquo; \u0026lt; threshold/k\n因此考虑以nums[i]为最小值的子数组，找出其最长子数组的长度m，如果有nums[i] \u0026gt; threshold/m，则m满足题意\n利用单调栈找出以nums[i]为最小值的子数组的范围\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int validSubarraySize(vector\u0026lt;int\u0026gt;\u0026amp; nums, int threshold) { int n = nums.size(); vector\u0026lt;int\u0026gt; L(n,-1),R(n,n);//两侧第一个比nums[i]小的元素 stack\u0026lt;int\u0026gt; stk; for(int i=0;i\u0026lt;n;i++){ while(!stk.empty() \u0026amp;\u0026amp; nums[stk.top()]\u0026gt;=nums[i]) stk.pop(); if(stk.empty()) L[i]=-1; else L[i]=stk.top(); stk.push(i); } while(!stk.empty()) stk.pop(); for(int i=n-1;i\u0026gt;=0;i--){ while(!stk.empty() \u0026amp;\u0026amp; nums[stk.top()]\u0026gt;=nums[i]) stk.pop(); if(stk.empty()) R[i]=n; else R[i]=stk.top(); stk.push(i); } for(int i=0;i\u0026lt;n;i++){ int m = R[i]-1 - (L[i]+1) + 1;//以nums[i]为最小值的区间的长度 if(1ll*nums[i] * m \u0026gt; 1ll*threshold) return m; } return -1; } }; ","date":"2022-07-12T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC82%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220712_hu18110628753784068249.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC82%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第82场双周赛总结"},{"content":"\n【模拟】解密消息 题目 给你字符串 key 和 message ，分别表示一个加密密钥和一段加密消息。解密 message 的步骤如下：\n使用 key 中 26 个英文小写字母第一次出现的顺序作为替换表中的字母 顺序 。 将替换表与普通英文字母表对齐，形成对照表。 按照对照表 替换 message 中的每个字母。 空格 ' ' 保持不变。 例如，key = \u0026quot;***hap***p***y*** ***bo***y\u0026quot;（实际的加密密钥会包含字母表中每个字母 至少一次），据此，可以得到部分对照表（'h' -\u0026gt; 'a'、'a' -\u0026gt; 'b'、'p' -\u0026gt; 'c'、'y' -\u0026gt; 'd'、'b' -\u0026gt; 'e'、'o' -\u0026gt; 'f'）。 返回解密后的消息。\n示例 1：\n1 2 3 4 输入：key = \u0026#34;the quick brown fox jumps over the lazy dog\u0026#34;, message = \u0026#34;vkbs bs t suepuv\u0026#34; 输出：\u0026#34;this is a secret\u0026#34; 解释：对照表如上图所示。 提取 \u0026#34;the quick brown fox jumps over the lazy dog\u0026#34; 中每个字母的首次出现可以得到替换表。 示例 2：\n1 2 3 4 输入：key = \u0026#34;eljuxhpwnyrdgtqkviszcfmabo\u0026#34;, message = \u0026#34;zwx hnfx lqantp mnoeius ycgk vcnjrdb\u0026#34; 输出：\u0026#34;the five boxing wizards jump quickly\u0026#34; 解释：对照表如上图所示。 提取 \u0026#34;eljuxhpwnyrdgtqkviszcfmabo\u0026#34; 中每个字母的首次出现可以得到替换表。 提示：\n26 \u0026lt;= key.length \u0026lt;= 2000 key 由小写英文字母及 ' ' 组成 key 包含英文字母表中每个字符（'a' 到 'z'）至少一次 1 \u0026lt;= message.length \u0026lt;= 2000 message 由小写英文字母和 ' ' 组成 解题思路 简单模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: string decodeMessage(string key, string message) { vector\u0026lt;int\u0026gt; mp(26,-1); int id=0; for(auto \u0026amp;x: key){ if(x==\u0026#39; \u0026#39;) continue; if(mp[x-\u0026#39;a\u0026#39;]==-1){ mp[x-\u0026#39;a\u0026#39;] = id++; } } for(auto \u0026amp;x: message){ if(x==\u0026#39; \u0026#39;) continue; x = \u0026#39;a\u0026#39; + mp[x-\u0026#39;a\u0026#39;]; } return message; } }; 【模拟】螺旋矩阵 IV 题目 给你两个整数：m 和 n ，表示矩阵的维数。\n另给你一个整数链表的头节点 head 。\n请你生成一个大小为 m x n 的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵 左上角 开始、顺时针 按 螺旋 顺序填充。如果还存在剩余的空格，则用 -1 填充。\n返回生成的矩阵。\n示例 1：\n1 2 3 4 输入：m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0] 输出：[[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]] 解释：上图展示了链表中的整数在矩阵中是如何排布的。 注意，矩阵中剩下的空格用 -1 填充。 示例 2：\n1 2 3 4 输入：m = 1, n = 4, head = [0,1,2] 输出：[[0,1,2,-1]] 解释：上图展示了链表中的整数在矩阵中是如何从左到右排布的。 注意，矩阵中剩下的空格用 -1 填充。 提示：\n1 \u0026lt;= m, n \u0026lt;= 10^5 1 \u0026lt;= m * n \u0026lt;= 10^5 链表中节点数目在范围 [1, m * n] 内 0 \u0026lt;= Node.val \u0026lt;= 1000 解题思路 利用宽搜进行模拟。\nWA了一次是因为最后一个点，4个方向都走不了的时候，应该返回了\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; spiralMatrix(int m, int n, ListNode* head) { //右 下 左 上 int dir[4][2] = { {0,1}, {1,0}, {0,-1}, {-1,0}}; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vis(m, vector\u0026lt;int\u0026gt;(n,0)); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(m,vector\u0026lt;int\u0026gt;(n,-1)); ListNode* tmp = head; queue\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; que; que.emplace(0,0); vis[0][0]=1; int flag = 0;//初始向右 while(tmp!=nullptr){ auto [x,y] = que.front(); g[x][y] = tmp-\u0026gt;val; int dx = x+dir[flag][0]; int dy = y+dir[flag][1]; int num=0; while((dx\u0026lt;0 || dx\u0026gt;=m || dy\u0026lt;0 || dy\u0026gt;=n) || vis[dx][dy] ){ flag = (flag+1)%4; num++; dx = x+dir[flag][0]; dy = y+dir[flag][1]; if(num\u0026gt;=4) return g; } que.pop(); vis[dx][dy]=1; tmp = tmp-\u0026gt;next; que.emplace(dx, dy); } return g; } }; 【差分】知道秘密的人数 题目 在第 1 天，有一个人发现了一个秘密。\n给你一个整数 delay ，表示每个人会在发现秘密后的 delay 天之后，每天 给一个新的人 分享 秘密。同时给你一个整数 forget ，表示每个人在发现秘密 forget 天之后会 忘记 这个秘密。一个人 不能 在忘记秘密那一天及之后的日子里分享秘密。\n给你一个整数 n ，请你返回在第 n 天结束时，知道秘密的人数。由于答案可能会很大，请你将结果对 10^9 + 7 取余 后返回。\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：n = 6, delay = 2, forget = 4 输出：5 解释： 第 1 天：假设第一个人叫 A 。（一个人知道秘密） 第 2 天：A 是唯一一个知道秘密的人。（一个人知道秘密） 第 3 天：A 把秘密分享给 B 。（两个人知道秘密） 第 4 天：A 把秘密分享给一个新的人 C 。（三个人知道秘密） 第 5 天：A 忘记了秘密，B 把秘密分享给一个新的人 D 。（三个人知道秘密） 第 6 天：B 把秘密分享给 E，C 把秘密分享给 F 。（五个人知道秘密） 示例 2：\n1 2 3 4 5 6 7 输入：n = 4, delay = 1, forget = 3 输出：6 解释： 第 1 天：第一个知道秘密的人为 A 。（一个人知道秘密） 第 2 天：A 把秘密分享给 B 。（两个人知道秘密） 第 3 天：A 和 B 把秘密分享给 2 个新的人 C 和 D 。（四个人知道秘密） 第 4 天：A 忘记了秘密，B、C、D 分别分享给 3 个新的人。（六个人知道秘密） 提示：\n2 \u0026lt;= n \u0026lt;= 1000 1 \u0026lt;= delay \u0026lt; forget \u0026lt;= n 解题思路 赛时太迷糊了\n赛后按原思路写出来了\n第一个人知道秘密的时间区间为[1, 1+forget-1]，而会去分享秘密的时间区间为[1+delay, 1+forget-1]\n在第i天时，只有处于分享秘密状态的人才会去分享秘密\n设第i天处于分享秘密状态的人数为sub，那么在区间[i, i+forget-1]上会新增sub个人知道秘密，在区间[i+delay, i+forget-1]上会新增sub个人开始分享秘密\n利用差分数组进行区间修改、单点查询\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #define ll long long const int MOD = 1e9+7; class Solution { public: int peopleAwareOfSecret(int n, int delay, int forget) { ll dif[2234], know[2234]; memset(dif,0,sizeof(dif)); memset(know,0,sizeof(know)); dif[1+delay]++, dif[1+forget]--;//一开始只有1个人，它的派生区间 know[1]++, know[1+forget]--;//这个人的记忆区间 ll all=1;//当前天知道秘密的人数 ll sub=0;//当前天可派生人数 for(int i=2;i\u0026lt;=n;i++){ sub = (sub + dif[i])%MOD; //可派生人数 开始传播秘密 know[i] = (know[i] + sub)%MOD; know[i+forget] = (know[i+forget]-sub+MOD)%MOD; //新增 可派生 dif[i+delay] = (dif[i+delay] + sub)%MOD; dif[i+forget] = (dif[i+forget] - sub+MOD)%MOD; all = (all + know[i])%MOD ; } return all; } }; 【记忆化搜索】网格图中递增路径的数目 题目 给你一个 m x n 的整数网格图 grid ，你可以从一个格子移动到 4 个方向相邻的任意一个格子。\n请你返回在网格图中从 任意 格子出发，达到 任意 格子，且路径中的数字是 严格递增 的路径数目。由于答案可能会很大，请将结果对 10^9 + 7 取余 后返回。\n如果两条路径中访问过的格子不是完全相同的，那么它们视为两条不同的路径。\n示例 1：\n1 2 3 4 5 6 7 输入：grid = [[1,1],[3,4]] 输出：8 解释：严格递增路径包括： - 长度为 1 的路径：[1]，[1]，[3]，[4] 。 - 长度为 2 的路径：[1 -\u0026gt; 3]，[1 -\u0026gt; 4]，[3 -\u0026gt; 4] 。 - 长度为 3 的路径：[1 -\u0026gt; 3 -\u0026gt; 4] 。 路径数目为 4 + 3 + 1 = 8 。 示例 2：\n1 2 3 4 5 6 输入：grid = [[1],[2]] 输出：3 解释：严格递增路径包括： - 长度为 1 的路径：[1]，[2] 。 - 长度为 2 的路径：[1 -\u0026gt; 2] 。 路径数目为 2 + 1 = 3 。 提示：\nm == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 1000 1 \u0026lt;= m * n \u0026lt;= 10^5 1 \u0026lt;= grid[i][j] \u0026lt;= 10^5 解题思路 可惜了，没去做\n令dp[i, j]表示以[i, j]结尾的递增路径的数目，进行记忆化搜索即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const int MOD=1e9+7; #define ll long long class Solution { public: int countPaths(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(),m=grid[0].size(); int dir[4][2]={ {-1,0},{1,0},{0,1},{0,-1} }; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; dp(n, vector\u0026lt;ll\u0026gt;(m,0)); function\u0026lt;ll(int,int)\u0026gt; dfs = [\u0026amp;](int x, int y){ if(dp[x][y]\u0026gt;0) return dp[x][y]; dp[x][y] = 1; for(int i=0;i\u0026lt;4;i++){ int dx=x+dir[i][0]; int dy=y+dir[i][1]; if(dx\u0026lt;0||dy\u0026lt;0||dx\u0026gt;=n||dy\u0026gt;=m) continue; if(grid[dx][dy] \u0026gt;= grid[x][y]) continue; dp[x][y] = (dp[x][y]+dfs(dx, dy))%MOD;; } return dp[x][y]; }; ll res=0; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ res = (res+dfs(i,j))%MOD; } } return res; } }; ","date":"2022-07-06T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC300%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220706_hu3001871944987811243.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC300%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第300场周赛总结"},{"content":"\n【模拟】判断矩阵是否是一个 X 矩阵 题目 如果一个正方形矩阵满足下述 全部 条件，则称之为一个 X 矩阵 ：\n矩阵对角线上的所有元素都 不是 0 矩阵中所有其他元素都是 0 给你一个大小为 n x n 的二维整数数组 grid ，表示一个正方形矩阵。如果 grid 是一个 X 矩阵 ，返回 true ；否则，返回 false 。\n示例 1：\n1 2 3 4 5 输入：grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]] 输出：true 解释：矩阵如上图所示。 X 矩阵应该满足：绿色元素（对角线上）都不是 0 ，红色元素都是 0 。 因此，grid 是一个 X 矩阵。 示例 2：\n1 2 3 4 5 输入：grid = [[5,7,0],[0,3,1],[0,5,0]] 输出：false 解释：矩阵如上图所示。 X 矩阵应该满足：绿色元素（对角线上）都不是 0 ，红色元素都是 0 。 因此，grid 不是一个 X 矩阵。 提示：\nn == grid.length == grid[i].length 3 \u0026lt;= n \u0026lt;= 100 0 \u0026lt;= grid[i][j] \u0026lt;= 10^5 解题思路 简单模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: bool checkXMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(); for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;n;j++){ if(i==j||i+j==n-1){ if(grid[i][j]==0) return false; } else if(grid[i][j]!=0) return false; } } return true; } }; 【DP】统计放置房子的方式数 题目 一条街道上共有 n * 2 个 地块 ，街道的两侧各有 n 个地块。每一边的地块都按从 1 到 n 编号。每个地块上都可以放置一所房子。\n现要求街道同一侧不能存在两所房子相邻的情况，请你计算并返回放置房屋的方式数目。由于答案可能很大，需要对 10^9 + 7 取余后再返回。\n注意，如果一所房子放置在这条街某一侧上的第 i 个地块，不影响在另一侧的第 i 个地块放置房子。\n示例 1：\n1 2 3 4 5 6 7 8 输入：n = 1 输出：4 解释： 可能的放置方式： 1. 所有地块都不放置房子。 2. 一所房子放在街道的某一侧。 3. 一所房子放在街道的另一侧。 4. 放置两所房子，街道两侧各放置一所。 示例 2：\n1 2 3 输入：n = 2 输出：9 解释：如上图所示，共有 9 种可能的放置方式。 提示：\n1 \u0026lt;= n \u0026lt;= 10^4 解题思路 一眼DP，赛时用了三维，dp[i, j, k]表示前i块地，两侧的最后一块是否放置房子 的方案数\nWA了一发是因为dp数组定义忘记用long long 了\n其实只需要考虑一侧就好，因为两侧放置房子是独立的，方案数相同，由乘法原理最后计数相乘即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #define ll long long const int MOD=1e9+7; class Solution { public: int countHousePlacements(int n) { ll dp[n+1][2][2]; memset(dp,0,sizeof(dp)); dp[1][0][0]=1; dp[1][0][1]=1; dp[1][1][0]=1; dp[1][1][1]=1; for(int i=2;i\u0026lt;=n;i++){ dp[i][0][0] = (dp[i-1][0][0]+dp[i-1][0][1]+dp[i-1][1][0]+dp[i-1][1][1])%MOD; dp[i][0][1] = (dp[i-1][0][0]+dp[i-1][1][0])%MOD; dp[i][1][0] = (dp[i-1][0][0]+dp[i-1][0][1])%MOD; dp[i][1][1] = (dp[i-1][0][0])%MOD; } ll res=0; for(int i=0;i\u0026lt;2;i++){ for(int j=0;j\u0026lt;2;j++){ res = (res+dp[n][i][j])%MOD; } } return res; } }; 偷学代码 令f[i]表示一侧前i块地放置放置房子的方案数，第i块可以放，也可以不放\n考虑第i块：1）如果不放房子，那么第i-1块土地可放可不放，加上f[i-1] ； 2）如果放房子，那么第i-1块土地必不可放，第i-2块土地可放可不放，加上f[i-2]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const int MOD = 1e9 + 7, MX = 1e4 + 1; int f[MX] = {1, 2}; int init = []() { for (int i = 2; i \u0026lt; MX; ++i) f[i] = (f[i - 1] + f[i - 2]) % MOD; return 0; }(); class Solution { public: int countHousePlacements(int n) { return (long) f[n] * f[n] % MOD; } }; 【DP】拼接数组的最大分数 题目 给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，长度都是 n 。\n你可以选择两个整数 left 和 right ，其中 0 \u0026lt;= left \u0026lt;= right \u0026lt; n ，接着 交换 两个子数组 nums1[left...right] 和 nums2[left...right] 。\n例如，设 nums1 = [1,2,3,4,5] 和 nums2 = [11,12,13,14,15] ，整数选择 left = 1 和 right = 2，那么 nums1 会变为 [1,12,13,4,5] 而 nums2 会变为 [11,2,3,14,15] 。 你可以选择执行上述操作 一次 或不执行任何操作。\n数组的 分数 取 sum(nums1) 和 sum(nums2) 中的最大值，其中 sum(arr) 是数组 arr 中所有元素之和。\n返回 可能的最大分数 。\n子数组 是数组中连续的一个元素序列。arr[left...right] 表示子数组包含 nums 中下标 left 和 right 之间的元素 （含 下标 left 和 right 对应元素）。\n示例 1：\n1 2 3 4 输入：nums1 = [60,60,60], nums2 = [10,90,10] 输出：210 解释：选择 left = 1 和 right = 1 ，得到 nums1 = [60,90,60] 和 nums2 = [10,60,10] 。 分数为 max(sum(nums1), sum(nums2)) = max(210, 80) = 210 。 示例 2：\n1 2 3 4 输入：nums1 = [20,40,20,70,30], nums2 = [50,20,50,40,20] 输出：220 解释：选择 left = 3 和 right = 4 ，得到 nums1 = [20,40,20,40,20] 和 nums2 = [50,20,50,70,30] 。 分数为 max(sum(nums1), sum(nums2)) = max(140, 220) = 220 。 示例 3：\n1 2 3 4 输入：nums1 = [7,11,13], nums2 = [1,1,1] 输出：31 解释：选择不交换任何子数组。 分数为 max(sum(nums1), sum(nums2)) = max(31, 3) = 31 。 提示：\nn == nums1.length == nums2.length 1 \u0026lt;= n \u0026lt;= 10^5 1 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 10^4 解题思路 交换两个数组的同一段的区间和，使得单个数组的总和最大\n在草稿纸上推一下示例就可以发现，就是找两个数组的差值数组的最大连续子段和，交换两个数组的这一段即可\nWA了一次是因为，两个数组的差值数组要考虑两种情况，a-b和b-a，只考虑了一种\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #define ll long long class Solution { public: int maximumsSplicedArray(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { int n=nums1.size(); vector\u0026lt;int\u0026gt; sum1(n+1,0),sum2(n+1,0); for(int i=1;i\u0026lt;=n;i++){ sum1[i]=sum1[i-1]+nums1[i-1]; sum2[i]=sum2[i-1]+nums2[i-1]; } vector\u0026lt;int\u0026gt; a1(n+1,0),a2(n+1,0); for(int i=1;i\u0026lt;=n;i++){ a1[i] = nums2[i-1]-nums1[i-1]; a2[i] = nums1[i-1]-nums2[i-1]; // cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } int maxv1=0,cur=0; for(int i=1;i\u0026lt;=n;i++){ cur = max(a1[i],cur+a1[i]); maxv1=max(maxv1,cur); } int maxv2=0; cur=0; for(int i=1;i\u0026lt;=n;i++){ cur = max(a2[i],cur+a2[i]); maxv2=max(maxv2,cur); } int res = max(sum1[n]+maxv1,sum2[n]+maxv2); return res; } }; 【DFS序+枚举】从树中删除边的最小分数 题目 存在一棵无向连通树，树中有编号从 0 到 n - 1 的 n 个节点， 以及 n - 1 条边。\n给你一个下标从 0 开始的整数数组 nums ，长度为 n ，其中 nums[i] 表示第 i 个节点的值。另给你一个二维整数数组 edges ，长度为 n - 1 ，其中 edges[i] = [ai, bi] 表示树中存在一条位于节点 ai 和 bi 之间的边。\n删除树中两条 不同 的边以形成三个连通组件。对于一种删除边方案，定义如下步骤以计算其分数：\n分别获取三个组件 每个 组件中所有节点值的异或值。 最大 异或值和 最小 异或值的 差值 就是这一种删除边方案的分数。 例如，三个组件的节点值分别是：[4,5,7]、[1,9] 和 [3,3,3] 。三个异或值分别是 4 ^ 5 ^ 7 = ***6***、1 ^ 9 = ***8*** 和 3 ^ 3 ^ 3 = ***3*** 。最大异或值是 8 ，最小异或值是 3 ，分数是 8 - 3 = 5 。 返回在给定树上执行任意删除边方案可能的 最小 分数。\n示例 1：\n1 2 3 4 5 6 7 8 输入：nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]] 输出：9 解释：上图展示了一种删除边方案。 - 第 1 个组件的节点是 [1,3,4] ，值是 [5,4,11] 。异或值是 5 ^ 4 ^ 11 = 10 。 - 第 2 个组件的节点是 [0] ，值是 [1] 。异或值是 1 = 1 。 - 第 3 个组件的节点是 [2] ，值是 [5] 。异或值是 5 = 5 。 分数是最大异或值和最小异或值的差值，10 - 1 = 9 。 可以证明不存在分数比 9 小的删除边方案。 示例 2：\n1 2 3 4 5 6 7 8 输入：nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]] 输出：0 解释：上图展示了一种删除边方案。 - 第 1 个组件的节点是 [3,4] ，值是 [4,4] 。异或值是 4 ^ 4 = 0 。 - 第 2 个组件的节点是 [1,0] ，值是 [5,5] 。异或值是 5 ^ 5 = 0 。 - 第 3 个组件的节点是 [2,5] ，值是 [2,2] 。异或值是 2 ^ 2 = 0 。 分数是最大异或值和最小异或值的差值，0 - 0 = 0 。 无法获得比 0 更小的分数 0 。 提示：\nn == nums.length 3 \u0026lt;= n \u0026lt;= 1000 1 \u0026lt;= nums[i] \u0026lt;= 10^8 edges.length == n - 1 edges[i].length == 2 0 \u0026lt;= ai, bi \u0026lt; n ai != bi edges 表示一棵有效的树 解题思路 $O(n^2)$ 时间内枚举删除的两条边，$O(1)$ 时间内计算子树的异或和\n注意到 $a\\oplus b \\oplus a=b$\n删除两条边后有不同的情况，需要分类讨论：删除的两条边对应的4个（或3个）是否存在祖先关系\n利用DFS序在O(1)时间内判断两点是否存在祖先关系\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 const int INF=0x3f3f3f3f; class Solution { public: int minimumScore(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { int n = nums.size(); vector\u0026lt;int\u0026gt; G[n]; for(auto \u0026amp;x: edges){ G[x[0]].push_back(x[1]); G[x[1]].push_back(x[0]); } vector\u0026lt;int\u0026gt; vis(n,0),in(n,0),out(n,0),val(n,0); int time=0; function\u0026lt;int(int)\u0026gt; dfs = [\u0026amp;](int u)-\u0026gt;int{ in[u] = ++time; val[u] = nums[u]; vis[u] = 1; for(auto \u0026amp;v: G[u]){ if(vis[v]) continue; vis[v]=1; val[u] = val[u]^dfs(v); } out[u] = time; return val[u]; }; int root = 1; dfs(root); auto isFather = [\u0026amp;](int u, int v)-\u0026gt;bool{ return in[u]\u0026lt;=in[v] \u0026amp;\u0026amp; out[u]\u0026gt;=out[v]; }; for(auto \u0026amp;x: edges){//枚举边的时候确保第0个元素是第1个元素的父节点 if(isFather(x[0],x[1])) continue; else swap(x[0],x[1]); } int maxv,minv,res=INF; for(int i=0;i\u0026lt;edges.size();i++){//枚举删除第1条变 int xi=edges[i][0],yi=edges[i][1]; for(int j=0;j\u0026lt;i;j++){//枚举删除第2条边 int xj=edges[j][0],yj=edges[j][1]; if(isFather(yi,yj)){//yi是yj的父节点 maxv = max({val[yj],val[yi]^val[yj],val[root]^val[yi]}); minv = min({val[yj],val[yi]^val[yj],val[root]^val[yi]}); }else if(isFather(yj,yi)){//yj是yi的父节点 maxv = max({val[yi],val[yj]^val[yi],val[root]^val[yj]}); minv = min({val[yi],val[yj]^val[yi],val[root]^val[yj]}); }else{//不存在祖先关系 maxv = max({val[yi],val[yj],val[root]^val[yi]^val[yj]}); minv = min({val[yi],val[yj],val[root]^val[yi]^val[yj]}); } res = min(maxv-minv,res); } } return res; } }; ","date":"2022-06-29T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC299%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220629_hu7695981661079306051.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC299%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第299场周赛总结"},{"content":"\n【模拟】统计星号 题目 给你一个字符串 s ，每 两个 连续竖线 '|' 为 一对 。换言之，第一个和第二个 '|' 为一对，第三个和第四个 '|' 为一对，以此类推。\n请你返回 不在 竖线对之间，s 中 '*' 的数目。\n注意，每个竖线 '|' 都会 恰好 属于一个对。\n示例 1：\n1 2 3 4 5 6 输入：s = \u0026#34;l|*e*et|c**o|*de|\u0026#34; 输出：2 解释：不在竖线对之间的字符加粗加斜体后，得到字符串：\u0026#34;l|*e*et|c**o|*de|\u0026#34; 。 第一和第二条竖线 \u0026#39;|\u0026#39; 之间的字符不计入答案。 同时，第三条和第四条竖线 \u0026#39;|\u0026#39; 之间的字符也不计入答案。 不在竖线对之间总共有 2 个星号，所以我们返回 2 。 示例 2：\n1 2 3 输入：s = \u0026#34;iamprogrammer\u0026#34; 输出：0 解释：在这个例子中，s 中没有星号。所以返回 0 。 示例 3：\n1 2 3 输入：s = \u0026#34;yo|uar|e**|b|e***au|tifu|l\u0026#34; 输出：5 解释：需要考虑的字符加粗加斜体后：\u0026#34;yo|uar|e**|b|e***au|tifu|l\u0026#34; 。不在竖线对之间总共有 5 个星号。所以我们返回 5 。 提示：\n1 \u0026lt;= s.length \u0026lt;= 1000 s 只包含小写英文字母，竖线 '|' 和星号 '*' 。 s 包含 偶数 个竖线 '|' 。 解题思路 按提议模拟\n总的*个数 减去 竖线对之间的 *个数\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int countAsterisks(string s) { int n = s.size(); int in = 0, all = 0; bool hasleft=false; for(auto \u0026amp;ch: s){ if(ch==\u0026#39;*\u0026#39;) all++; if(ch==\u0026#39;|\u0026#39;){ if(hasleft) hasleft=false; else{ hasleft=true; } } if(hasleft\u0026amp;\u0026amp;ch==\u0026#39;*\u0026#39;) in++; } return all-in; } }; 【求连通块大小】统计无向图中无法互相到达点对数 题目 给你一个整数 n ，表示一张 无向图 中有 n 个节点，编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边。\n请你返回 无法互相到达 的不同 点对数目 。\n示例 1：\n1 2 3 输入：n = 3, edges = [[0,1],[0,2],[1,2]] 输出：0 解释：所有点都能互相到达，意味着没有点对无法互相到达，所以我们返回 0 。 示例 2：\n1 2 3 4 5 输入：n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]] 输出：14 解释：总共有 14 个点对互相无法到达： [[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]] 所以我们返回 14 。 提示：\n1 \u0026lt;= n \u0026lt;= 10^5 0 \u0026lt;= edges.length \u0026lt;= 2 * 10^5 edges[i].length == 2 0 \u0026lt;= ai, bi \u0026lt; n ai != bi 不会有重复边。 解题思路 求出每个点所在联通块的大小s，其对答案的贡献为 n-s\n或者考虑单个联通块大小s，其对答案的贡献为s*(n-s)\n无向图，最后除以2\n可以用并查集求连通块，也可以用BFS/DFS\n代码 并查集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 const int MAXN=1e5+5; int p[MAXN],s[MAXN]; int setfind(int x){ if(p[x]!=x) p[x]=setfind(p[x]); return p[x]; } void setunion(int x, int y){ if(setfind(x)==setfind(y)) return; s[setfind(y)]+=s[setfind(x)]; p[setfind(x)]=setfind(y); return; } int setsize(int x){ return s[setfind(x)]; } class Solution { public: void init(int n){ for(int i=0;i\u0026lt;n;i++){ p[i]=i; s[i]=1; } } long long countPairs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { long long res = 0; init(n); for(auto \u0026amp;x: edges){ setunion(x[0],x[1]); } for(int i=0;i\u0026lt;n;i++){ int sz = s[setfind(i)]; res += n-sz; } return res/2; } }; BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; e; vector\u0026lt;bool\u0026gt; vis; int bfs(int S) { int ret = 0; queue\u0026lt;int\u0026gt; q; q.push(S); vis[S] = true; while (!q.empty()) { ret++; int sn = q.front(); q.pop(); for (int fn : e[sn]) if (!vis[fn]) q.push(fn), vis[fn] = true; } return ret; } public: long long countPairs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { e.resize(n, vector\u0026lt;int\u0026gt;()); vis.resize(n, false); for (auto \u0026amp;edge : edges) e[edge[0]].push_back(edge[1]), e[edge[1]].push_back(edge[0]); long long ans = 0; for (int i = 0; i \u0026lt; n; i++) if (!vis[i]) { int t = bfs(i); ans += 1LL * t * (n - t); } return ans / 2; } }; // 作者：TsReaper // 链接：https://leetcode.cn/circle/discuss/Yj3lGZ/view/yUnvMQ/ // 来源：力扣（LeetCode） // 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 【思维+位操作】操作后的最大异或和 题目 给你一个下标从 0 开始的整数数组 nums 。一次操作中，选择 任意 非负整数 x 和一个下标 i ，更新 nums[i] 为 nums[i] AND (nums[i] XOR x) 。\n注意，AND 是逐位与运算，XOR 是逐位异或运算。\n请你执行 任意次 更新操作，并返回 nums 中所有元素 最大 逐位异或和。\n示例 1：\n1 2 3 4 5 6 输入：nums = [3,2,4,6] 输出：7 解释：选择 x = 4 和 i = 3 进行操作，num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2 。 现在，nums = [3, 2, 4, 2] 且所有元素逐位异或得到 3 XOR 2 XOR 4 XOR 2 = 7 。 可知 7 是能得到的最大逐位异或和。 注意，其他操作可能也能得到逐位异或和 7 。 示例 2：\n1 2 3 4 5 输入：nums = [1,2,3,9,2] 输出：11 解释：执行 0 次操作。 所有元素的逐位异或和为 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11 。 可知 11 是能得到的最大逐位异或和。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 0 \u0026lt;= nums[i] \u0026lt;= 10^8 解题思路 x可以取任意值，那么 nums[i] XOR x 的结果也是任意值\n上述结果再与nums[i]按位与，结果一定小于等于nums[i]，从位的角度看，即是将nums[i]的若干个1变成0\n最后要取最大的异或和，从位的角度看，能是1的位就令其为1，否则为0\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int maximumXOR(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; cnt(32,0); for(auto \u0026amp;num: nums){ for(int i=0;i\u0026lt;32;i++){ if((num\u0026gt;\u0026gt;i)\u0026amp;1) cnt[i]++; } } int res = 0; for(int i=0;i\u0026lt;32;i++){ if(cnt[i]==0) continue; res += (1\u0026lt;\u0026lt;i); } return res; } }; 偷学代码 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int maximumXOR(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int ans = 0; for (int x : nums) ans |= x; return ans; } }; // 作者：TsReaper // 链接：https://leetcode.cn/circle/discuss/Yj3lGZ/view/yUnvMQ/ // 来源：力扣（LeetCode） // 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 【DP】不同骰子序列的数目 题目 给你一个整数 n 。你需要掷一个 6 面的骰子 n 次。请你在满足以下要求的前提下，求出 不同 骰子序列的数目：\n序列中任意 相邻 数字的 最大公约数 为 1 。 序列中 相等 的值之间，至少有 2 个其他值的数字。正式地，如果第 i 次掷骰子的值 等于 第 j 次的值，那么 abs(i - j) \u0026gt; 2 。 请你返回不同序列的 总数目 。由于答案可能很大，请你将答案对 10^9 + 7 取余 后返回。\n如果两个序列中至少有一个元素不同，那么它们被视为不同的序列。\n示例 1：\n1 2 3 4 5 6 7 输入：n = 4 输出：184 解释：一些可行的序列为 (1, 2, 3, 4) ，(6, 1, 2, 3) ，(1, 2, 3, 1) 等等。 一些不可行的序列为 (1, 2, 1, 3) ，(1, 2, 3, 6) 。 (1, 2, 1, 3) 是不可行的，因为第一个和第三个骰子值相等且 abs(1 - 3) = 2 （下标从 1 开始表示）。 (1, 2, 3, 6) i是不可行的，因为 3 和 6 的最大公约数是 3 。 总共有 184 个不同的可行序列，所以我们返回 184 。 示例 2：\n1 2 3 4 5 输入：n = 2 输出：22 解释：一些可行的序列为 (1, 2) ，(2, 1) ，(3, 2) 。 一些不可行的序列为 (3, 6) ，(2, 4) ，因为最大公约数不为 1 。 总共有 22 个不同的可行序列，所以我们返回 22 。 提示：\n1 \u0026lt;= n \u0026lt;= 10^4 解题思路 一眼DP，但是状态定义错了，赛时考虑的是二维DP，结果不对，状态转移的时候考虑的情况有重复\n应该定义成三维的，第i位受限制于第i-1位和第i-2位\n令dp[i, j, k]为 子序列[1..i] 最后一位为k，倒数第二位为j的 可行序列方案数\n然后根据题意转移就方便很多，且不会重复了\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #define ll long long const int MOD = 1e9+7; class Solution { public: int distinctSequences(int n) { if(n==1) return 6; long long dp[n+1][7][7]; memset(dp,0,sizeof(dp)); for(int j=1;j\u0026lt;=6;j++){ for(int k=1;k\u0026lt;=6;k++){ dp[1][j][k]=1; } } for(int j=1;j\u0026lt;=6;j++){ for(int k=1;k\u0026lt;=6;k++){ if(__gcd(j,k)==1\u0026amp;\u0026amp;j!=k){ dp[2][j][k] = 1; } } } for(int i=3;i\u0026lt;=n;i++){//第i位 for(int j=1;j\u0026lt;=6;j++){//枚举第i-1位的数为j for(int k=1;k\u0026lt;=6;k++){//枚举第i位的数为k if(__gcd(j,k)!=1) continue; if(k==j) continue; for(int p=1;p\u0026lt;=6;p++){//枚举第i-2位的数 if(__gcd(p,j)!=1) continue; if(p==k) continue; dp[i][j][k]=(dp[i][j][k]+dp[i-1][p][j])%MOD; } } } } ll res = 0; for(int j=1;j\u0026lt;=6;j++){ for(int k=1;k\u0026lt;=6;k++){ res = (res+dp[n][j][k])%MOD; } } return res; } }; ","date":"2022-06-27T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC81%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220627_hu6384847478091020990.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC81%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第81场双周赛总结"},{"content":"\n【模拟】兼具大小写的最好英文字母 题目 给你一个由英文字母组成的字符串 s ，请你找出并返回 s 中的 最好 英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。\n最好 英文字母的大写和小写形式必须 都 在 s 中出现。\n英文字母 b 比另一个英文字母 a 更好 的前提是：英文字母表中，b 在 a 之 后 出现。\n示例 1：\n1 2 3 4 输入：s = \u0026#34;lEeTcOdE\u0026#34; 输出：\u0026#34;E\u0026#34; 解释： 字母 \u0026#39;E\u0026#39; 是唯一一个大写和小写形式都出现的字母。 示例 2：\n1 2 3 4 5 输入：s = \u0026#34;arRAzFif\u0026#34; 输出：\u0026#34;R\u0026#34; 解释： 字母 \u0026#39;R\u0026#39; 是大写和小写形式都出现的最好英文字母。 注意 \u0026#39;A\u0026#39; 和 \u0026#39;F\u0026#39; 的大写和小写形式也都出现了，但是 \u0026#39;R\u0026#39; 比 \u0026#39;F\u0026#39; 和 \u0026#39;A\u0026#39; 更好。 示例 3：\n1 2 3 4 输入：s = \u0026#34;AbCdEfGhIjK\u0026#34; 输出：\u0026#34;\u0026#34; 解释： 不存在大写和小写形式都出现的字母。 提示：\n1 \u0026lt;= s.length \u0026lt;= 1000 s 由小写和大写英文字母组成 解题思路 按题意模拟即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: string greatestLetter(string s) { vector\u0026lt;int\u0026gt; a(26,0),A(26,0); for(auto \u0026amp;x: s){ if(islower(x)) a[x-\u0026#39;a\u0026#39;]++; else A[x-\u0026#39;A\u0026#39;]++; } string res; for(int i=25;i\u0026gt;=0;i--){ if(a[i]\u0026amp;\u0026amp;A[i]) { res += \u0026#39;A\u0026#39;+i; break; } } return res; } }; 【枚举+数学】个位数字为 K 的整数之和 题目 给你两个整数 num 和 k ，考虑具有以下属性的正整数多重集：\n每个整数个位数字都是 k 。 所有整数之和是 num 。 返回该多重集的最小大小，如果不存在这样的多重集，返回 -1 。\n注意：\n多重集与集合类似，但多重集可以包含多个同一整数，空多重集的和为 0 。 个位数字 是数字最右边的数位。 示例 1：\n1 2 3 4 5 6 输入：num = 58, k = 9 输出：2 解释： 多重集 [9,49] 满足题目条件，和为 58 且每个整数的个位数字是 9 。 另一个满足条件的多重集是 [19,39] 。 可以证明 2 是满足题目条件的多重集的最小长度。 示例 2：\n1 2 3 输入：num = 37, k = 2 输出：-1 解释：个位数字为 2 的整数无法相加得到 37 。 示例 3：\n1 2 3 输入：num = 0, k = 7 输出：0 解释：空多重集的和为 0 。 提示：\n0 \u0026lt;= num \u0026lt;= 3000 0 \u0026lt;= k \u0026lt;= 9 解题思路 构造题的感觉\n考虑若干个末位数字相加后，其和的个位数字能否和num的个位数字相同\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int minimumNumbers(int num, int k) { if(num==0) return 0; if(num\u0026lt;k) return -1; int tar = num%10; bool flag = false; for(int i=1;i\u0026lt;=10;i++){ if(k*i%10==tar \u0026amp;\u0026amp; i*k\u0026lt;=num){ return i; flag=true; } } return -1; } }; 【贪心】小于等于 K 的最长二进制子序列 题目 给你一个二进制字符串 s 和一个正整数 k 。\n请你返回 s 的 最长 子序列，且该子序列对应的 二进制 数字小于等于 k 。\n注意：\n子序列可以有 前导 0 。 空字符串视为 0 。 子序列 是指从一个字符串中删除零个或者多个字符后，不改变顺序得到的剩余字符序列。 示例 1：\n1 2 3 4 5 输入：s = \u0026#34;1001010\u0026#34;, k = 5 输出：5 解释：s 中小于等于 5 的最长子序列是 \u0026#34;00010\u0026#34; ，对应的十进制数字是 2 。 注意 \u0026#34;00100\u0026#34; 和 \u0026#34;00101\u0026#34; 也是可行的最长子序列，十进制分别对应 4 和 5 。 最长子序列的长度为 5 ，所以返回 5 。 示例 2：\n1 2 3 4 输入：s = \u0026#34;00101001\u0026#34;, k = 1 输出：6 解释：\u0026#34;000001\u0026#34; 是 s 中小于等于 1 的最长子序列，对应的十进制数字是 1 。 最长子序列的长度为 6 ，所以返回 6 。 提示：\n1 \u0026lt;= s.length \u0026lt;= 1000 s[i] 要么是 '0' ，要么是 '1' 。 1 \u0026lt;= k \u0026lt;= 109 解题思路 赛时想到的是二分+贪心，但是贪心贪错了\n补题的时候想到了正确的贪心方式，二分就没必要了\n考虑k的二进制表示，其位数为len，（最高位为1）\n那么二进制位数小于len（最高位为1，即不考虑前导0）的数一定小于k\n如果位数相等，那么可以转换成10进制再比较大小\n最后补上尽量多的前导0即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int longestSubsequence(string s, int k) { vector\u0026lt;int\u0026gt; tar(1005,0); int high=-1; for(int i=0;i\u0026lt;32;i++){ tar[i] = (k\u0026gt;\u0026gt;i)\u0026amp;1; if(tar[i]==1){ high=i;//k的二进制表示中，最高位1所在的位置 } } if(high+1\u0026gt;=s.size()) return s.size(); int n=s.size(); int cnt=0; reverse(s.begin(),s.end()); for(int i=high+1;i\u0026lt;n;i++){ if(s[i]==\u0026#39;0\u0026#39;) cnt++; } string suf=s.substr(0,high+1); reverse(suf.begin(),suf.end()); int cur=stoi(suf,nullptr,2);//将字符串suf中的数看做是二进制编码，转成10进制整数。 if(s[high]==\u0026#39;0\u0026#39;) return high+1+cnt; else if(cur\u0026lt;=k) return high+1+cnt; else return high+cnt; } }; 【DP】卖木头块 题目 给你两个整数 m 和 n ，分别表示一块矩形木块的高和宽。同时给你一个二维整数数组 prices ，其中 prices[i] = [hi, wi, pricei] 表示你可以以 pricei 元的价格卖一块高为 hi 宽为 wi 的矩形木块。\n每一次操作中，你必须按下述方式之一执行切割操作，以得到两块更小的矩形木块：\n沿垂直方向按高度 完全 切割木块，或 沿水平方向按宽度 完全 切割木块 在将一块木块切成若干小木块后，你可以根据 prices 卖木块。你可以卖多块同样尺寸的木块。你不需要将所有小木块都卖出去。你 不能 旋转切好后木块的高和宽。\n请你返回切割一块大小为 m x n 的木块后，能得到的 最多 钱数。\n注意你可以切割木块任意次。\n示例 1：\n1 2 3 4 5 6 7 8 输入：m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]] 输出：19 解释：上图展示了一个可行的方案。包括： - 2 块 2 x 2 的小木块，售出 2 * 7 = 14 元。 - 1 块 2 x 1 的小木块，售出 1 * 3 = 3 元。 - 1 块 1 x 4 的小木块，售出 1 * 2 = 2 元。 总共售出 14 + 3 + 2 = 19 元。 19 元是最多能得到的钱数。 示例 2：\n1 2 3 4 5 6 7 8 输入：m = 4, n = 6, prices = [[3,2,10],[1,4,2],[4,1,3]] 输出：32 解释：上图展示了一个可行的方案。包括： - 3 块 3 x 2 的小木块，售出 3 * 10 = 30 元。 - 1 块 1 x 4 的小木块，售出 1 * 2 = 2 元。 总共售出 30 + 2 = 32 元。 32 元是最多能得到的钱数。 注意我们不能旋转 1 x 4 的木块来得到 4 x 1 的木块。 提示：\n1 \u0026lt;= m, n \u0026lt;= 200 1 \u0026lt;= prices.length \u0026lt;= 2 * 10^4 prices[i].length == 3 1 \u0026lt;= hi \u0026lt;= m 1 \u0026lt;= wi \u0026lt;= n 1 \u0026lt;= pricei \u0026lt;= 10^6 所有 (hi, wi) 互不相同 。 解题思路 一眼DP，可惜没时间做\n看清题意，切割操作有两种，要么沿水平方向切割，要么沿竖直方向切割\n二维vector初始化比起用memset初始化费时地多\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: long long sellingWood(int n, int m, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; prices) { // 记录直接卖的收益 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; A; A.resize(n + 1, vector\u0026lt;int\u0026gt;(m + 1)); for (auto \u0026amp;vec : prices) A[vec[0]][vec[1]] = vec[2]; vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; f; f.resize(n + 1, vector\u0026lt;long long\u0026gt;(m + 1)); for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) { // 直接卖 f[i][j] = A[i][j]; // 沿水平方向分割 for (int k = 1; k \u0026lt; i; k++) f[i][j] = max(f[i][j], f[k][j] + f[i - k][j]); // 沿垂直方向分割 for (int k = 1; k \u0026lt; j; k++) f[i][j] = max(f[i][j], f[i][k] + f[i][j - k]); } return f[n][m]; } }; // 作者：TsReaper // 链接：https://leetcode.cn/circle/discuss/qovhgl/view/OGIKuU/ // 来源：力扣（LeetCode） // 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 记忆化搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #define ll long long class Solution { public: long long sellingWood(int m, int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; prices) { long long dp[202][202],single[202][202]; memset(dp,-1,sizeof(dp)); memset(single,0,sizeof(single)); //dp[i][j] 高为i，宽为j的矩形木块 切割后能得到的最多钱数 for(auto \u0026amp;sub : prices){ single[sub[0]][sub[1]] = sub[2]; } function\u0026lt;ll(int,int)\u0026gt; dfs=[\u0026amp;](int x, int y){ if(dp[x][y]!=-1) return dp[x][y]; if(!x||!y) return 1ll*0; ll res = single[x][y]; for(int i=1;i\u0026lt;x;i++){ res=max(res,dfs(i,y)+dfs(x-i,y)); } for(int j=1;j\u0026lt;y;j++){ res=max(res,dfs(x,j)+dfs(x,y-j)); } dp[x][y]=res; return dp[x][y]; }; dfs(m,n); return dp[m][n]; } }; ","date":"2022-06-25T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC298%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220625_hu13741186177240308962.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC298%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第298场周赛总结"},{"content":"\n【模拟】计算应缴税款总额 题目 给你一个下标从 0 开始的二维整数数组 brackets ，其中 brackets[i] = [upperi, percenti] ，表示第 i 个税级的上限是 upperi ，征收的税率为 percenti 。税级按上限 从低到高排序（在满足 0 \u0026lt; i \u0026lt; brackets.length 的前提下，upperi-1 \u0026lt; upperi）。\n税款计算方式如下：\n不超过 upper0 的收入按税率 percent0 缴纳 接着 upper1 - upper0 的部分按税率 percent1 缴纳 然后 upper2 - upper1 的部分按税率 percent2 缴纳 以此类推 给你一个整数 income 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 10-5 的结果将被视作正确答案。\n示例 1：\n1 2 3 4 5 6 7 输入：brackets = [[3,50],[7,10],[12,25]], income = 10 输出：2.65000 解释： 前 $3 的税率为 50% 。需要支付税款 $3 * 50% = $1.50 。 接下来 $7 - $3 = $4 的税率为 10% 。需要支付税款 $4 * 10% = $0.40 。 最后 $10 - $7 = $3 的税率为 25% 。需要支付税款 $3 * 25% = $0.75 。 需要支付的税款总计 $1.50 + $0.40 + $0.75 = $2.65 。 示例 2：\n1 2 3 4 5 6 输入：brackets = [[1,0],[4,25],[5,50]], income = 2 输出：0.25000 解释： 前 $1 的税率为 0% 。需要支付税款 $1 * 0% = $0 。 剩下 $1 的税率为 25% 。需要支付税款 $1 * 25% = $0.25 。 需要支付的税款总计 $0 + $0.25 = $0.25 。 示例 3：\n1 2 3 4 输入：brackets = [[2,50]], income = 0 输出：0.00000 解释： 没有收入，无需纳税，需要支付的税款总计 $0 。 提示：\n1 \u0026lt;= brackets.length \u0026lt;= 100 1 \u0026lt;= upperi \u0026lt;= 1000 0 \u0026lt;= percenti \u0026lt;= 100 0 \u0026lt;= income \u0026lt;= 1000 upperi 按递增顺序排列 upperi 中的所有值 互不相同 最后一个税级的上限大于等于 income 解题思路 简单模拟。\nWA了一发，在income\u0026lt;=b[0][0]时就可以直接返回了，否则的话后面要判断rst是否大于0\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: double calculateTax(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; brackets, int income) { int n = brackets.size(); double res = 0.0; if(income\u0026lt;=brackets[0][0]) res = 1.00*income*brackets[0][1]/100; else res = brackets[0][0]*1.00*brackets[0][1]/100; for(int i=1;i\u0026lt;n;i++){ if(income\u0026gt;=brackets[i][0]){ int rst = brackets[i][0]-brackets[i-1][0]; res += 1.00*rst*brackets[i][1]/100; }else{ int rst = income-brackets[i-1][0]; if(rst\u0026gt;0) res += 1.00*rst*brackets[i][1]/100; break; } } return res; } }; 【动态规划】网格中的最小路径代价 题目 给你一个下标从 0 开始的整数矩阵 grid ，矩阵大小为 m x n ，由从 0 到 m * n - 1 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 下一行 的任何其他单元格。如果你位于单元格 (x, y) ，且满足 x \u0026lt; m - 1 ，你可以移动到 (x + 1, 0), (x + 1, 1), \u0026hellip;, (x + 1, n - 1) 中的任何一个单元格。注意： 在最后一行中的单元格不能触发移动。\n每次可能的移动都需要付出对应的代价，代价用一个下标从 0 开始的二维数组 moveCost 表示，该数组大小为 (m * n) x n ，其中 moveCost[i][j] 是从值为 i 的单元格移动到下一行第 j 列单元格的代价。从 grid 最后一行的单元格移动的代价可以忽略。\ngrid 一条路径的代价是：所有路径经过的单元格的 值之和 加上 所有移动的 代价之和 。从 第一行 任意单元格出发，返回到达 最后一行 任意单元格的最小路径代价*。*\n示例 1：\n1 2 3 4 5 6 7 输入：grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]] 输出：17 解释：最小代价的路径是 5 -\u0026gt; 0 -\u0026gt; 1 。 - 路径途经单元格值之和 5 + 0 + 1 = 6 。 - 从 5 移动到 0 的代价为 3 。 - 从 0 移动到 1 的代价为 8 。 路径总代价为 6 + 3 + 8 = 17 。 示例 2：\n1 2 3 4 5 6 7 输入：grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]] 输出：6 解释： 最小代价的路径是 2 -\u0026gt; 3 。 - 路径途经单元格值之和 2 + 3 = 5 。 - 从 2 移动到 3 的代价为 1 。 路径总代价为 5 + 1 = 6 。 提示：\nm == grid.length n == grid[i].length 2 \u0026lt;= m, n \u0026lt;= 50 grid 由从 0 到 m * n - 1 的不同整数组成 moveCost.length == m * n moveCost[i].length == n 1 \u0026lt;= moveCost[i][j] \u0026lt;= 100 解题思路 简单路径规划类DP\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const int INF = 0x3f3f3f3f; class Solution { public: int minPathCost(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; moveCost) { int n = grid.size(), m = grid[0].size(); int res = INF; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n,vector\u0026lt;int\u0026gt;(m,INF)); for(int j=0;j\u0026lt;m;j++){ dp[0][j] = grid[0][j]; } for(int i=1;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ for(int k=0;k\u0026lt;m;k++){ dp[i][j]=min(dp[i][j], grid[i][j]+dp[i-1][k]+moveCost[grid[i-1][k]][j]); } } } for(int j=0;j\u0026lt;m;j++){ res = min(res,dp[n-1][j]); } return res; } }; 【DFS/状压DP】公平分发饼干 题目 给你一个整数数组 cookies ，其中 cookies[i] 表示在第 i 个零食包中的饼干数量。另给你一个整数 k 表示等待分发零食包的孩子数量，所有 零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。\n分发的 不公平程度 定义为单个孩子在分发过程中能够获得饼干的最大总数。\n返回所有分发的最小不公平程度。\n示例 1：\n1 2 3 4 5 6 7 输入：cookies = [8,15,10,20,8], k = 2 输出：31 解释：一种最优方案是 [8,15,8] 和 [10,20] 。 - 第 1 个孩子分到 [8,15,8] ，总计 8 + 15 + 8 = 31 块饼干。 - 第 2 个孩子分到 [10,20] ，总计 10 + 20 = 30 块饼干。 分发的不公平程度为 max(31,30) = 31 。 可以证明不存在不公平程度小于 31 的分发方案。 示例 2：\n1 2 3 4 5 6 7 8 输入：cookies = [6,1,3,2,2,4,1,2], k = 3 输出：7 解释：一种最优方案是 [6,1]、[3,2,2] 和 [4,1,2] 。 - 第 1 个孩子分到 [6,1] ，总计 6 + 1 = 7 块饼干。 - 第 2 个孩子分到 [3,2,2] ，总计 3 + 2 + 2 = 7 块饼干。 - 第 3 个孩子分到 [4,1,2] ，总计 4 + 1 + 2 = 7 块饼干。 分发的不公平程度为 max(7,7,7) = 7 。 可以证明不存在不公平程度小于 7 的分发方案。 提示：\n2 \u0026lt;= cookies.length \u0026lt;= 8 1 \u0026lt;= cookies[i] \u0026lt;= 10^5 2 \u0026lt;= k \u0026lt;= cookies.length 解题思路 看数据规模，n最大值为8，考虑DFS，一遍过了没优化\n也想过可以用状压DP，赛时不敢用不熟练的状压DP\n代码 DFS 1.0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const int INF = 0x3f3f3f3f; class Solution { public: vector\u0026lt;int\u0026gt; num; vector\u0026lt;int\u0026gt; cook; int n,res,k; void dfs(int x){ if(x==n){ int maxv=0; for(auto \u0026amp;p: num){ maxv = max(maxv,p); } res = min(res,maxv); return; } for(int i=0;i\u0026lt;k;i++){ num[i] += cook[x]; dfs(x+1); num[i] -= cook[x]; } } int distributeCookies(vector\u0026lt;int\u0026gt;\u0026amp; cookies, int k) { n = cookies.size(); cook = cookies; res = INF; this-\u0026gt;k=k; num.assign(k,0); dfs(0); return res; } }; DFS 2.0 可以考虑记录当前最大值进行剪枝。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 const int INF = 0x3f3f3f3f; class Solution { public: vector\u0026lt;int\u0026gt; num; vector\u0026lt;int\u0026gt; cook; int n,res,k; void dfs(int x, int curmax){ if(curmax\u0026gt;=res) return; if(x==n){ int maxv=0; for(auto \u0026amp;p: num){ maxv = max(maxv,p); } res = min(res,maxv); return; } int tmpmax=curmax; for(int i=0;i\u0026lt;k;i++){ num[i] += cook[x]; curmax = max(curmax, cook[x]); dfs(x+1,curmax); num[i] -= cook[x]; curmax = tmpmax; } } int distributeCookies(vector\u0026lt;int\u0026gt;\u0026amp; cookies, int k) { n = cookies.size(); cook = cookies; res = INF; this-\u0026gt;k=k; num.assign(k,0); dfs(0,0); return res; } }; 状压DP 主要是考虑第i个孩子状态为state时，枚举前i-1个孩子的子状态j（state的子集）），补集为state^j\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: int distributeCookies(vector\u0026lt;int\u0026gt;\u0026amp; cookies, int k) { int n = cookies.size(); vector\u0026lt;int\u0026gt; num(1\u0026lt;\u0026lt;n, 0);//num[state] 饼干状态为state时的饼干数量 for(int state=0;state\u0026lt;(1\u0026lt;\u0026lt;n);state++){ int cur=0; for(int i=0;i\u0026lt;n;i++){ if((state\u0026gt;\u0026gt;i)\u0026amp;1) cur+=cookies[i]; } num[state] = cur; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(1\u0026lt;\u0026lt;n, 0)); //dp[i][state] 前i个孩子，选择的饼干状态为state时 单个孩子最大饼干数量的最小值 for(int state=0;state\u0026lt;(1\u0026lt;\u0026lt;n);state++){ dp[0][state] = num[state]; } for(int i=1;i\u0026lt;k;i++){ for(int state=0;state\u0026lt;(1\u0026lt;\u0026lt;n);state++){ dp[i][state] = INT_MAX; for(int j=state;j;j=(j-1)\u0026amp;state){//枚举state的子集 dp[i][state]=min(dp[i][state], max(dp[i-1][j],num[state^j])); } } } return dp[k-1][(1\u0026lt;\u0026lt;n)-1]; } }; 状压DP 空间优化 类似于01背包，将第二维逆序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int distributeCookies(vector\u0026lt;int\u0026gt;\u0026amp; cookies, int k) { int n = cookies.size(); vector\u0026lt;int\u0026gt; num(1\u0026lt;\u0026lt;n, 0);//num[state] 饼干状态为state时的饼干数量 for(int state=0;state\u0026lt;(1\u0026lt;\u0026lt;n);state++){ int cur=0; for(int i=0;i\u0026lt;n;i++){ if((state\u0026gt;\u0026gt;i)\u0026amp;1) cur+=cookies[i]; } num[state] = cur; } vector\u0026lt;int\u0026gt; dp(1\u0026lt;\u0026lt;n); //dp[i][state] 前i个孩子，选择的饼干状态为state时 单个孩子最大饼干数量的最小值 dp = num; for(int i=1;i\u0026lt;k;i++){ for(int state=(1\u0026lt;\u0026lt;n)-1;state\u0026gt;=0;state--){ for(int j=state;j;j=(j-1)\u0026amp;state){//枚举state的子集 dp[state]=min(dp[state], max(dp[j],num[state^j])); } } } return dp[(1\u0026lt;\u0026lt;n)-1]; } }; 【枚举+计数】公司命名 题目 给你一个字符串数组 ideas 表示在公司命名过程中使用的名字列表。公司命名流程如下：\n从 ideas 中选择 2 个 不同 名字，称为 ideaA 和 ideaB 。 交换 ideaA 和 ideaB 的首字母。 如果得到的两个新名字 都 不在 ideas 中，那么 ideaA ideaB（串联 ideaA 和 ideaB ，中间用一个空格分隔）是一个有效的公司名字。 否则，不是一个有效的名字。 返回 不同 且有效的公司名字的数目。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 输入：ideas = [\u0026#34;coffee\u0026#34;,\u0026#34;donuts\u0026#34;,\u0026#34;time\u0026#34;,\u0026#34;toffee\u0026#34;] 输出：6 解释：下面列出一些有效的选择方案： - (\u0026#34;coffee\u0026#34;, \u0026#34;donuts\u0026#34;)：对应的公司名字是 \u0026#34;doffee conuts\u0026#34; 。 - (\u0026#34;donuts\u0026#34;, \u0026#34;coffee\u0026#34;)：对应的公司名字是 \u0026#34;conuts doffee\u0026#34; 。 - (\u0026#34;donuts\u0026#34;, \u0026#34;time\u0026#34;)：对应的公司名字是 \u0026#34;tonuts dime\u0026#34; 。 - (\u0026#34;donuts\u0026#34;, \u0026#34;toffee\u0026#34;)：对应的公司名字是 \u0026#34;tonuts doffee\u0026#34; 。 - (\u0026#34;time\u0026#34;, \u0026#34;donuts\u0026#34;)：对应的公司名字是 \u0026#34;dime tonuts\u0026#34; 。 - (\u0026#34;toffee\u0026#34;, \u0026#34;donuts\u0026#34;)：对应的公司名字是 \u0026#34;doffee tonuts\u0026#34; 。 因此，总共有 6 个不同的公司名字。 下面列出一些无效的选择方案： - (\u0026#34;coffee\u0026#34;, \u0026#34;time\u0026#34;)：在原数组中存在交换后形成的名字 \u0026#34;toffee\u0026#34; 。 - (\u0026#34;time\u0026#34;, \u0026#34;toffee\u0026#34;)：在原数组中存在交换后形成的两个名字。 - (\u0026#34;coffee\u0026#34;, \u0026#34;toffee\u0026#34;)：在原数组中存在交换后形成的两个名字。 示例 2：\n1 2 3 输入：ideas = [\u0026#34;lack\u0026#34;,\u0026#34;back\u0026#34;] 输出：0 解释：不存在有效的选择方案。因此，返回 0 。 提示：\n2 \u0026lt;= ideas.length \u0026lt;= 5 * 10^4 1 \u0026lt;= ideas[i].length \u0026lt;= 10 ideas[i] 由小写英文字母组成 ideas 中的所有字符串 互不相同 解题思路 赛时想到了要按首字母分组\n同时记录每个组后缀相同情况\n但赛时还是紧张了，只想到了记录是否有相同后缀，没有去记录有相同后缀的个数！可惜\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public: long long distinctNames(vector\u0026lt;string\u0026gt;\u0026amp; ideas) { int n = ideas.size(); vector\u0026lt;unordered_set\u0026lt;string\u0026gt;\u0026gt; tab(26); for(auto \u0026amp;str: ideas){ int type=str[0]-\u0026#39;a\u0026#39;; string suf(str.begin()+1,str.end()); tab[type].insert(suf); } long long res = 0; int same[26][26]; memset(same,0,sizeof(same)); for(int i=0;i\u0026lt;26;i++){ if(tab[i].empty()) continue; for(int j=0;j\u0026lt;26;j++){ if(i==j||tab[j].empty()) continue; same[i][j]=0;//以i开头和以j开头的字符串相同后缀的个数 for(auto \u0026amp;str: tab[i]){ if(tab[j].count(str)){ same[i][j]++; } } } } for(int i=0;i\u0026lt;26;i++){ if(tab[i].empty()) continue; for(int j=0;j\u0026lt;26;j++){ if(i==j||tab[j].empty()) continue; // for(auto \u0026amp;str: tab[i]){ // if(!tab[j].count(str)){ // res += tab[j].size()-same[i][j]; // } // } res+=tab[i].size()*tab[j].size()-same[i][j]*tab[j].size()-same[j][i]*tab[i].size()+same[i][j]*same[j][i];//容斥原理 } } return res; } }; ","date":"2022-06-24T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC297%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220624_hu17005853508236671447.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC297%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第297场周赛总结"},{"content":"\n【模拟】强密码检验器 II 题目 如果一个密码满足以下所有条件，我们称它是一个 强 密码：\n它有至少 8 个字符。 至少包含 一个小写英文 字母。 至少包含 一个大写英文 字母。 至少包含 一个数字 。 至少包含 一个特殊字符 。特殊字符为：\u0026quot;!@#$%^\u0026amp;*()-+\u0026quot; 中的一个。 它 不 包含 2 个连续相同的字符（比方说 \u0026quot;aab\u0026quot; 不符合该条件，但是 \u0026quot;aba\u0026quot; 符合该条件）。 给你一个字符串 password ，如果它是一个 强 密码，返回 true，否则返回 false 。\n示例 1：\n1 2 3 输入：password = \u0026#34;IloveLe3tcode!\u0026#34; 输出：true 解释：密码满足所有的要求，所以我们返回 true 。 示例 2：\n1 2 3 输入：password = \u0026#34;Me+You--IsMyDream\u0026#34; 输出：false 解释：密码不包含数字，且包含 2 个连续相同的字符。所以我们返回 false 。 示例 3：\n1 2 3 输入：password = \u0026#34;1aB!\u0026#34; 输出：false 解释：密码不符合长度要求。所以我们返回 false 。 提示：\n1 \u0026lt;= password.length \u0026lt;= 100 password 包含字母，数字和 \u0026quot;!@#$%^\u0026amp;*()-+\u0026quot; 这些特殊字符。 解题思路 按题意模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: bool issp(char ch){ //!@#$%^\u0026amp;*()-+ if(ch==\u0026#39;!\u0026#39;||ch==\u0026#39;@\u0026#39;||ch==\u0026#39;#\u0026#39;||ch==\u0026#39;$\u0026#39;||ch==\u0026#39;%\u0026#39;||ch==\u0026#39;^\u0026#39;||ch==\u0026#39;\u0026amp;\u0026#39;||ch==\u0026#39;*\u0026#39;||ch==\u0026#39;(\u0026#39;||ch==\u0026#39;)\u0026#39;||ch==\u0026#39;-\u0026#39;||ch==\u0026#39;+\u0026#39;) return true; return false; } int type(char ch){ if(issp(ch)) return 4; else if(ch\u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;z\u0026#39;) return 1; else if(ch\u0026gt;=\u0026#39;A\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;Z\u0026#39;) return 2; else if(ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;) return 3; return 0; } bool strongPasswordCheckerII(string password) { int n = password.size(); if(n\u0026lt;8) return false; vector\u0026lt;int\u0026gt; t(5,0); bool flag=true; t[type(password[0])]++; for(int i=1;i\u0026lt;n;i++){ t[type(password[i])]++; if(password[i]==password[i-1]){ flag = false; break; } } for(int i=1;i\u0026lt;=4;i++){ if(t[i]\u0026lt;1) flag=false; } return flag; } }; 偷学代码 优雅\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: bool strongPasswordCheckerII(string s) { if (s.size() \u0026lt; 8) return false; for (int i = 1; i \u0026lt; s.size(); i += 1) if (s[i] == s[i - 1]) return false; int ans = 0; string t = \u0026#34;!@#$%^\u0026amp;*()-+\u0026#34;; for (char c : s) { if (isdigit(c)) ans |= 1; if (islower(c)) ans |= 2; if (isupper(c)) ans |= 4; if (count(t.begin(), t.end(), c)) ans |= 8; } return ans == 15; } }; 【排序+二分】咒语和药水的成功对数 题目 给你两个正整数数组 spells 和 potions ，长度分别为 n 和 m ，其中 spells[i] 表示第 i 个咒语的能量强度，potions[j] 表示第 j 瓶药水的能量强度。\n同时给你一个整数 success 。一个咒语和药水的能量强度 相乘 如果 大于等于 success ，那么它们视为一对 成功 的组合。\n请你返回一个长度为 n 的整数数组 pairs，其中 pairs[i] 是能跟第 i 个咒语成功组合的 药水 数目。\n示例 1：\n1 2 3 4 5 6 7 输入：spells = [5,1,3], potions = [1,2,3,4,5], success = 7 输出：[4,0,3] 解释： - 第 0 个咒语：5 * [1,2,3,4,5] = [5,10,15,20,25] 。总共 4 个成功组合。 - 第 1 个咒语：1 * [1,2,3,4,5] = [1,2,3,4,5] 。总共 0 个成功组合。 - 第 2 个咒语：3 * [1,2,3,4,5] = [3,6,9,12,15] 。总共 3 个成功组合。 所以返回 [4,0,3] 。 示例 2：\n1 2 3 4 5 6 7 输入：spells = [3,1,2], potions = [8,5,8], success = 16 输出：[2,0,2] 解释： - 第 0 个咒语：3 * [8,5,8] = [24,15,24] 。总共 2 个成功组合。 - 第 1 个咒语：1 * [8,5,8] = [8,5,8] 。总共 0 个成功组合。 - 第 2 个咒语：2 * [8,5,8] = [16,10,16] 。总共 2 个成功组合。 所以返回 [2,0,2] 。 提示：\nn == spells.length m == potions.length 1 \u0026lt;= n, m \u0026lt;= 10^5 1 \u0026lt;= spells[i], potions[i] \u0026lt;= 10^5 1 \u0026lt;= success \u0026lt;= 10^10 解题思路 将药水从小到到大排序，乘积都是整数，且具有单调性，所以可以二分\n$x\\times y \\ge success$等价于$y\\ge \\lceil \\frac{success}{x} \\rceil$，也等价于$y\u0026gt;\\lfloor \\frac{success-1}{x}\\rfloor$，或者是$y\\ge \\lfloor \\frac{success+x-1}{x} \\rfloor$\n代码 Version 1.0 比赛时WA了一发，没有将target转为long long\n后面将p数组也转为了long long ，其实没必要\n按照了是否能整除来判断是用lower_bound还是upper_bound\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: vector\u0026lt;int\u0026gt; successfulPairs(vector\u0026lt;int\u0026gt;\u0026amp; spells, vector\u0026lt;int\u0026gt;\u0026amp; potions, long long success) { int n = spells.size(), m = potions.size(); vector\u0026lt;long long\u0026gt; p(potions.begin(),potions.end()); sort(p.begin(),p.end()); vector\u0026lt;int\u0026gt; res(n,0); for(int i=0;i\u0026lt;n;i++){ if(1ll*spells[i]\u0026gt;=success){ res[i] = m; continue; } long long target = success/spells[i]; int idx=-1; if(success%(spells[i]*1ll)==0) idx = lower_bound(p.begin(),p.end(),target)-p.begin(); else idx = upper_bound(p.begin(),p.end(),target)-p.begin(); res[i] = m-idx; } return res; } }; Version 2.0 $y\u0026gt;\\lfloor \\frac{success-1}{x}\\rfloor$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: vector\u0026lt;int\u0026gt; successfulPairs(vector\u0026lt;int\u0026gt;\u0026amp; spells, vector\u0026lt;int\u0026gt;\u0026amp; potions, long long success) { int n = spells.size(), m = potions.size(); vector\u0026lt;long long\u0026gt; p(potions.begin(),potions.end()); sort(p.begin(),p.end()); vector\u0026lt;int\u0026gt; res(n,0); for(int i=0;i\u0026lt;n;i++){ if(1ll*spells[i]\u0026gt;=success){ res[i] = m; continue; } long long target = (success-1)/spells[i]; int idx=-1; idx = upper_bound(p.begin(),p.end(),target)-p.begin(); res[i] = m-idx; } return res; } }; Version 3.0 $y\\ge \\lfloor \\frac{success+x-1}{x} \\rfloor$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: vector\u0026lt;int\u0026gt; successfulPairs(vector\u0026lt;int\u0026gt;\u0026amp; spells, vector\u0026lt;int\u0026gt;\u0026amp; potions, long long success) { int n = spells.size(), m = potions.size(); sort(potions.begin(),potions.end()); vector\u0026lt;int\u0026gt; res(n,0); for(int i=0;i\u0026lt;n;i++){ if(spells[i]\u0026gt;=success){ res[i] = m; continue; } long long target = (success+spells[i]-1)/spells[i]; int idx=-1; idx = lower_bound(potions.begin(),potions.end(),target)-potions.begin(); res[i] = m-idx; } return res; } }; 【枚举】替换字符后匹配 题目 给你两个字符串 s 和 sub 。同时给你一个二维字符数组 mappings ，其中 mappings[i] = [oldi, newi] 表示你可以将 sub 中任意数目的 oldi 字符替换为 newi 。sub 中每个字符 不能 被替换超过一次。\n如果使用 mappings 替换 0 个或者若干个字符，可以将 sub 变成 s 的一个子字符串，请你返回 true，否则返回 false 。\n一个 子字符串 是字符串中连续非空的字符序列。\n示例 1：\n1 2 3 4 输入：s = \u0026#34;fool3e7bar\u0026#34;, sub = \u0026#34;leet\u0026#34;, mappings = [[\u0026#34;e\u0026#34;,\u0026#34;3\u0026#34;],[\u0026#34;t\u0026#34;,\u0026#34;7\u0026#34;],[\u0026#34;t\u0026#34;,\u0026#34;8\u0026#34;]] 输出：true 解释：将 sub 中第一个 \u0026#39;e\u0026#39; 用 \u0026#39;3\u0026#39; 替换，将 \u0026#39;t\u0026#39; 用 \u0026#39;7\u0026#39; 替换。 现在 sub = \u0026#34;l3e7\u0026#34; ，它是 s 的子字符串，所以我们返回 true 。 示例 2：\n1 2 3 4 输入：s = \u0026#34;fooleetbar\u0026#34;, sub = \u0026#34;f00l\u0026#34;, mappings = [[\u0026#34;o\u0026#34;,\u0026#34;0\u0026#34;]] 输出：false 解释：字符串 \u0026#34;f00l\u0026#34; 不是 s 的子串且没有可以进行的修改。 注意我们不能用 \u0026#39;o\u0026#39; 替换 \u0026#39;0\u0026#39; 。 示例 3：\n1 2 3 4 输入：s = \u0026#34;Fool33tbaR\u0026#34;, sub = \u0026#34;leetd\u0026#34;, mappings = [[\u0026#34;e\u0026#34;,\u0026#34;3\u0026#34;],[\u0026#34;t\u0026#34;,\u0026#34;7\u0026#34;],[\u0026#34;t\u0026#34;,\u0026#34;8\u0026#34;],[\u0026#34;d\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;p\u0026#34;,\u0026#34;b\u0026#34;]] 输出：true 解释：将 sub 里第一个和第二个 \u0026#39;e\u0026#39; 用 \u0026#39;3\u0026#39; 替换，用 \u0026#39;b\u0026#39; 替换 sub 里的 \u0026#39;d\u0026#39; 。 得到 sub = \u0026#34;l33tb\u0026#34; ，它是 s 的子字符串，所以我们返回 true 。 提示：\n1 \u0026lt;= sub.length \u0026lt;= s.length \u0026lt;= 5000 0 \u0026lt;= mappings.length \u0026lt;= 1000 mappings[i].length == 2 oldi != newi s 和 sub 只包含大写和小写英文字母和数字。 oldi 和 newi 是大写、小写字母或者是个数字。 解题思路 离谱啊，枚举就行了\n枚举s[i..i+m-1] = sub[0..m-1]相匹配，字符相同就不用换，不同就在mappings里找能否替换，利用哈希表在O(1)时间内查询\n\u0026lsquo;0\u0026rsquo;的ascii码是48\n\u0026lsquo;A\u0026rsquo;的ascii码是65\n\u0026lsquo;a\u0026rsquo;的ascii码是97\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: bool matchReplacement(string s, string sub, vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; mappings) { unordered_set\u0026lt;char\u0026gt; tab[100]; for(auto \u0026amp;x: mappings){ tab[x[0]-\u0026#39;0\u0026#39;].insert(x[1]); } int n=s.size(),m=sub.size(); for(int i=0;i+m-1\u0026lt;n;i++){ //s[i..i+m-1] = sub[0..m-1] bool flag = true; for(int j=0;j\u0026lt;m\u0026amp;\u0026amp;flag;j++){ if(s[i+j]==sub[j]) continue; if(tab[sub[j]-\u0026#39;0\u0026#39;].count(s[i+j])) continue; flag = false; } if(flag) return true; } return 0; } }; 【前缀和+二分/滑动窗口】统计得分小于 K 的子数组数目 题目 一个数字的 分数 定义为数组之和 乘以 数组的长度。\n比方说，[1, 2, 3, 4, 5] 的分数为 (1 + 2 + 3 + 4 + 5) * 5 = 75 。 给你一个正整数数组 nums 和一个整数 k ，请你返回 nums 中分数 严格小于 k 的 非空整数子数组数目。\n子数组 是数组中的一个连续元素序列。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 输入：nums = [2,1,4,3,5], k = 10 输出：6 解释： 有 6 个子数组的分数小于 10 ： - [2] 分数为 2 * 1 = 2 。 - [1] 分数为 1 * 1 = 1 。 - [4] 分数为 4 * 1 = 4 。 - [3] 分数为 3 * 1 = 3 。 - [5] 分数为 5 * 1 = 5 。 - [2,1] 分数为 (2 + 1) * 2 = 6 。 注意，子数组 [1,4] 和 [4,3,5] 不符合要求，因为它们的分数分别为 10 和 36，但我们要求子数组的分数严格小于 10 。 示例 2：\n1 2 3 4 5 6 输入：nums = [1,1,1], k = 5 输出：5 解释： 除了 [1,1,1] 以外每个子数组分数都小于 5 。 [1,1,1] 分数为 (1 + 1 + 1) * 3 = 9 ，大于 5 。 所以总共有 5 个子数组得分小于 5 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^5 1 \u0026lt;= k \u0026lt;= 10^15 解题思路 比赛时是用二分做的\n考虑[l,r]区间内的分数，利用前缀和可在$O(1)$时间内计算：(sum[r]-sum[l-1])*(r-l+1)\n考虑前i个数（以1开始计数），且末尾元素是nums[i]的子数组范围，它的子数组范围为：[1..i], [2..i], [3..i],...,[i..i]，由于元素值都是大于0的，可以发现上述子数组的分数是单调递增的。\n所以可以固定右端点，再二分查找出分数严格小于k的最小左端点，统计进总数即可。这样时间复杂度是$O(nlogn)$\n注意数据类型。\nWA了两发是数组起始0和1搞混了\n代码 二分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #define ll long long class Solution { public: long long countSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums, long long k) { int n = nums.size(); vector\u0026lt;ll\u0026gt; sum(n+1,0); for(int i=1;i\u0026lt;=n;i++) sum[i]=sum[i-1]+nums[i-1]; ll res = 0; for(int i=1;i\u0026lt;=n;i++){//枚举右端点为i if(nums[i-1]\u0026gt;=k) continue; int l=1,r=i;//左端点的范围为[1,i] while(l\u0026lt;=r){//左闭右闭 int mid=(l+r)\u0026gt;\u0026gt;1; long long cur = (sum[i]-sum[mid-1])*(i-mid+1); if(cur\u0026gt;=k) l=mid+1; else r=mid-1;//最后要小于k，满足条件推出循环后mid=r+1，故左端点为r+1 } //r+1 [r+1,i]中所有以nums[i]结尾的子数组的分数都严格小于k，共有i-(r+1)+1个 res += i-(r+1)+1; } return res; } }; 偷学代码 滑动窗口 滑动窗口考量区间[l,r]是否满足题中要求:\n不满足就右移l 满足的话,[l+1,r],[l+2,r]\u0026hellip;等区间也满足,计数增加 ++r - l 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public long countSubarrays(int[] nums, long k) { int n = nums.length; long res = 0; long[] sum = new long[n + 1]; for (int i = 0; i \u0026lt; n; i++) { sum[i + 1] = sum[i] + nums[i];//前缀和 } int l = 0, r = 0; while (r \u0026lt; n) { while (l \u0026lt;= r \u0026amp;\u0026amp; (r - l + 1) * (sum[r + 1] - sum[l]) \u0026gt;= k) l++;//右移l直到满足 res += ++r - l;//计数并右移r } return res; } } ","date":"2022-06-14T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC80%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220614_hu10226028110340242760.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC80%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第80场双周赛总结"},{"content":"\n【模拟】极大极小游戏 题目 给你一个下标从 0 开始的整数数组 nums ，其长度是 2 的幂。\n对 nums 执行下述算法：\n设 n 等于 nums 的长度，如果 n == 1 ，终止 算法过程。否则，创建 一个新的整数数组 newNums ，新数组长度为 n / 2 ，下标从 0 开始。 对于满足 0 \u0026lt;= i \u0026lt; n / 2 的每个 偶数 下标 i ，将 newNums[i] 赋值 为 min(nums[2 * i], nums[2 * i + 1]) 。 对于满足 0 \u0026lt;= i \u0026lt; n / 2 的每个 奇数 下标 i ，将 newNums[i] 赋值 为 max(nums[2 * i], nums[2 * i + 1]) 。 用 newNums 替换 nums 。 从步骤 1 开始 重复 整个过程。 执行算法后，返回 nums 中剩下的那个数字。\n示例 1：\n1 2 3 4 5 6 7 输入：nums = [1,3,5,2,4,8,2,2] 输出：1 解释：重复执行算法会得到下述数组。 第一轮：nums = [1,5,4,2] 第二轮：nums = [1,4] 第三轮：nums = [1] 1 是最后剩下的那个数字，返回 1 。 示例 2：\n1 2 3 输入：nums = [3] 输出：3 解释：3 就是最后剩下的数字，返回 3 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 1024 1 \u0026lt;= nums[i] \u0026lt;= 109 nums.length 是 2 的幂 解题思路 按题意模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int minMaxGame(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); while(n\u0026gt;1){ for(int i=0;i\u0026lt;n/2;i++){ if(i%2==0) nums[i]=min(nums[i*2],nums[i*2+1]); else nums[i]=max(nums[i*2],nums[i*2+1]); } n=n/2; } return nums[0]; } }; 【排序+贪心】划分数组使最大差为 K 题目 给你一个整数数组 nums 和一个整数 k 。你可以将 nums 划分成一个或多个 子序列 ，使 nums 中的每个元素都 恰好 出现在一个子序列中。\n在满足每个子序列中最大值和最小值之间的差值最多为 k 的前提下，返回需要划分的 最少 子序列数目。\n子序列 本质是一个序列，可以通过删除另一个序列中的某些元素（或者不删除）但不改变剩下元素的顺序得到。\n示例 1：\n1 2 3 4 5 6 7 输入：nums = [3,6,1,2,5], k = 2 输出：2 解释： 可以将 nums 划分为两个子序列 [3,1,2] 和 [6,5] 。 第一个子序列中最大值和最小值的差值是 3 - 1 = 2 。 第二个子序列中最大值和最小值的差值是 6 - 5 = 1 。 由于创建了两个子序列，返回 2 。可以证明需要划分的最少子序列数目就是 2 。 示例 2：\n1 2 3 4 5 6 7 输入：nums = [1,2,3], k = 1 输出：2 解释： 可以将 nums 划分为两个子序列 [1,2] 和 [3] 。 第一个子序列中最大值和最小值的差值是 2 - 1 = 1 。 第二个子序列中最大值和最小值的差值是 3 - 3 = 0 。 由于创建了两个子序列，返回 2 。注意，另一种最优解法是将 nums 划分成子序列 [1] 和 [2,3] 。 示例 3：\n1 2 3 4 5 6 7 8 输入：nums = [2,2,4,5], k = 0 输出：3 解释： 可以将 nums 划分为三个子序列 [2,2]、[4] 和 [5] 。 第一个子序列中最大值和最小值的差值是 2 - 2 = 0 。 第二个子序列中最大值和最小值的差值是 4 - 4 = 0 。 第三个子序列中最大值和最小值的差值是 5 - 5 = 0 。 由于创建了三个子序列，返回 3 。可以证明需要划分的最少子序列数目就是 3 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 0 \u0026lt;= nums[i] \u0026lt;= 10^5 0 \u0026lt;= k \u0026lt;= 105 解题思路 要求是子序列，不用连续，位置不重要，排序贪心就好了。\n从小到大排序后，每次找差值为K的一组。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int partitionArray(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); sort(nums.begin(),nums.end()); int res = 0 ; int curmin=-1; for(int i=0;i\u0026lt;n;i++){ if(curmin==-1){ curmin = nums[i]; }else{ if(nums[i]-curmin\u0026lt;=k){//差值没有超过K，可继续添加元素 }else{//否则，另起一组 curmin = nums[i]; res++; } } } return res+1;//最后的一组统计进来 } }; 【模拟】替换数组中的元素 题目 给你一个下标从 0 开始的数组 nums ，它包含 n 个 互不相同 的正整数。请你对这个数组执行 m 个操作，在第 i 个操作中，你需要将数字 operations[i][0] 替换成 operations[i][1] 。\n题目保证在第 i 个操作中：\noperations[i][0] 在 nums 中存在。 operations[i][1] 在 nums 中不存在。 请你返回执行完所有操作后的数组。\n示例 1：\n1 2 3 4 5 6 7 输入：nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]] 输出：[3,2,7,1] 解释：我们对 nums 执行以下操作： - 将数字 1 替换为 3 。nums 变为 [3,2,4,6] 。 - 将数字 4 替换为 7 。nums 变为 [3,2,7,6] 。 - 将数字 6 替换为 1 。nums 变为 [3,2,7,1] 。 返回最终数组 [3,2,7,1] 。 示例 2：\n1 2 3 4 5 6 7 输入：nums = [1,2], operations = [[1,3],[2,1],[3,2]] 输出：[2,1] 解释：我们对 nums 执行以下操作： - 将数字 1 替换为 3 。nums 变为 [3,2] 。 - 将数字 2 替换为 1 。nums 变为 [3,1] 。 - 将数字 3 替换为 2 。nums 变为 [2,1] 。 返回最终数组 [2,1] 。 提示：\nn == nums.length m == operations.length 1 \u0026lt;= n, m \u0026lt;= 10^5 nums 中所有数字 互不相同 。 operations[i].length == 2 1 \u0026lt;= nums[i], operations[i][0], operations[i][1] \u0026lt;= 10^6 在执行第 i 个操作时，operations[i][0] 在 nums 中存在。 在执行第 i 个操作时，operations[i][1] 在 nums 中不存在。 解题思路 要替换数字，先找到该数字的位置，然后再替换\n元素都不同，且每次操作也不冲突\n利用数据结构存储数的位置。当时看数据范围没那么大就用数组了，值的范围大一点的话用map或unordered_map就行。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const int MAXN = 1e6+5; class Solution { public: vector\u0026lt;int\u0026gt; arrayChange(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; operations) { int n = nums.size(); vector\u0026lt;int\u0026gt; pos(MAXN,-1); for(int i=0;i\u0026lt;n;i++) pos[nums[i]]=i; for(auto \u0026amp;x: operations){ int before = x[0]; int after = x[1]; pos[after] = pos[before]; pos[before] = -1; } vector\u0026lt;int\u0026gt; res(n,0); for(int i=0;i\u0026lt;MAXN;i++){ if(pos[i]\u0026gt;-1) res[pos[i]]=i; } return res; } }; 题目进阶 如果含有重复元素呢\n考虑将操作倒过来，记录每个数最终要变成的数\n令mp[i] = j 表示数i最后会被修改成j\n如果j也会被修改，即mp[i] = mp[j]\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: vector\u0026lt;int\u0026gt; arrayChange(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; operations) { unordered_map\u0026lt;int, int\u0026gt; mp; reverse(operations.begin(), operations.end()); for (auto \u0026amp;op:operations) { // 建立数与数之间的映射关系 if (mp.count(op[1])) mp[op[0]] = mp[op[1]]; else mp[op[0]] = op[1]; } for (int \u0026amp;x:nums) if (mp.count(x)) x = mp[x]; return nums; } }; 【模拟】设计一个文本编辑器 题目 请你设计一个带光标的文本编辑器，它可以实现以下功能：\n**添加：**在光标所在处添加文本。 **删除：**在光标所在处删除文本（模拟键盘的删除键）。 **移动：**将光标往左或者往右移动。 当删除文本时，只有光标左边的字符会被删除。光标会留在文本内，也就是说任意时候 0 \u0026lt;= cursor.position \u0026lt;= currentText.length 都成立。\n请你实现 TextEditor 类：\nTextEditor() 用空文本初始化对象。 void addText(string text) 将 text 添加到光标所在位置。添加完后光标在 text 的右边。 int deleteText(int k) 删除光标左边 k 个字符。返回实际删除的字符数目。 string cursorLeft(int k) 将光标向左移动 k 次。返回移动后光标左边 min(10, len) 个字符，其中 len 是光标左边的字符数目。 string cursorRight(int k) 将光标向右移动 k 次。返回移动后光标左边 min(10, len) 个字符，其中 len 是光标左边的字符数目。 示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 输入： [\u0026#34;TextEditor\u0026#34;, \u0026#34;addText\u0026#34;, \u0026#34;deleteText\u0026#34;, \u0026#34;addText\u0026#34;, \u0026#34;cursorRight\u0026#34;, \u0026#34;cursorLeft\u0026#34;, \u0026#34;deleteText\u0026#34;, \u0026#34;cursorLeft\u0026#34;, \u0026#34;cursorRight\u0026#34;] [[], [\u0026#34;leetcode\u0026#34;], [4], [\u0026#34;practice\u0026#34;], [3], [8], [10], [2], [6]] 输出： [null, null, 4, null, \u0026#34;etpractice\u0026#34;, \u0026#34;leet\u0026#34;, 4, \u0026#34;\u0026#34;, \u0026#34;practi\u0026#34;] 解释： TextEditor textEditor = new TextEditor(); // 当前 text 为 \u0026#34;|\u0026#34; 。（\u0026#39;|\u0026#39; 字符表示光标） textEditor.addText(\u0026#34;leetcode\u0026#34;); // 当前文本为 \u0026#34;leetcode|\u0026#34; 。 textEditor.deleteText(4); // 返回 4 // 当前文本为 \u0026#34;leet|\u0026#34; 。 // 删除了 4 个字符。 textEditor.addText(\u0026#34;practice\u0026#34;); // 当前文本为 \u0026#34;leetpractice|\u0026#34; 。 textEditor.cursorRight(3); // 返回 \u0026#34;etpractice\u0026#34; // 当前文本为 \u0026#34;leetpractice|\u0026#34;. // 光标无法移动到文本以外，所以无法移动。 // \u0026#34;etpractice\u0026#34; 是光标左边的 10 个字符。 textEditor.cursorLeft(8); // 返回 \u0026#34;leet\u0026#34; // 当前文本为 \u0026#34;leet|practice\u0026#34; 。 // \u0026#34;leet\u0026#34; 是光标左边的 min(10, 4) = 4 个字符。 textEditor.deleteText(10); // 返回 4 // 当前文本为 \u0026#34;|practice\u0026#34; 。 // 只有 4 个字符被删除了。 textEditor.cursorLeft(2); // 返回 \u0026#34;\u0026#34; // 当前文本为 \u0026#34;|practice\u0026#34; 。 // 光标无法移动到文本以外，所以无法移动。 // \u0026#34;\u0026#34; 是光标左边的 min(10, 0) = 0 个字符。 textEditor.cursorRight(6); // 返回 \u0026#34;practi\u0026#34; // 当前文本为 \u0026#34;practi|ce\u0026#34; 。 // \u0026#34;practi\u0026#34; 是光标左边的 min(10, 6) = 6 个字符。 提示：\n1 \u0026lt;= text.length, k \u0026lt;= 40 text 只含有小写英文字母。 调用 addText ，deleteText ，cursorLeft 和 cursorRight 的 总 次数不超过 2 * 10^4 次。 进阶：你能设计并实现一个每次调用时间复杂度为 O(k) 的解决方案吗？\n解题思路 一开始看数据范围很小，直接string暴力开码，保存当前光标位置\n没想到74/75，超时了\n果断换Java StringBuilder过了，但它的函数和C++的有区别，一直在调，人麻了\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class TextEditor { StringBuffer str; int p; public TextEditor() { str = new StringBuffer(\u0026#34;|\u0026#34;); p = 0; } public void addText(String text) { str.insert(p,text); p = p+text.length(); } public int deleteText(int k) { int start = Math.max(0,p-k); str.delete(start,p); int res=p-Math.max(0,p-k); p = Math.max(0,p-k); return res; } public String cursorLeft(int k) { str.delete(p,p+1); str.insert(Math.max(0,p-k),\u0026#34;|\u0026#34;); p=Math.max(0,p-k); int start=Math.max(0,p-10); int len=Math.min(10,p-start); return str.substring(start,start+len); } public String cursorRight(int k) { int ma = str.length()-1; str.delete(p,p+1); str.insert(Math.min(p+k,ma),\u0026#34;|\u0026#34;); p=Math.min(p+k,ma); int start=Math.max(0,p-10); int len=Math.min(10,p-start); return str.substring(start,start+len); } } 偷学代码 两个string维护 一个string维护光标前的字符串，一个string维护光标后的字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class TextEditor { string s,t; public: TextEditor() { s=t=\u0026#34;\u0026#34;; } void addText(string text) { s+=text; } int deleteText(int k) { if(s.size()\u0026lt;k)k=s.size(); int i; for(i=0;i\u0026lt;k;i++)s.pop_back(); return k; } string cursorLeft(int k) { if(s.size()\u0026lt;k)k=s.size(); int i; for(i=0;i\u0026lt;k;i++) { t.push_back(s.back()); s.pop_back(); } string ans(s.end()-min(10,int(s.size())),s.end()); return ans; } string cursorRight(int k) { if(t.size()\u0026lt;k)k=t.size(); int i; for(i=0;i\u0026lt;k;i++) { s.push_back(t.back()); t.pop_back(); } string ans(s.end()-min(10,int(s.size())),s.end()); return ans; } }; 双向链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class TextEditor { list\u0026lt;char\u0026gt; l; list\u0026lt;char\u0026gt;::iterator cur = l.begin(); public: TextEditor() {} void addText(string text) { for (char ch : text) l.insert(cur, ch); } int deleteText(int k) { int k0 = k; for (; k \u0026amp;\u0026amp; cur != l.begin(); --k) cur = l.erase(prev(cur)); return k0 - k; } string text() { string s; auto it = cur; for (int k = 10; k \u0026amp;\u0026amp; it != l.begin(); --k) { it = prev(it); s += *it; } reverse(s.begin(), s.end()); return s; } string cursorLeft(int k) { for (; k \u0026amp;\u0026amp; cur != l.begin(); --k) cur = prev(cur); return text(); } string cursorRight(int k) { for (; k \u0026amp;\u0026amp; cur != l.end(); --k) cur = next(cur); return text(); } }; 对顶栈 和两个string维护的差不多\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class TextEditor { vector\u0026lt;char\u0026gt; left, right; public: TextEditor() {} void addText(string text) { left.insert(left.end(), text.begin(), text.end()); } int deleteText(int k) { int k0 = k; for (; k \u0026amp;\u0026amp; !left.empty(); --k) left.pop_back(); return k0 - k; } string text() { return string(next(left.begin(), max((int) left.size() - 10, 0)), left.end()); } string cursorLeft(int k) { for (; k \u0026amp;\u0026amp; !left.empty(); --k) { right.emplace_back(left.back()); left.pop_back(); } return text(); } string cursorRight(int k) { for (; k \u0026amp;\u0026amp; !right.empty(); --k) { left.emplace_back(right.back()); right.pop_back(); } return text(); } }; ","date":"2022-06-08T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220608_hu11374455145407352516.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第296场周赛总结"},{"content":"打家劫舍I、II是经典的序列型DP\n打家劫舍III是树型的，但主要思想是一样的。\n打家劫舍 题目 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n示例 1：\n输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2：\n输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 100\n0 \u0026lt;= nums[i] \u0026lt;= 400\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/house-robber 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 序列DP。\n每个房屋有偷窃和不偷窃两个状态，如果当前房屋偷窃，那么前一个房屋必定不能偷窃；\n如果当前房屋不偷窃，那么前一个房屋可以选择偷窃，也可以选择不偷窃。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if(n==1) return nums[0]; auto dp = vector(n,vector\u0026lt;int\u0026gt;(2,0)); //dp[i][j] 前i个,j=1偷第i个，j=0不偷第i个，的最高金额 dp[0][0]=0,dp[0][1]=nums[0]; dp[1][0]=dp[0][1],dp[1][1]=nums[1]; for(int i=2;i\u0026lt;n;i++){ dp[i][0]=dp[i-1][1]; dp[i][1]=max(dp[i-2][0],dp[i-2][1])+nums[i]; } return max(dp[n-1][0],dp[n-1][1]); } }; 也可以只用一个数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if(n==1) return nums[0]; vector\u0026lt;int\u0026gt; dp(n,0); //dp[i] 前i个房屋能偷窃的最高金额 dp[0] = nums[0]; dp[1] = max(nums[0],nums[1]); for(int i=2;i\u0026lt;n;i++){ dp[i] = max(dp[i-1],dp[i-2]+nums[i]);//第i个要么偷，要么不偷 } return dp[n-1]; } }; 打家劫舍II 题目 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。\n示例 1：\n输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2：\n输入：nums = [1,2,3,1] 输出：4 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 3：\n输入：nums = [1,2,3] 输出：3\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 100\n0 \u0026lt;= nums[i] \u0026lt;= 1000\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/house-robber-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 和前一题的区别是变成了环形。\n受影响的是，选第0个时，最后一个也不能选。\n分情况讨论即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if(n==1) return nums[0]; vector\u0026lt;int\u0026gt; dp(n,0); int res=0; //选第0个时, dp[i]前i个的最大偷窃金额 dp[0]=nums[0]; dp[1]=max(nums[1],dp[0]); for(int i=2;i\u0026lt;n;i++){ dp[i]=max(dp[i-1],dp[i-2]+nums[i]); } res = dp[n-2];//选第0个，则第n-1个不能选 //下面计算不选第0个时的情况 dp[0]=0; dp[1]=nums[1]; for(int i=2;i\u0026lt;n;i++){ dp[i]=max(dp[i-1],dp[i-2]+nums[i]); } res = max(res,dp[n-1]); return res; } }; 打家劫舍III 题目 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。\n除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。\n给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。\n示例 1:\n输入: root = [3,2,3,null,3,null,1] 输出: 7 解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7 示例 2:\n输入: root = [3,4,5,1,3,null,1] 输出: 9 解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9\n提示：\n树的节点数在 [1, 10^4] 范围内\n0 \u0026lt;= Node.val \u0026lt;= 10^4\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/house-robber-iii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 变成了树型，主要思路还是一样的，偷还是不偷两个状态。\n如果偷了当前节点，那么其左右两个子节点必定不能偷\n如果没有偷当前节点，那么其左右两个子节点都是可以偷或者不偷的，取较大值\n代码 官方式的记忆化搜索:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: unordered_map\u0026lt;TreeNode*,int\u0026gt; f,g; //f[root] 偷当前节点 最大值 //g[root] 不偷当前节点 最大值 void dfs(TreeNode* root){ if(root==nullptr) return; dfs(root-\u0026gt;left); dfs(root-\u0026gt;right); int fval = root-\u0026gt;val+g[root-\u0026gt;left]+g[root-\u0026gt;right]; int gval = max(f[root-\u0026gt;left],g[root-\u0026gt;left])+max(f[root-\u0026gt;right],g[root-\u0026gt;right]); f[root]=fval; g[root]=gval; return; } int rob(TreeNode* root) { f[nullptr]=0,g[nullptr]=0; dfs(root); return max(f[root],g[root]); } }; 但我觉得这样更像记忆化搜索：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ #define P pair\u0026lt;TreeNode*,int\u0026gt; class Solution { public: map\u0026lt;P,int\u0026gt; dp; //dp[root][0] 当前根节点为root，且不偷当前节点 的最大值 //dp[root][1] 当前根节点为root，且偷当前节点 的最大值 int dfs(P node){ if(node.first==nullptr) return 0; if(dp[node]) return dp[node]; TreeNode* root = node.first; //偷当前节点 int res=root-\u0026gt;val+dfs(make_pair(root-\u0026gt;left,0))+dfs(make_pair(root-\u0026gt;right,0)); dp[make_pair(root,1)]=res; //不偷当前节点 int res2 = max(dfs(make_pair(root-\u0026gt;left,0)),dfs(make_pair(root-\u0026gt;left,1))) +max(dfs(make_pair(root-\u0026gt;right,0)),dfs(make_pair(root-\u0026gt;right,1))); dp[make_pair(root,0)] = res2; if(node.second==0) return res2; else return res; } int rob(TreeNode* root) { return max(dfs(make_pair(root,0)),dfs(make_pair(root,1))); } }; 树型DP：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ #define P pair\u0026lt;int,int\u0026gt; //first: 不偷 second： 偷 class Solution { public: P dfs(TreeNode* root){ if(root==nullptr) return P(0,0); P left = dfs(root-\u0026gt;left); P right = dfs(root-\u0026gt;right); int val = max(left.first,left.second)+max(right.first,right.second);//不偷当前节点 int val2 = root-\u0026gt;val+left.first+right.first;//偷当前节点 return P(val,val2); } int rob(TreeNode* root) { P res = dfs(root); return max(res.first,res.second); } }; ","date":"2022-06-04T00:00:00Z","image":"https://tetsuou.github.io/p/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/post-bg-20220604_hu10388592810475247632.png","permalink":"https://tetsuou.github.io/p/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/","title":"打家劫舍"},{"content":"\n【枚举】重排字符形成目标字符串 题目 给你两个下标从 0 开始的字符串 s 和 target 。你可以从 s 取出一些字符并将其重排，得到若干新的字符串。\n从 s 中取出字符并重新排列，返回可以形成 target 的 最大 副本数。\n示例 1：\n1 2 3 4 5 6 7 输入：s = \u0026#34;ilovecodingonleetcode\u0026#34;, target = \u0026#34;code\u0026#34; 输出：2 解释： 对于 \u0026#34;code\u0026#34; 的第 1 个副本，选取下标为 4 、5 、6 和 7 的字符。 对于 \u0026#34;code\u0026#34; 的第 2 个副本，选取下标为 17 、18 、19 和 20 的字符。 形成的字符串分别是 \u0026#34;ecod\u0026#34; 和 \u0026#34;code\u0026#34; ，都可以重排为 \u0026#34;code\u0026#34; 。 可以形成最多 2 个 \u0026#34;code\u0026#34; 的副本，所以返回 2 。 示例 2：\n1 2 3 4 5 6 输入：s = \u0026#34;abcba\u0026#34;, target = \u0026#34;abc\u0026#34; 输出：1 解释： 选取下标为 0 、1 和 2 的字符，可以形成 \u0026#34;abc\u0026#34; 的 1 个副本。 可以形成最多 1 个 \u0026#34;abc\u0026#34; 的副本，所以返回 1 。 注意，尽管下标 3 和 4 分别有额外的 \u0026#39;a\u0026#39; 和 \u0026#39;b\u0026#39; ，但不能重用下标 2 处的 \u0026#39;c\u0026#39; ，所以无法形成 \u0026#34;abc\u0026#34; 的第 2 个副本。 示例 3：\n1 2 3 4 5 输入：s = \u0026#34;abbaccaddaeea\u0026#34;, target = \u0026#34;aaaaa\u0026#34; 输出：1 解释： 选取下标为 0 、3 、6 、9 和 12 的字符，可以形成 \u0026#34;aaaaa\u0026#34; 的 1 个副本。 可以形成最多 1 个 \u0026#34;aaaaa\u0026#34; 的副本，所以返回 1 。 提示：\n1 \u0026lt;= s.length \u0026lt;= 100 1 \u0026lt;= target.length \u0026lt;= 10 s 和 target 由小写英文字母组成 解题思路 枚举。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int rearrangeCharacters(string s, string target) { vector\u0026lt;int\u0026gt; cnt(26,0),t(26,0); for(auto \u0026amp;x: s) cnt[x-\u0026#39;a\u0026#39;]++; for(auto \u0026amp;x: target) t[x-\u0026#39;a\u0026#39;]++; int res=100; for(int i=0;i\u0026lt;26;i++){ if(!t[i]) continue; res = min(res, cnt[i]/t[i]); } return res; } }; 【模拟】价格减免 题目 句子 是由若干个单词组成的字符串，单词之间用单个空格分隔，其中每个单词可以包含数字、小写字母、和美元符号 '$' 。如果单词的形式为美元符号后跟着一个非负实数，那么这个单词就表示一个价格。\n例如 \u0026quot;$100\u0026quot;、\u0026quot;$23\u0026quot; 和 \u0026quot;$6.75\u0026quot; 表示价格，而 \u0026quot;100\u0026quot;、\u0026quot;$\u0026quot; 和 \u0026quot;2$3\u0026quot; 不是。 **注意：**本题输入中的价格均为整数。\n给你一个字符串 sentence 和一个整数 discount 。对于每个表示价格的单词，都在价格的基础上减免 discount% ，并 更新 该单词到句子中。所有更新后的价格应该表示为一个 恰好保留小数点后两位 的数字。\n返回表示修改后句子的字符串。\n示例 1：\n1 2 3 4 5 6 输入：sentence = \u0026#34;there are $1 $2 and 5$ candies in the shop\u0026#34;, discount = 50 输出：\u0026#34;there are $0.50 $1.00 and 5$ candies in the shop\u0026#34; 解释： 表示价格的单词是 \u0026#34;$1\u0026#34; 和 \u0026#34;$2\u0026#34; 。 - \u0026#34;$1\u0026#34; 减免 50% 为 \u0026#34;$0.50\u0026#34; ，所以 \u0026#34;$1\u0026#34; 替换为 \u0026#34;$0.50\u0026#34; 。 - \u0026#34;$2\u0026#34; 减免 50% 为 \u0026#34;$1\u0026#34; ，所以 \u0026#34;$1\u0026#34; 替换为 \u0026#34;$1.00\u0026#34; 。 示例 2：\n1 2 3 4 5 6 输入：sentence = \u0026#34;1 2 $3 4 $5 $6 7 8$ $9 $10$\u0026#34;, discount = 100 输出：\u0026#34;1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$\u0026#34; 解释： 任何价格减免 100% 都会得到 0 。 表示价格的单词分别是 \u0026#34;$3\u0026#34;、\u0026#34;$5\u0026#34;、\u0026#34;$6\u0026#34; 和 \u0026#34;$9\u0026#34;。 每个单词都替换为 \u0026#34;$0.00\u0026#34;。 提示：\n1 \u0026lt;= sentence.length \u0026lt;= 10^5 sentence 由小写英文字母、数字、' ' 和 '$' 组成 sentence 不含前导和尾随空格 sentence 的所有单词都用单个空格分隔 所有价格都是 正 整数且不含前导零 所有价格 最多 为 10 位数字 0 \u0026lt;= discount \u0026lt;= 100 解题思路 C++做这题真的人麻了。\n两个坑吧，一个是价格最多为10位数字，用stoi函数将string转int时是不够的，可能会溢出，要用stol函数；\n一个是精度问题。利用字符串流。\n1 2 3 4 5 long long price = stol(cur.substr(1)); double p = 1.00*price*(100-discount)/100.00; stringstream out; out\u0026lt;\u0026lt;fixed\u0026lt;\u0026lt;setprecision(2)\u0026lt;\u0026lt;p; string s = out.str(); 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: string discountPrices(string sentence, int discount) { stringstream ss(sentence); string res,cur; while(ss\u0026gt;\u0026gt;cur){ if(cur.size()\u0026gt;1 \u0026amp;\u0026amp; cur[0]==\u0026#39;$\u0026#39;){ bool flag=true; for(int i=1;i\u0026lt;cur.size()\u0026amp;\u0026amp;flag;i++) { if(cur[i]\u0026gt;=\u0026#39;0\u0026#39; \u0026amp;\u0026amp; cur[i]\u0026lt;=\u0026#39;9\u0026#39;) continue; else flag=false; } if(!flag){ res += cur+\u0026#39; \u0026#39;; continue; } long long price = stol(cur.substr(1)); double p = 1.00*price*(100-discount)/100.00; stringstream out; out\u0026lt;\u0026lt;fixed\u0026lt;\u0026lt;setprecision(2)\u0026lt;\u0026lt;p; string s = out.str(); cur = \u0026#39;$\u0026#39;+s; } res += cur+\u0026#39; \u0026#39;; } res = res.substr(0,res.size()-1); return res; } }; 偷学代码 用python很舒服\n1 2 3 4 5 6 7 8 9 10 class Solution: def discountPrices(self, sentence: str, discount: int) -\u0026gt; str: arr = [] for x in sentence.split(): if x.startswith(\u0026#39;$\u0026#39;) and x[1:].isdigit(): num = float(x[1:]) * (100 - float(discount)) / 100 arr.append(\u0026#39;${:.2f}\u0026#39;.format(num)) else: arr.append(x) return \u0026#39; \u0026#39;.join(arr) 【单调栈+DP】使数组按非递减顺序排列 题目 给你一个下标从 0 开始的整数数组 nums 。在一步操作中，移除所有满足 nums[i - 1] \u0026gt; nums[i] 的 nums[i] ，其中 0 \u0026lt; i \u0026lt; nums.length 。\n重复执行步骤，直到 nums 变为 非递减 数组，返回所需执行的操作数。\n示例 1：\n1 2 3 4 5 6 7 输入：nums = [5,3,4,4,7,3,6,11,8,5,11] 输出：3 解释：执行下述几个步骤： - 步骤 1 ：[5,3,4,4,7,3,6,11,8,5,11] 变为 [5,4,4,7,6,11,11] - 步骤 2 ：[5,4,4,7,6,11,11] 变为 [5,4,7,11,11] - 步骤 3 ：[5,4,7,11,11] 变为 [5,7,11,11] [5,7,11,11] 是一个非递减数组，因此，返回 3 。 示例 2：\n1 2 3 输入：nums = [4,5,7,7,13] 输出：0 解释：nums 已经是一个非递减数组，因此，返回 0 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^9 解题思路 元素 x 会被左边某个比他大的元素 y 给删除（如果存在的话）。\n我们需要计算在删除 x 之前，删除了多少个比 y 小的元素，从而算出删除 x 的时刻（第几步操作）。\n答案可以转换成所有元素被删除的时刻的最大值。\n考虑每一个数被删除的时间点。如果num[i]左侧没有比它更大的数，那么该数不会被删除；如果左侧有比它更大的数，记左侧最近比它大的数的位置为L，那么num[L+1..i]这几个数都可以看成是被num[L]删除的，此时t[i]=max(t[L+1..i-1])+1，即在中间的数删除后加1。\n单调栈+DP+线段树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 const int MAXN = 1e5+5; #define ls(p) (p\u0026lt;\u0026lt;1) #define rs(p) (p\u0026lt;\u0026lt;1|1) class Solution { public: struct node{ int maxv; }T[MAXN\u0026lt;\u0026lt;2]; void push_up(int p){ T[p].maxv=max(T[ls(p)].maxv,T[rs(p)].maxv); } void build(int p, int l, int r){ T[p]={0}; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(ls(p),l,mid); build(rs(p),mid+1,r); } void update(int p, int l, int r, int nr, int k){ if(l==r \u0026amp;\u0026amp; l==nr){ T[p].maxv = k; return; } int mid=(l+r)\u0026gt;\u0026gt;1; if(nr\u0026lt;=mid) update(ls(p),l,mid,nr,k); else update(rs(p),mid+1,r,nr,k); push_up(p); } int query(int p, int l, int r, int nl, int nr){ if(nl\u0026lt;=l\u0026amp;\u0026amp;nr\u0026gt;=r) return T[p].maxv; int mid=(l+r)\u0026gt;\u0026gt;1; int res=0; if(nl\u0026lt;=mid) res=max(res,query(ls(p),l,mid,nl,nr)); if(nr\u0026gt;mid) res=max(res,query(rs(p),mid+1,r,nl,nr)); return res; } int totalSteps(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; L(n,-1);//L[i] 左边第一个比nums[i]大的数的位置 stack\u0026lt;int\u0026gt; stk; stk.push(0); for(int i=1;i\u0026lt;n;i++){ while(!stk.empty() \u0026amp;\u0026amp; nums[i]\u0026gt;=nums[stk.top()]) stk.pop(); if(stk.empty()) L[i] = -1; else L[i] = stk.top(); stk.push(i); } vector\u0026lt;int\u0026gt; t(n,0);//t[i] 删除nums[i]所需执行的操作数 int res = 0; build(1,1,n); for(int i=0;i\u0026lt;n;i++){ if(L[i]==-1) t[i]=0;//nums[i]左边没有比它更大的数，不会被删除 //else if(L[i]==i-1) t[i]=1;//会被相邻左边元素删掉，步数为1 else{ //t[i]=max(t[l+1..i-1]) t[i]=query(1,1,n,L[i]+1+1,i-1+1)+1; } update(1,1,n,i+1,t[i]); res = max(res,t[i]); } return res; } }; 单调栈+DP 仅仅使用单调栈也是可以的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int totalSteps(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; t(n,0);//t[i] 删除nums[i]所需要的时间 int res=0; stack\u0026lt;int\u0026gt; stk; for(int i=0;i\u0026lt;n;i++){ int cur=0;//删除nums[i]所需要的时间 while(!stk.empty() \u0026amp;\u0026amp; nums[i]\u0026gt;=nums[stk.top()]){ cur=max(cur,t[stk.top()]); stk.pop(); } if(stk.empty()) cur=0;//左侧没有更大的数，不会被删 else cur+=1;//有，删除该数需要加1次操作 stk.push(i); t[i]=cur; res=max(res,cur); } return res; } }; 【最短路】到达角落需要移除障碍物的最小数目 题目 给你一个下标从 0 开始的二维整数数组 grid ，数组大小为 m x n 。每个单元格都是两个值之一：\n0 表示一个 空 单元格， 1 表示一个可以移除的 障碍物 。 你可以向上、下、左、右移动，从一个空单元格移动到另一个空单元格。\n现在你需要从左上角 (0, 0) 移动到右下角 (m - 1, n - 1) ，返回需要移除的障碍物的 最小 数目。\n示例 1：\n1 2 3 4 5 输入：grid = [[0,1,1],[1,1,0],[1,1,0]] 输出：2 解释：可以移除位于 (0, 1) 和 (0, 2) 的障碍物来创建从 (0, 0) 到 (2, 2) 的路径。 可以证明我们至少需要移除两个障碍物，所以返回 2 。 注意，可能存在其他方式来移除 2 个障碍物，创建出可行的路径。 示例 2：\n1 2 3 输入：grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]] 输出：0 解释：不移除任何障碍物就能从 (0, 0) 到 (2, 4) ，所以返回 0 。 提示：\nm == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 10^5 2 \u0026lt;= m * n \u0026lt;= 10^5 grid[i][j] 为 0 或 1 grid[0][0] == grid[m - 1][n - 1] == 0 解题思路 一开始没想到用最短路相关算法做。\n只想着用BFS+优先队列，一路标记状态避免访问重复状态，最先到达终点时就是最小移除障碍数目。标记状态时，状态有3部分。\n这种做法很接近堆优化的Dijkstra算法了。\n注意一点，优先队列priority_queue默认是最大堆，要么在结构体定义\u0026lt;号时反过来，要么还是在结构体中正常定义，但是将堆声明为最小堆（这种方式好像不行，只能在结构体定义中注意一下了）。\n代码1.0（TLE） 状态是3元组，用set存自定义结构体。超时了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public: struct node{ int x,y; int del; node(int _x,int _y,int _d){ x=_x,y=_y,del=_d; } friend bool operator \u0026lt; (const node\u0026amp; a, const node\u0026amp; b){ if(a.del!=b.del) return a.del\u0026gt;b.del; else if(a.x!=b.x) return a.x\u0026lt;b.x; else return a.y\u0026lt;b.y; } }; int dir[4][2]={ {0,1},{0,-1},{1,0},{-1,0} };//右 左 上 下 int minimumObstacles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(),m=grid[0].size(); set\u0026lt;node\u0026gt; tab; // queue\u0026lt;node\u0026gt; que; priority_queue\u0026lt;node\u0026gt; que; que.emplace(0,0,0); tab.insert(node(0,0,0)); function\u0026lt;bool(int,int)\u0026gt; isok = [\u0026amp;](int p,int q){ if(p\u0026lt;0||p\u0026gt;=n) return false; if(q\u0026lt;0||q\u0026gt;=m) return false; return true; }; while(!que.empty()){ auto [x,y,del] = que.top(); que.pop(); if(x==n-1\u0026amp;\u0026amp;y==m-1) return del; for(int i=0;i\u0026lt;4;i++){ int dx=x+dir[i][0]; int dy=y+dir[i][1]; if(!isok(dx,dy)) continue; if(grid[dx][dy]==1) { if(tab.count(node(dx,dy,del+1))) continue; tab.insert(node(dx,dy,del+1)); que.push(node(dx,dy,del+1)); }else{ if(tab.count(node(dx,dy,del))) continue; tab.insert(node(dx,dy,del)); que.push(node(dx,dy,del)); } } } return 0; } }; 代码2.0（TLE） 将set换成unordered_set，需要自定义哈希方法，结果需要的时间反而更多？通过样例更少\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class Solution { public: struct node{ int x,y; int del; node(int _x,int _y,int _d){ x=_x,y=_y,del=_d; } friend bool operator \u0026lt; (const node\u0026amp; a, const node\u0026amp; b){ if(a.del!=b.del) return a.del\u0026gt;b.del; else if(a.x!=b.x) return a.x\u0026lt;b.x; else return a.y\u0026lt;b.y; } friend bool operator ==(const node\u0026amp; a, const node\u0026amp; b){ return a.x==b.x\u0026amp;\u0026amp;a.y==b.y\u0026amp;\u0026amp;a.del==b.del; } }; struct nodeHash{ size_t operator () (const node\u0026amp; t) const{ return t.x*100+t.y*10+t.del; } }; int dir[4][2]={ {0,1},{0,-1},{1,0},{-1,0} };//右 左 上 下 int minimumObstacles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(),m=grid[0].size(); // set\u0026lt;node\u0026gt; tab; unordered_set\u0026lt;node,nodeHash\u0026gt; tab; // queue\u0026lt;node\u0026gt; que; priority_queue\u0026lt;node\u0026gt; que; que.emplace(0,0,0); tab.insert(node(0,0,0)); function\u0026lt;bool(int,int)\u0026gt; isok = [\u0026amp;](int p,int q){ if(p\u0026lt;0||p\u0026gt;=n) return false; if(q\u0026lt;0||q\u0026gt;=m) return false; return true; }; while(!que.empty()){ auto [x,y,del] = que.top(); que.pop(); if(x==n-1\u0026amp;\u0026amp;y==m-1) return del; for(int i=0;i\u0026lt;4;i++){ int dx=x+dir[i][0]; int dy=y+dir[i][1]; if(!isok(dx,dy)) continue; if(grid[dx][dy]==1) { if(tab.count(node(dx,dy,del+1))) continue; tab.insert(node(dx,dy,del+1)); que.push(node(dx,dy,del+1)); }else{ if(tab.count(node(dx,dy,del))) continue; tab.insert(node(dx,dy,del)); que.push(node(dx,dy,del)); } } } return 0; } }; 代码3.0（堆优化的Dijkstra） 将空白处的2个节点相互之间是一条权值为0的边，与障碍物则是一条权值为1的边，实际上这题就是最短路径问题。\ndst[x,y] 起点到该点的最短距离\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 const int INF = 0x3f3f3f3f; class Solution { public: struct node{ int x,y; int del; node(int _x,int _y,int _d){ x=_x,y=_y,del=_d; } friend bool operator \u0026lt; (const node\u0026amp; a, const node\u0026amp; b){ if(a.del!=b.del) return a.del\u0026gt;b.del; else if(a.x!=b.x) return a.x\u0026lt;b.x; else return a.y\u0026lt;b.y; } }; int dir[4][2]={ {0,1},{0,-1},{1,0},{-1,0} };//右 左 上 下 int minimumObstacles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(),m=grid[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dst(n,vector\u0026lt;int\u0026gt;(m,INF)); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vis(n,vector\u0026lt;int\u0026gt;(m,0)); priority_queue\u0026lt;node\u0026gt; que; que.emplace(0,0,0); dst[0][0]=0; vis[0][0]=1; function\u0026lt;bool(int,int)\u0026gt; isok = [\u0026amp;](int p,int q){ if(p\u0026lt;0||p\u0026gt;=n) return false; if(q\u0026lt;0||q\u0026gt;=m) return false; return true; }; while(!que.empty()){ auto [x,y,del] = que.top(); que.pop(); if(x==n-1\u0026amp;\u0026amp;y==m-1) return del; for(int i=0;i\u0026lt;4;i++){ int dx=x+dir[i][0]; int dy=y+dir[i][1]; if(!isok(dx,dy)) continue; if(vis[dx][dy]) continue; if(del+grid[dx][dy]\u0026lt;dst[dx][dy]){ dst[dx][dy]=del+grid[dx][dy]; que.push(node(dx,dy,dst[dx][dy])); vis[dx][dy]=1; } } } return dst[n-1][m-1]; } }; 代码4.0（01BFS） BFS为什么能求最短路径。在每个权值相同的情况下，BFS求的是最短路径。像这种只有0和另一权值的，也可以用BFS，不过一个队列是不够的，要么拿两个队列，要么拿一个双端队列，0的话加在开头，另一权值的加在末尾。\n即不用到优先队列，就可以判断最短距离。注意，只有权值为0和其他值才可以，但是如果是2个不为0的，就不能保证。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 const int INF = 0x3f3f3f3f; class Solution { public: struct node{ int x,y; int del; node(int _x,int _y,int _d){ x=_x,y=_y,del=_d; } }; int dir[4][2]={ {0,1},{0,-1},{1,0},{-1,0} };//右 左 上 下 int minimumObstacles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(),m=grid[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dst(n,vector\u0026lt;int\u0026gt;(m,INF)); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vis(n,vector\u0026lt;int\u0026gt;(m,0)); deque\u0026lt;node\u0026gt; que; que.emplace_back(0,0,0); dst[0][0]=0; vis[0][0]=1; function\u0026lt;bool(int,int)\u0026gt; isok = [\u0026amp;](int p,int q){ if(p\u0026lt;0||p\u0026gt;=n) return false; if(q\u0026lt;0||q\u0026gt;=m) return false; return true; }; while(!que.empty()){ auto [x,y,del] = que.front(); que.pop_front(); if(x==n-1\u0026amp;\u0026amp;y==m-1) return del; for(int i=0;i\u0026lt;4;i++){ int dx=x+dir[i][0]; int dy=y+dir[i][1]; if(!isok(dx,dy)) continue; if(vis[dx][dy]) continue; if(grid[dx][dy]==1) que.emplace_back(dx,dy,del+1); else que.emplace_front(dx,dy,del); vis[dx][dy]=1; } } return 0; } }; ","date":"2022-06-02T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC295%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220602_hu2328369915977039937.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC295%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第295场周赛总结"},{"content":"\n【模拟】判断一个数的数字计数是否等于数位的值 题目 给你一个下标从 0 开始长度为 n 的字符串 num ，它只包含数字。\n如果对于 每个 0 \u0026lt;= i \u0026lt; n 的下标 i ，都满足数位 i 在 num 中出现了 num[i]次，那么请你返回 true ，否则返回 false 。\n示例 1：\n1 2 3 4 5 6 7 8 输入：num = \u0026#34;1210\u0026#34; 输出：true 解释： num[0] = \u0026#39;1\u0026#39; 。数字 0 在 num 中出现了一次。 num[1] = \u0026#39;2\u0026#39; 。数字 1 在 num 中出现了两次。 num[2] = \u0026#39;1\u0026#39; 。数字 2 在 num 中出现了一次。 num[3] = \u0026#39;0\u0026#39; 。数字 3 在 num 中出现了零次。 \u0026#34;1210\u0026#34; 满足题目要求条件，所以返回 true 。 示例 2：\n1 2 3 4 5 6 7 输入：num = \u0026#34;030\u0026#34; 输出：false 解释： num[0] = \u0026#39;0\u0026#39; 。数字 0 应该出现 0 次，但是在 num 中出现了一次。 num[1] = \u0026#39;3\u0026#39; 。数字 1 应该出现 3 次，但是在 num 中出现了零次。 num[2] = \u0026#39;0\u0026#39; 。数字 2 在 num 中出现了 0 次。 下标 0 和 1 都违反了题目要求，所以返回 false 。 提示：\nn == num.length 1 \u0026lt;= n \u0026lt;= 10 num 只包含数字。 解题思路 模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: bool digitCount(string num) { vector\u0026lt;int\u0026gt; a(10,0);//a[i] i出现的次数 for(auto \u0026amp;x: num){ a[x-\u0026#39;0\u0026#39;]++; } for(int i=0;i\u0026lt;num.size();i++){ if(a[i]!=num[i]-\u0026#39;0\u0026#39;) return false; } return true; } }; 【模拟】最多单词数的发件人 题目 给你一个聊天记录，共包含 n 条信息。给你两个字符串数组 messages 和 senders ，其中 messages[i] 是 senders[i] 发出的一条 信息 。\n一条 信息 是若干用单个空格连接的 单词 ，信息开头和结尾不会有多余空格。发件人的 单词计数 是这个发件人总共发出的 单词数 。注意，一个发件人可能会发出多于一条信息。\n请你返回发出单词数 最多 的发件人名字。如果有多个发件人发出最多单词数，请你返回 字典序 最大的名字。\n注意：\n字典序里，大写字母小于小写字母。 \u0026quot;Alice\u0026quot; 和 \u0026quot;alice\u0026quot; 是不同的名字。 示例 1：\n1 2 3 4 5 6 输入：messages = [\u0026#34;Hello userTwooo\u0026#34;,\u0026#34;Hi userThree\u0026#34;,\u0026#34;Wonderful day Alice\u0026#34;,\u0026#34;Nice day userThree\u0026#34;], senders = [\u0026#34;Alice\u0026#34;,\u0026#34;userTwo\u0026#34;,\u0026#34;userThree\u0026#34;,\u0026#34;Alice\u0026#34;] 输出：\u0026#34;Alice\u0026#34; 解释：Alice 总共发出了 2 + 3 = 5 个单词。 userTwo 发出了 2 个单词。 userThree 发出了 3 个单词。 由于 Alice 发出单词数最多，所以我们返回 \u0026#34;Alice\u0026#34; 。 示例 2：\n1 2 3 4 5 输入：messages = [\u0026#34;How is leetcode for everyone\u0026#34;,\u0026#34;Leetcode is useful for practice\u0026#34;], senders = [\u0026#34;Bob\u0026#34;,\u0026#34;Charlie\u0026#34;] 输出：\u0026#34;Charlie\u0026#34; 解释：Bob 总共发出了 5 个单词。 Charlie 总共发出了 5 个单词。 由于最多单词数打平，返回字典序最大的名字，也就是 Charlie 。 提示：\nn == messages.length == senders.length 1 \u0026lt;= n \u0026lt;= 10^4 1 \u0026lt;= messages[i].length \u0026lt;= 100 1 \u0026lt;= senders[i].length \u0026lt;= 10 messages[i] 包含大写字母、小写字母和 ' ' 。 messages[i] 中所有单词都由 单个空格 隔开。 messages[i] 不包含前导和后缀空格。 senders[i] 只包含大写英文字母和小写英文字母。 解题思路 统计每个人发送的单词个数\nWA了一发，WA在返回值的初始化上，不能盲目地像整型那样，直接初始化答案为第1个人是不妥的。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: int fun(string s){ int res=0; for(auto \u0026amp;x: s){ if(x==\u0026#39; \u0026#39;) res++; } return res+1; } string largestWordCount(vector\u0026lt;string\u0026gt;\u0026amp; messages, vector\u0026lt;string\u0026gt;\u0026amp; senders) { int maxnum = 0; int n = messages.size(); map\u0026lt;string,int\u0026gt; tab; for(int i=0;i\u0026lt;n;i++){ tab[senders[i]] += fun(messages[i]); } string res = \u0026#34;\u0026#34;; for(auto \u0026amp;x: tab){ // cout\u0026lt;\u0026lt;x.first\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;x.second\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;maxnum\u0026lt;\u0026lt;endl; if(x.second\u0026gt;=maxnum){ // cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; maxnum = x.second; if(x.first\u0026gt;=res) res = x.first; } } return res; } }; 【贪心】道路的最大总重要性 题目 给你一个整数 n ，表示一个国家里的城市数目。城市编号为 0 到 n - 1 。\n给你一个二维整数数组 roads ，其中 roads[i] = [ai, bi] 表示城市 ai 和 bi 之间有一条 双向 道路。\n你需要给每个城市安排一个从 1 到 n 之间的整数值，且每个值只能被使用 一次 。道路的 重要性 定义为这条道路连接的两座城市数值 之和 。\n请你返回在最优安排下，所有道路重要性 之和 最大 为多少。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 输入：n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]] 输出：43 解释：上图展示了国家图和每个城市被安排的值 [2,4,5,3,1] 。 - 道路 (0,1) 重要性为 2 + 4 = 6 。 - 道路 (1,2) 重要性为 4 + 5 = 9 。 - 道路 (2,3) 重要性为 5 + 3 = 8 。 - 道路 (0,2) 重要性为 2 + 5 = 7 。 - 道路 (1,3) 重要性为 4 + 3 = 7 。 - 道路 (2,4) 重要性为 5 + 1 = 6 。 所有道路重要性之和为 6 + 9 + 8 + 7 + 7 + 6 = 43 。 可以证明，重要性之和不可能超过 43 。 示例 2：\n1 2 3 4 5 6 7 8 输入：n = 5, roads = [[0,3],[2,4],[1,3]] 输出：20 解释：上图展示了国家图和每个城市被安排的值 [4,3,2,5,1] 。 - 道路 (0,3) 重要性为 4 + 5 = 9 。 - 道路 (2,4) 重要性为 2 + 1 = 3 。 - 道路 (1,3) 重要性为 3 + 5 = 8 。 所有道路重要性之和为 9 + 3 + 8 = 20 。 可以证明，重要性之和不可能超过 20 。 提示：\n2 \u0026lt;= n \u0026lt;= 5 * 10^4 1 \u0026lt;= roads.length \u0026lt;= 5 * 10^4 roads[i].length == 2 0 \u0026lt;= ai, bi \u0026lt;= n - 1 ai != bi 没有重复道路。 解题思路 显然对邻居数越多的点赋予越重要的值，收益越大\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: long long maximumImportance(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; roads) { long long res = 0; vector\u0026lt;int\u0026gt; cnt(n,0); for(auto \u0026amp;x: roads){ cnt[x[0]]++; cnt[x[1]]++; } sort(cnt.begin(),cnt.end(),greater\u0026lt;int\u0026gt;()); // for(auto \u0026amp;x: cnt) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;; int a = n; for(auto \u0026amp;x: cnt){ res += 1ll*a*x; a--; } return res; } }; 【线段树好题】以组为单位订音乐会的门票 题目 一个音乐会总共有 n 排座位，编号从 0 到 n - 1 ，每一排有 m 个座椅，编号为 0 到 m - 1 。你需要设计一个买票系统，针对以下情况进行座位安排：\n同一组的 k 位观众坐在 同一排座位，且座位连续 。 k 位观众中 每一位 都有座位坐，但他们 不一定 坐在一起。 由于观众非常挑剔，所以：\n只有当一个组里所有成员座位的排数都 小于等于 maxRow ，这个组才能订座位。每一组的 maxRow 可能 不同 。 如果有多排座位可以选择，优先选择 最小 的排数。如果同一排中有多个座位可以坐，优先选择号码 最小 的。 请你实现 BookMyShow 类：\nBookMyShow(int n, int m) ，初始化对象，n 是排数，m 是每一排的座位数。 int[] gather(int k, int maxRow) 返回长度为 2 的数组，表示 k 个成员中 第一个座位 的排数和座位编号，这 k 位成员必须坐在 同一排座位，且座位连续 。换言之，返回最小可能的 r 和 c 满足第 r 排中 [c, c + k - 1] 的座位都是空的，且 r \u0026lt;= maxRow 。如果 无法 安排座位，返回 [] 。 boolean scatter(int k, int maxRow) 如果组里所有 k 个成员 不一定 要坐在一起的前提下，都能在第 0 排到第 maxRow 排之间找到座位，那么请返回 true 。这种情况下，每个成员都优先找排数 最小 ，然后是座位编号最小的座位。如果不能安排所有 k 个成员的座位，请返回 false 。 示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 输入： [\u0026#34;BookMyShow\u0026#34;, \u0026#34;gather\u0026#34;, \u0026#34;gather\u0026#34;, \u0026#34;scatter\u0026#34;, \u0026#34;scatter\u0026#34;] [[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]] 输出： [null, [0, 0], [], true, false] 解释： BookMyShow bms = new BookMyShow(2, 5); // 总共有 2 排，每排 5 个座位。 bms.gather(4, 0); // 返回 [0, 0] // 这一组安排第 0 排 [0, 3] 的座位。 bms.gather(2, 0); // 返回 [] // 第 0 排只剩下 1 个座位。 // 所以无法安排 2 个连续座位。 bms.scatter(5, 1); // 返回 True // 这一组安排第 0 排第 4 个座位和第 1 排 [0, 3] 的座位。 bms.scatter(5, 1); // 返回 False // 总共只剩下 2 个座位。 提示：\n1 \u0026lt;= n \u0026lt;= 5 * 10^4 1 \u0026lt;= m, k \u0026lt;= 10^9 0 \u0026lt;= maxRow \u0026lt;= n - 1 gather 和 scatter 总 调用次数不超过 5 * 10^4 次。 解题思路 比赛的时候这题一开始一直刷不出来？后面看到题也没有思路。就没去做了。看了题解码了代码，发现真是一道线段树好题。\n想到了可能要用线段树，但不知道维护啥，当时没注意到座位排的每一行最左边都是排满的，即不会出现两边坐人，中间有空的情况，所以还是很方便维护的。\n即线段树的叶子节点对应的是，第i排座位的使用情况，分析后面操作可知，区间维护总和 和 最大值即可。\n题中共有两种操作，gather操作和scatter操作。\n（由于写线段树一般都从1开始，所以与题中0开始的计序，有个1的偏移）\n对于gather操作，对于区间[1,maxRow+1]，在该区间查询是否存在有某一个单点的剩余座位数大于等于k，如果存在，则需要对最左边这样的单点进行更新。这需要维护区间最大值（区间最大剩余座位数）。\n对于scatter操作，对于区间[1,maxRow+1]，在该区间查询剩余总座位数是否大于等于k，如果满足，则需要从左到右落座，即从最左边开始对若干单点进行更新。这需要维护区间总和（区间剩余座位数的总和）。\n1 2 3 4 struct node{ ll sum;//区间内剩余座位的总和，可能溢出，定义类型为long long int maxv;//区间内最大剩余座位数 }T[MAXN\u0026lt;\u0026lt;2]; push_up 1 2 3 4 void push_up(int p){ T[p].sum = T[ls(p)].sum+T[rs(p)].sum; T[p].maxv = max(T[ls(p)].maxv, T[rs(p)].maxv); } 更新总和 以及 最大值。\n注意此题是用不到区间更新的，所以不需要用懒标记，即不需要push_down。\nbuild 1 2 3 4 5 6 7 8 9 10 11 void build(int p, int l, int r){ T[p]={0,0}; if(l==r){ T[p]={m,m};//初始时，单排剩余座位为m return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(ls(p),l,mid); build(rs(p),mid+1,r); push_up(p); } 常规线段树建树。叶子节点对应的是单点，即每一排座位的情况。非叶子节点对应的是一个长度大于1的区间，维护了该区间内剩余座位的总和以及最大值。\ngather操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //gather 在[nl,nr]区间内查询第一个剩余座位大于等于k的单点 //如果找到，还要进行单点更新 vector\u0026lt;int\u0026gt; do_gather(int p, int l, int r, int nl, int nr, int k){ if(T[p].maxv \u0026lt; k) return {};//最大容量都满足不了 //l==r说明是单点 nr\u0026gt;=r\u0026amp;\u0026amp;nl\u0026lt;=l说明满足区间要求 找到解了 if(l==r \u0026amp;\u0026amp; nr\u0026gt;=r \u0026amp;\u0026amp; nl\u0026lt;=l){ vector\u0026lt;int\u0026gt; res(2,0); res[0] = l-1; res[1] = m-T[p].maxv; T[p].maxv -= k;//修改 T[p].sum -= k; return res; } vector\u0026lt;int\u0026gt; ans; int mid=(l+r)\u0026gt;\u0026gt;1; //要么往左子树走要么往右子树走，直到叶子节点为止 //如果左子树够的话，肯定先往左子树走；否则往右子树走 if(T[ls(p)].maxv\u0026gt;=k \u0026amp;\u0026amp; nl\u0026lt;=mid) ans = do_gather(ls(p),l,mid,nl,nr,k); else if(T[rs(p)].maxv\u0026gt;=k \u0026amp;\u0026amp; nr\u0026gt;mid) ans = do_gather(rs(p),mid+1,r,nl,nr,k); push_up(p); return ans; } 这个操作处理题中的gather操作。将区间查询和单点更新操作写到了一块儿。\nscatter操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //scatter 在[nl,nr]区间内查询sum是否大于等于k //如果满足条件，设最后一个人在的位置为(row,col)，进行更新 //则[1,row-1]区间内的剩余座位为0，[row,row]区间内剩余座位 减人数 bool do_scatter(int p, int l, int r, int nl, int nr, int k){ if(T[p].sum\u0026lt;k) return false;//区间内总剩余座位数不够 if(l==r \u0026amp;\u0026amp; nr\u0026gt;=r \u0026amp;\u0026amp; nl\u0026lt;=l){//该排坐k个人，单点更新 T[p].sum -= k; T[p].maxv = T[p].sum; return true; } int mid=(l+r)\u0026gt;\u0026gt;1; //看左子树的总剩余座位数够不够，优先往左子树坐人 int left = min(T[ls(p)].sum, 1ll*k);//左子树容纳的人数 k -= left;//减去左子树的座位，如果有多的则要去右子树 bool res = true; //左子树不够，还要去右子树，如果加上右子树还不够，返回false if(k\u0026gt;0) { if(nr\u0026lt;=mid) res=false;//往右子树走需满足 nr\u0026gt;mid if(!res) return false; res = res \u0026amp;\u0026amp; do_scatter(rs(p),mid+1,r,nl,nr,k); } if(!res) return false; //不需要用到右子树，判断左子树是否够 if(nl\u0026lt;=mid) res = res \u0026amp;\u0026amp; do_scatter(ls(p),l,mid,nl,nr,left); push_up(p); return res; } 这个操作处理题中的scatter操作，也是将查询和单点更新写在了一块儿。\n每次可先判断左子树的总剩余座位数够不够，如果够的话，就不用管右子树了，这些人应该全部往左子树坐；如果不够的话，可以求出右子树要坐的人，再将这些人往右子树坐。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 #define ls(p) (p\u0026lt;\u0026lt;1) #define rs(p) (p\u0026lt;\u0026lt;1|1) #define ll long long const int MAXN = 5e4+5; class BookMyShow { public: int n,m; struct node{ ll sum;//区间内剩余座位的总和 int maxv;//区间内最大剩余座位数 }T[MAXN\u0026lt;\u0026lt;2]; void push_up(int p){ T[p].sum = T[ls(p)].sum+T[rs(p)].sum; T[p].maxv = max(T[ls(p)].maxv, T[rs(p)].maxv); } void build(int p, int l, int r){ T[p]={0,0}; if(l==r){ T[p]={m,m};//初始时，单排剩余座位为m return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(ls(p),l,mid); build(rs(p),mid+1,r); push_up(p); } //gather 在[nl,nr]区间内查询第一个剩余座位大于等于k的单点 //如果找到，还要进行单点更新 vector\u0026lt;int\u0026gt; do_gather(int p, int l, int r, int nl, int nr, int k){ if(T[p].maxv \u0026lt; k) return {};//最大容量都满足不了 //l==r说明是单点 nr\u0026gt;=r\u0026amp;\u0026amp;nl\u0026lt;=l说明满足区间要求 找到解了 if(l==r \u0026amp;\u0026amp; nr\u0026gt;=r \u0026amp;\u0026amp; nl\u0026lt;=l){ vector\u0026lt;int\u0026gt; res(2,0); res[0] = l-1; res[1] = m-T[p].maxv; T[p].maxv -= k;//修改 T[p].sum -= k; return res; } vector\u0026lt;int\u0026gt; ans; int mid=(l+r)\u0026gt;\u0026gt;1; //要么往左子树走要么往右子树走，直到叶子节点为止 //如果左子树够的话，肯定先往左子树走；否则往右子树走 if(T[ls(p)].maxv\u0026gt;=k \u0026amp;\u0026amp; nl\u0026lt;=mid) ans = do_gather(ls(p),l,mid,nl,nr,k); else if(T[rs(p)].maxv\u0026gt;=k \u0026amp;\u0026amp; nr\u0026gt;mid) ans = do_gather(rs(p),mid+1,r,nl,nr,k); push_up(p); return ans; } //scatter 在[nl,nr]区间内查询sum是否大于等于k //如果满足条件，设最后一个人在的位置为(row,col)，进行更新 //则[1,row-1]区间内的剩余座位为0，[row,row]区间内剩余座位 减人数 bool do_scatter(int p, int l, int r, int nl, int nr, int k){ if(T[p].sum\u0026lt;k) return false;//区间内总剩余座位数不够 if(l==r \u0026amp;\u0026amp; nr\u0026gt;=r \u0026amp;\u0026amp; nl\u0026lt;=l){//该排坐k个人，单点更新 T[p].sum -= k; T[p].maxv = T[p].sum; return true; } int mid=(l+r)\u0026gt;\u0026gt;1; //看左子树的总剩余座位数够不够，优先往左子树坐人 int left = min(T[ls(p)].sum, 1ll*k);//左子树容纳的人数 k -= left;//减去左子树的座位，如果有多的则要去右子树 bool res = true; //左子树不够，还要去右子树，如果加上右子树还不够，返回false if(k\u0026gt;0) { if(nr\u0026lt;=mid) res=false;//往右子树走需满足 nr\u0026gt;mid if(!res) return false; res = res \u0026amp;\u0026amp; do_scatter(rs(p),mid+1,r,nl,nr,k); } if(!res) return false; //不需要用到右子树，判断左子树是否够 if(nl\u0026lt;=mid) res = res \u0026amp;\u0026amp; do_scatter(ls(p),l,mid,nl,nr,left); push_up(p); return res; } BookMyShow(int n, int m) { this-\u0026gt;n = n; this-\u0026gt;m = m; build(1,1,n); } vector\u0026lt;int\u0026gt; gather(int k, int maxRow) { return do_gather(1,1,n,1,maxRow+1,k); } bool scatter(int k, int maxRow) { return do_scatter(1,1,n,1,maxRow+1,k); } }; /** * Your BookMyShow object will be instantiated and called as such: * BookMyShow* obj = new BookMyShow(n, m); * vector\u0026lt;int\u0026gt; param_1 = obj-\u0026gt;gather(k,maxRow); * bool param_2 = obj-\u0026gt;scatter(k,maxRow); */ ","date":"2022-05-31T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC79%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220531_hu1039696824626845607.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC79%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第79场双周赛总结"},{"content":"\n【模拟】字母在字符串中的百分比 题目 给你一个字符串 s 和一个字符 letter ，返回在 s 中等于 letter 字符所占的 百分比 ，向下取整到最接近的百分比。\n示例 1：\n1 2 3 4 输入：s = \u0026#34;foobar\u0026#34;, letter = \u0026#34;o\u0026#34; 输出：33 解释： 等于字母 \u0026#39;o\u0026#39; 的字符在 s 中占到的百分比是 2 / 6 * 100% = 33% ，向下取整，所以返回 33 。 示例 2：\n1 2 3 4 输入：s = \u0026#34;jjjj\u0026#34;, letter = \u0026#34;k\u0026#34; 输出：0 解释： 等于字母 \u0026#39;k\u0026#39; 的字符在 s 中占到的百分比是 0% ，所以返回 0 。 提示：\n1 \u0026lt;= s.length \u0026lt;= 100 s 由小写英文字母组成 letter 是一个小写英文字母 解题思路 按题意模拟即可。\n代码 1 2 3 4 5 6 7 8 9 class Solution { public: int percentageLetter(string s, char letter) { int n = s.size(); int cnt=0; for(auto \u0026amp;x: s) if(x==letter) cnt++; return (cnt*100/n); } }; 【贪心】装满石头的背包的最大数量 题目 现有编号从 0 到 n - 1 的 n 个背包。给你两个下标从 0 开始的整数数组 capacity 和 rocks 。第 i 个背包最大可以装 capacity[i] 块石头，当前已经装了 rocks[i] 块石头。另给你一个整数 additionalRocks ，表示你可以放置的额外石头数量，石头可以往 任意 背包中放置。\n请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的 最大 数量*。*\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2 输出：3 解释： 1 块石头放入背包 0 ，1 块石头放入背包 1 。 每个背包中的石头总数是 [2,3,4,4] 。 背包 0 、背包 1 和 背包 2 都装满石头。 总计 3 个背包装满石头，所以返回 3 。 可以证明不存在超过 3 个背包装满石头的情况。 注意，可能存在其他放置石头的方案同样能够得到 3 这个结果。 示例 2：\n1 2 3 4 5 6 7 8 9 输入：capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100 输出：3 解释： 8 块石头放入背包 0 ，2 块石头放入背包 2 。 每个背包中的石头总数是 [10,2,2] 。 背包 0 、背包 1 和背包 2 都装满石头。 总计 3 个背包装满石头，所以返回 3 。 可以证明不存在超过 3 个背包装满石头的情况。 注意，不必用完所有的额外石头。 提示：\nn == capacity.length == rocks.length 1 \u0026lt;= n \u0026lt;= 5 * 10^4 1 \u0026lt;= capacity[i] \u0026lt;= 10^9 0 \u0026lt;= rocks[i] \u0026lt;= capacity[i] 1 \u0026lt;= additionalRocks \u0026lt;= 10^9 解题思路 将剩余容量排序，从小往大填\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int maximumBags(vector\u0026lt;int\u0026gt;\u0026amp; capacity, vector\u0026lt;int\u0026gt;\u0026amp; rocks, int additionalRocks) { int n = capacity.size(); vector\u0026lt;int\u0026gt; a; for(int i=0;i\u0026lt;n;i++){ a.push_back(capacity[i]-rocks[i]); } sort(a.begin(),a.end()); int res = 0; for(auto \u0026amp;x: a){ if(x==0) res++; else{ additionalRocks -= x; if(additionalRocks\u0026gt;=0) res++; else break; } } return res; } }; 【枚举】表示一个折线图的最少线段数 题目 给你一个二维整数数组 stockPrices ，其中 stockPrices[i] = [dayi, pricei] 表示股票在 dayi 的价格为 pricei 。折线图 是一个二维平面上的若干个点组成的图，横坐标表示日期，纵坐标表示价格，折线图由相邻的点连接而成。比方说下图是一个例子：\n请你返回要表示一个折线图所需要的 最少线段数 。\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]] 输出：3 解释： 上图为输入对应的图，横坐标表示日期，纵坐标表示价格。 以下 3 个线段可以表示折线图： - 线段 1 （红色）从 (1,7) 到 (4,4) ，经过 (1,7) ，(2,6) ，(3,5) 和 (4,4) 。 - 线段 2 （蓝色）从 (4,4) 到 (5,4) 。 - 线段 3 （绿色）从 (5,4) 到 (8,1) ，经过 (5,4) ，(6,3) ，(7,2) 和 (8,1) 。 可以证明，无法用少于 3 条线段表示这个折线图。 示例 2：\n1 2 3 4 输入：stockPrices = [[3,4],[1,2],[7,8],[2,3]] 输出：1 解释： 如上图所示，折线图可以用一条线段表示。 提示：\n1 \u0026lt;= stockPrices.length \u0026lt;= 105 stockPrices[i].length == 2 1 \u0026lt;= dayi, pricei \u0026lt;= 109 所有 dayi 互不相同 。 解题思路 这题真的醉了，一开始用斜率判断是否三点贡献，最后有两个测试用例过不了，WA了两发才知道是精度问题\n以后涉及到除法的，小心精度问题\n枚举一遍就行了，我写成了动规的形式\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: bool isok(vector\u0026lt;int\u0026gt; \u0026amp;a, vector\u0026lt;int\u0026gt; \u0026amp;b, vector\u0026lt;int\u0026gt; \u0026amp;c){//是否三点共线 if(c[1]==b[1] \u0026amp;\u0026amp; b[1]==a[1]) return true; // if(1.00*(c[1]-b[1])/(1.00*(c[0]-b[0]))==1.00*(b[1]-a[1])/(1.00*(b[0]-a[0]))) return true; // else return false; long long x = 1ll*(c[0]-b[0])*(b[1]-a[1]); long long y = 1ll*(c[1]-b[1])*(b[0]-a[0]); return x==y; } int minimumLines(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; stockPrices) { int n = stockPrices.size(); if(n==1) return 0; if(n==2) return 1; sort(stockPrices.begin(), stockPrices.end()); // cout\u0026lt;\u0026lt;isok(stockPrices[2],stockPrices[3],stockPrices[4]); vector\u0026lt;int\u0026gt; dp(n,0); dp[0] = 0; dp[1] = 1; for(int i=2;i\u0026lt;n;i++){ if(isok(stockPrices[i-2],stockPrices[i-1],stockPrices[i])) dp[i] = dp[i-1]; else dp[i] = dp[i-1]+1; } return dp[n-1]; } }; 【计算贡献+单调栈+前缀和】巫师的总力量和 题目 作为国王的统治者，你有一支巫师军队听你指挥。\n给你一个下标从 0 开始的整数数组 strength ，其中 strength[i] 表示第 i 位巫师的力量值。对于连续的一组巫师（也就是这些巫师的力量值是 strength 的 子数组），总力量 定义为以下两个值的 乘积 ：\n巫师中 最弱 的能力值。\n组中所有巫师的个人力量值 之和 。\n请你返回 所有 巫师组的 总 力量之和。由于答案可能很大，请将答案对 10^9 + 7 取余 后返回。\n子数组 是一个数组里 非空 连续子序列。\n示例 1：\n输入：strength = [1,3,1,2] 输出：44 解释：以下是所有连续巫师组：\n[1,3,1,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1 [1,3,1,2] 中 [3] ，总力量值为 min([3]) * sum([3]) = 3 * 3 = 9 [1,3,1,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1 [1,3,1,2] 中 [2] ，总力量值为 min([2]) * sum([2]) = 2 * 2 = 4 [1,3,1,2] 中 [1,3] ，总力量值为 min([1,3]) * sum([1,3]) = 1 * 4 = 4 [1,3,1,2] 中 [3,1] ，总力量值为 min([3,1]) * sum([3,1]) = 1 * 4 = 4 [1,3,1,2] 中 [1,2] ，总力量值为 min([1,2]) * sum([1,2]) = 1 * 3 = 3 [1,3,1,2] 中 [1,3,1] ，总力量值为 min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5 [1,3,1,2] 中 [3,1,2] ，总力量值为 min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6 [1,3,1,2] 中 [1,3,1,2] ，总力量值为 min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7 所有力量值之和为 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44 。 示例 2： 输入：strength = [5,4,6] 输出：213 解释：以下是所有连续巫师组：\n[5,4,6] 中 [5] ，总力量值为 min([5]) * sum([5]) = 5 * 5 = 25 [5,4,6] 中 [4] ，总力量值为 min([4]) * sum([4]) = 4 * 4 = 16 [5,4,6] 中 [6] ，总力量值为 min([6]) * sum([6]) = 6 * 6 = 36 [5,4,6] 中 [5,4] ，总力量值为 min([5,4]) * sum([5,4]) = 4 * 9 = 36 [5,4,6] 中 [4,6] ，总力量值为 min([4,6]) * sum([4,6]) = 4 * 10 = 40 [5,4,6] 中 [5,4,6] ，总力量值为 min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60 所有力量值之和为 25 + 16 + 36 + 36 + 40 + 60 = 213 。 提示：\n1 \u0026lt;= strength.length \u0026lt;= 10^5\n1 \u0026lt;= strength[i] \u0026lt;= 10^9\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/sum-of-total-strength-of-wizards 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 一眼计算贡献，但之前做的都是按照动态规划的思路做的，比赛后发现这题推不了递推式，还是得采用计算单个元素的贡献范围以及贡献值。\n对于每个元素s[i]，找到其贡献范围[l, r]，为了避免相同元素重复计算贡献，注意L[i]和R[i]的含义\n注意取模，出现减法的话要加个MOD再模\n计算贡献的时候，这个表达式要敢于计算\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 const int MOD = 1e9+7; class Solution { public: int totalStrength(vector\u0026lt;int\u0026gt;\u0026amp; strength) { int n = strength.size(); if(n==1) return (1ll*strength[0]*strength[0])%MOD; vector\u0026lt;int\u0026gt; L(n,0);//L[i] 左侧小于等于s[i]的第一个位置 stack\u0026lt;int\u0026gt; stk; L[0]=-1; stk.push(0); for(int i=1;i\u0026lt;n;i++){ while(!stk.empty() \u0026amp;\u0026amp; strength[i]\u0026lt;strength[stk.top()]) stk.pop(); if(stk.empty()) L[i]=-1; else L[i]=stk.top(); stk.push(i); } vector\u0026lt;int\u0026gt; R(n,n);//R[i] 右侧小于s[i]的第一个位置 R[n-1]=n; while(!stk.empty()) stk.pop(); stk.push(n-1); for(int i=n-2;i\u0026gt;=0;i--){ while(!stk.empty() \u0026amp;\u0026amp; strength[i]\u0026lt;=strength[stk.top()]) stk.pop(); if(stk.empty()) R[i]=n; else R[i]=stk.top(); stk.push(i); } vector\u0026lt;long long\u0026gt; sum(n+1,0), psum(n+1,0); sum[0]=0;//前缀和 psum[0]=0;//前缀和的前缀和 for(int i=1;i\u0026lt;=n;i++){//注意和思路中表达式中 有偏移 sum[i] = (sum[i-1]+strength[i-1])%MOD; psum[i] = (psum[i-1]+sum[i])%MOD; } function\u0026lt;long long(int)\u0026gt; p = [\u0026amp;](int idx){ if(idx\u0026lt;=0) return 1ll*0; if(idx\u0026gt;=n+1) return psum[n]; return psum[idx]; }; long long res = 0; for(int i=0;i\u0026lt;n;i++){ int l = L[i]+1, r = R[i]-1; long long partI = (i-l+1)*(p(r+1)-p(i))%MOD; long long partII= (r-i+1)*(p(i)-p(l-1))%MOD; res = (res+strength[i]*(partI-partII)+MOD)%MOD; } return res; } }; ","date":"2022-05-23T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC294%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220523_hu4052301632059984521.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC294%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第294场周赛总结"},{"content":"分析清楚题意，弄清转移过程（是否需要其他辅助变量，是否需要用到前面的dp数组等）\n可以设状态，弄清状态转移\n可以增加维数，以限制条件\n买卖股票的最佳时机 题目 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n示例 1：\n输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2：\n输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。\n提示：\n1 \u0026lt;= prices.length \u0026lt;= 10^5 0 \u0026lt;= prices[i] \u0026lt;= 10^4\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\nDP version1 令dp[i]为第i天卖出能获得的最大利润\n初始化：dp[0] = 0，第i天卖出的话只能在第i天买入，不赚不亏\n考虑dp[i]，令p为今天卖出比昨天卖出新增的利润，可能为正，也可能为负，但归纳起来就3种情况，1）前一天卖出的最大利润+新增利润，表示在前i天买入的情况；2）dp[i]，即初始化的0，亏钱是不可能亏钱的；3）前一天买入，第i天卖出\n结果为转移过程中的最大值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if(n==1) return 0; vector\u0026lt;int\u0026gt; dp(n,0); //dp[i] 第i天卖出能获得的最大利润 dp[0] = 0; for(int i=1;i\u0026lt;n;i++){ int p = prices[i]-prices[i-1];//新增利润 dp[i]=max(dp[i-1]+p,max(dp[i],p)); } return *max_element(dp.begin(),dp.end()); } }; DP version2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if(n==1) return 0; int dp[n][2]; //dp[i][0] 前i天，且第i天未持有股票 的最大利润 //dp[i][1] 前i天，且第i天持有股票 的最大利润 int res = 0; dp[0][0] = 0; dp[0][1] = -prices[0]; for(int i=1;i\u0026lt;n;i++){ dp[i][0] = max(dp[i-1][1]+prices[i], dp[i-1][0]);//要么第i天卖出，要么不操作 dp[i][1] = max(-prices[i],dp[i-1][1]);//要么第i天买入，要么不操作 //写成下面这样是错误的，如果第i天买入，说明前i-1天都不能操作！所以是由-prices[i]转化而来 //因为dp[i-1][0]只说明了持不持有股票，但没记录交易了几次！题目中限制只能交易1次 // dp[i][1] = max(dp[i-1][0]-prices[i], dp[i-1][1]); } return dp[n-1][0]; } }; DP version3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if(n==1) return 0; int dp[n][2][2]; //dp[i][0][k] 前i天，且第i天未持有股票 的最大利润 已经交易了k次 //dp[i][1][k] 前i天，且第i天持有股票 的最大利润 已经交易了k次 int res = 0; dp[0][0][0] = 0, dp[0][0][1] = 0; dp[0][1][0] = -prices[0], dp[0][1][1] = -prices[0]; for(int i=1;i\u0026lt;n;i++){ dp[i][0][0] = 0; dp[i][0][1] = max(dp[i-1][1][0]+prices[i],dp[i-1][0][1]);//要么在第i天卖出，要么不操作 dp[i][1][0] = max(dp[i-1][0][0]-prices[i],dp[i-1][1][0]);//要么在第i天买入，要么不操作 dp[i][1][1] = max(dp[i-1][0][1]-prices[i],dp[i-1][1][1]);//要么在第i天卖出，要么不操作 } return dp[n-1][0][1]; } }; 贪心 只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。\n作者：LeetCode-Solution 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solution/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int inf = 1e9; int minprice = inf, maxprofit = 0; for (int price: prices) { maxprofit = max(maxprofit, price - minprice); minprice = min(price, minprice); } return maxprofit; } }; 买卖股票的最佳时机II 题目 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。\n在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。\n返回 你能获得的 最大 利润 。\n示例 1：\n输入：prices = [7,1,5,3,6,4] 输出：7 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。 总利润为 4 + 3 = 7 。 示例 2：\n输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 总利润为 4 。 示例 3：\n输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。\n提示：\n1 \u0026lt;= prices.length \u0026lt;= 3 * 10^4 0 \u0026lt;= prices[i] \u0026lt;= 10^4\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n贪心 这题虽然还是一次只能最多持有1支股票，但可交易多次。\n那只有将存在利润的地方都加起来即可。\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if(n==1) return 0; int res = 0; for(int i=1;i\u0026lt;n;i++){ res+=prices[i]\u0026gt;prices[i-1]?prices[i]-prices[i-1]:0; } return res; } }; DP 此处将上一题的version2小改一下即可\n因为取消了只能交易一次的限制\n计算第i天的情况，考虑前一天的情况：持有股票或不持有股票\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if(n==1) return 0; int dp[n][2]; //dp[i][0] 前i天，且第i天未持有一支股票的最大利润 //dp[i][1] 前i天，且第i天持有一支股票的最大利润 dp[0][0] = 0; dp[0][1] = -prices[0]; for(int i=1;i\u0026lt;n;i++){ dp[i][0] = max(dp[i-1][1]+prices[i], dp[i-1][0]); dp[i][1] = max(dp[i-1][0]-prices[i], dp[i-1][1]);//注意这里 } return dp[n-1][0]; } }; 买卖股票的最佳时机III 题目 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n示例 1:\n输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2：\n输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。\n因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3：\n输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。 示例 4：\n输入：prices = [1] 输出：0\n提示：\n1 \u0026lt;= prices.length \u0026lt;= 10^5 0 \u0026lt;= prices[i] \u0026lt;= 10^5\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\nDP version 1 交易一次，说明买入-卖出一次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if(n==1) return 0; int dp[n][2][3]; // memset(dp,0,sizeof(dp)); //dp[i][0][k] 前i天，且第i天未持有股票，已经交易了k次的最大利润 //dp[i][1][k] 前i天，且第i天持有股票，已经交易了k次的最大利润 dp[0][0][0]=0,dp[0][0][1]=0,dp[0][0][2]=0; dp[0][1][0]=-prices[0]; dp[0][1][1]=-prices[0]; dp[0][1][2]=-prices[0]; for(int i=1;i\u0026lt;n;i++){ dp[i][0][0] = 0; dp[i][0][1] = max(dp[i-1][1][0]+prices[i], dp[i-1][0][1]);//第i天卖出，交易次数加一；要么不操作 dp[i][0][2] = max(dp[i-1][1][1]+prices[i], dp[i-1][0][2]);//第i天卖出，交易次数加一；要么不操作 dp[i][1][0] = max(dp[i-1][0][0]-prices[i], dp[i-1][1][0]);//第i天买入，交易次数不变；要么不操作 dp[i][1][1] = max(dp[i-1][0][1]-prices[i], dp[i-1][1][1]);//第i天买入，交易次数不变，要么不操作 //下面这行其实用不到 dp[i][1][2] = max(dp[i-1][0][2]-prices[i], dp[i-1][1][2]);//第i天买入，交易次数不变，要么不操作 } return dp[n-1][0][2]; } }; DP version 2 上面这种写法好写一点，也可以提前想好状态。一天就5个状态：\n没有操作 第一次买入 第一次卖出 第二次买入 第二次卖出 令dp[i][j]表示前i天，且第i天的状态为j 的最大利润\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if(n==1) return 0; int dp[n][5]; //dp[i][j] 前i天 且第i天状态为j 的最大利润 dp[0][0]=0;//不操作 dp[0][1]=-prices[0];//第一次买入 dp[0][2]=0;//第一次卖出 dp[0][3]=-prices[0];//第二次买入 dp[0][4]=0;//第二次卖出 for(int i=1;i\u0026lt;n;i++){ dp[i][0] = 0; dp[i][1] = max(dp[i-1][0]-prices[i], dp[i-1][1]);//买入；不操作 dp[i][2] = max(dp[i-1][1]+prices[i], dp[i-1][2]);//卖出；不操作 dp[i][3] = max(dp[i-1][2]-prices[i], dp[i-1][3]);//买入，不操作 dp[i][4] = max(dp[i-1][3]+prices[i], dp[i-1][4]);//卖出，不操作 } return dp[n-1][4]; } }; 买卖股票的最佳时机IV 题目 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n示例 1：\n输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2：\n输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。\n提示：\n0 \u0026lt;= k \u0026lt;= 100 0 \u0026lt;= prices.length \u0026lt;= 1000 0 \u0026lt;= prices[i] \u0026lt;= 1000\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\nDP 和III思路是一样的，变成了最多可以交易k次。那么最终答案在dp[n-1][0][p]中选，其中p的范围是[0..k]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: int maxProfit(int k, vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if(k==0||n==0) return 0; int dp[n][2][k+1]; //dp[i][0][p] 前i天，且第i天未持有股票，已经交易了p次 //dp[i][1][p] 前i天，且第i天持有股票，已经交易了p次 for(int p=0;p\u0026lt;=k;p++) dp[0][0][p] = 0; for(int p=0;p\u0026lt;=k;p++) dp[0][1][p] = -prices[0]; for(int i=1;i\u0026lt;n;i++){ dp[i][0][0] = 0; dp[i][1][0] = max(dp[i-1][0][0]-prices[i], dp[i-1][1][0]); for(int p=1;p\u0026lt;=k;p++){ dp[i][0][p]=max(dp[i-1][1][p-1]+prices[i],dp[i-1][0][p]); dp[i][1][p]=max(dp[i-1][0][p]-prices[i], dp[i-1][1][p]); } } int res=0; for(int p=0;p\u0026lt;=k;p++){ res=max(res,dp[n-1][0][p]); } return res; } }; 最佳买卖股票时机含冷冻期 题目 给定一个整数数组prices，其中第 prices[i] 表示第 i 天的股票价格 。\n设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n示例 1:\n输入: prices = [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 示例 2:\n输入: prices = [1] 输出: 0\n提示：\n1 \u0026lt;= prices.length \u0026lt;= 5000 0 \u0026lt;= prices[i] \u0026lt;= 1000\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\nDP version1 初看是有打家劫舍那味儿的\n卖出股票后，无法在第二天买入股票 (即冷冻期为 1 天)。说明买入股票时，不能由前一天未持有股票时转移过来，而应该由前两天未持有股票时转移过来（因为有冷冻期，此时不考虑前1天的不就行了嘛）。\n但i-2，会出现负坐标，所以拆开来写。\ni\u0026gt;=2时，下标合法，就那样写就行\ni\u0026lt;2时，此时将dp[-1][0]当作0即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if(n==1) return 0; int dp[n][2]; //dp[i][0] 前i天，且第i天不持有股票 的最大利润 //dp[i][1] 前i天，且第i天持有股票 的最大利润 dp[0][0] = 0; dp[0][1] = -prices[0]; for(int i=1;i\u0026lt;n;i++){ dp[i][0] = max(dp[i-1][1]+prices[i],dp[i-1][0]); if(i\u0026gt;=2) dp[i][1]=max(dp[i-2][0]-prices[i],dp[i-1][1]); else dp[i][1]=max(-prices[i],dp[i-1][1]); } return dp[n-1][0]; } }; DP version2 考虑状态\n每天分为三种状态：\n0.手上没有股票且不处于冷冻期的最大收益\n1.手上没有股票但处于冷冻期的最大收益\n2.手上有股票的最大收益\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if(n == 1) return 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(3)); dp[0][0] = 0; //手上没有股票且不处于冷冻期的最大收益 dp[0][1] = 0; //手上没有股票但处于冷冻期的最大收益 dp[0][2] = - prices[0]; //手上有股票的最大收益 for(int i = 1; i \u0026lt; n; i ++) { dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]); //手上没有股票说明前一天没有或者前一天处于冷冻期 dp[i][1] = dp[i - 1][2] + prices[i]; dp[i][2] = max(dp[i - 1][2], dp[i - 1][0] - prices[i]); } return max(dp[n - 1][0], dp[n - 1][1]); } }; 买卖股票的最佳时机含手续费 题目 给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。\n你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。\n返回获得利润的最大值。\n注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。\n示例 1：\n输入：prices = [1, 3, 2, 8, 4, 9], fee = 2 输出：8 解释：能够达到的最大利润:\n在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8 示例 2：\n输入：prices = [1,3,7,5,10,3], fee = 3 输出：6\n提示：\n1 \u0026lt;= prices.length \u0026lt;= 5 * 10^4 1 \u0026lt;= prices[i] \u0026lt; 5 * 10^4 0 \u0026lt;= fee \u0026lt; 5 * 10^4\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\nDP version1 和II类似，注意支付手续费就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices, int fee) { int n = prices.size(); if(n==1) return 0; int dp[n][2]; //dp[i][0] 前i天，且第i天未持有股票 的最大利润 //dp[i][1] 前i天，且第i天持有股票 的最大利润 dp[0][0]=0; dp[0][1]=-prices[0]; for(int i=1;i\u0026lt;n;i++){ dp[i][0] = max(dp[i-1][1]+prices[i]-fee, dp[i-1][0]); dp[i][1] = max(dp[i-1][0]-prices[i], dp[i-1][1]); } return dp[n-1][0]; } }; ","date":"2022-05-19T00:00:00Z","image":"https://tetsuou.github.io/p/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/post-bg-20220519_hu856904171358879548.png","permalink":"https://tetsuou.github.io/p/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/","title":"买卖股票"},{"content":"\n第一次AK力扣周赛，上大分了。继上次双周赛刷新最好名次后，周赛再度刷新。\n【模拟】移除字母异位词后的结果数组 题目 给你一个下标从 0 开始的字符串 words ，其中 words[i] 由小写英文字符组成。\n在一步操作中，需要选出任一下标 i ，从 words 中 删除 words[i] 。其中下标 i 需要同时满足下述两个条件：\n0 \u0026lt; i \u0026lt; words.length words[i - 1] 和 words[i] 是 字母异位词 。 只要可以选出满足条件的下标，就一直执行这个操作。\n在执行所有操作后，返回 words 。可以证明，按任意顺序为每步操作选择下标都会得到相同的结果。\n字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。例如，\u0026quot;dacb\u0026quot; 是 \u0026quot;abdc\u0026quot; 的一个字母异位词。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 输入：words = [\u0026#34;abba\u0026#34;,\u0026#34;baba\u0026#34;,\u0026#34;bbaa\u0026#34;,\u0026#34;cd\u0026#34;,\u0026#34;cd\u0026#34;] 输出：[\u0026#34;abba\u0026#34;,\u0026#34;cd\u0026#34;] 解释： 获取结果数组的方法之一是执行下述步骤： - 由于 words[2] = \u0026#34;bbaa\u0026#34; 和 words[1] = \u0026#34;baba\u0026#34; 是字母异位词，选择下标 2 并删除 words[2] 。 现在 words = [\u0026#34;abba\u0026#34;,\u0026#34;baba\u0026#34;,\u0026#34;cd\u0026#34;,\u0026#34;cd\u0026#34;] 。 - 由于 words[1] = \u0026#34;baba\u0026#34; 和 words[0] = \u0026#34;abba\u0026#34; 是字母异位词，选择下标 1 并删除 words[1] 。 现在 words = [\u0026#34;abba\u0026#34;,\u0026#34;cd\u0026#34;,\u0026#34;cd\u0026#34;] 。 - 由于 words[2] = \u0026#34;cd\u0026#34; 和 words[1] = \u0026#34;cd\u0026#34; 是字母异位词，选择下标 2 并删除 words[2] 。 现在 words = [\u0026#34;abba\u0026#34;,\u0026#34;cd\u0026#34;] 。 无法再执行任何操作，所以 [\u0026#34;abba\u0026#34;,\u0026#34;cd\u0026#34;] 是最终答案。 示例 2：\n1 2 3 4 输入：words = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;,\u0026#34;e\u0026#34;] 输出：[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;,\u0026#34;e\u0026#34;] 解释： words 中不存在互为字母异位词的两个相邻字符串，所以无需执行任何操作。 提示：\n1 \u0026lt;= words.length \u0026lt;= 100 1 \u0026lt;= words[i].length \u0026lt;= 10 words[i] 由小写英文字母组成 解题思路 按题意模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: bool isok(string\u0026amp; a, string\u0026amp; b){//判断是否是字母异位词 if(a.size()!=b.size()) return false; map\u0026lt;char,int\u0026gt; ma,mb; for(auto \u0026amp;x: a) ma[x]++; for(auto \u0026amp;x: b) mb[x]++; return ma==mb; } vector\u0026lt;string\u0026gt; removeAnagrams(vector\u0026lt;string\u0026gt;\u0026amp; words) { int n = words.size(); if(n==1) return words; vector\u0026lt;bool\u0026gt; del(n,0); vector\u0026lt;string\u0026gt; res; for(int i=1;i\u0026lt;n;i++){ if(isok(words[i-1],words[i])) del[i]=1; } for(int i=0;i\u0026lt;n;i++){ if(!del[i]) res.push_back(words[i]); } return res; } }; 【排序】不含特殊楼层的最大连续楼层数 题目 Alice 管理着一家公司，并租用大楼的部分楼层作为办公空间。Alice 决定将一些楼层作为 特殊楼层 ，仅用于放松。\n给你两个整数 bottom 和 top ，表示 Alice 租用了从 bottom 到 top（含 bottom 和 top 在内）的所有楼层。另给你一个整数数组 special ，其中 special[i] 表示 Alice 指定用于放松的特殊楼层。\n返回不含特殊楼层的 最大 连续楼层数。\n示例 1：\n1 2 3 4 5 6 7 输入：bottom = 2, top = 9, special = [4,6] 输出：3 解释：下面列出的是不含特殊楼层的连续楼层范围： - (2, 3) ，楼层数为 2 。 - (5, 5) ，楼层数为 1 。 - (7, 9) ，楼层数为 3 。 因此，返回最大连续楼层数 3 。 示例 2：\n1 2 3 输入：bottom = 6, top = 8, special = [7,6,8] 输出：0 解释：每层楼都被规划为特殊楼层，所以返回 0 。 提示\n1 \u0026lt;= special.length \u0026lt;= 10^5 1 \u0026lt;= bottom \u0026lt;= special[i] \u0026lt;= top \u0026lt;= 10^9 special 中的所有值 互不相同 解题思路 将special数组排序后，遍历一遍找最大连续层数即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int maxConsecutive(int bottom, int top, vector\u0026lt;int\u0026gt;\u0026amp; special) { int n = special.size(); sort(special.begin(), special.end()); int res = special[0]-bottom; for(int i=1;i\u0026lt;n;i++){ res = max(res, special[i]-special[i-1]-1); } res = max(res, top-special[n-1]); return res; } }; 【枚举】按位与结果大于零的最长组合 题目 对数组 nums 执行 按位与 相当于对数组 nums 中的所有整数执行 按位与 。\n例如，对 nums = [1, 5, 3] 来说，按位与等于 1 \u0026amp; 5 \u0026amp; 3 = 1 。 同样，对 nums = [7] 而言，按位与等于 7 。 给你一个正整数数组 candidates 。计算 candidates 中的数字每种组合下 按位与 的结果。 candidates 中的每个数字在每种组合中只能使用 一次 。\n返回按位与结果大于 0 的 最长 组合的长度*。*\n示例 1：\n1 2 3 4 5 6 7 输入：candidates = [16,17,71,62,12,24,14] 输出：4 解释：组合 [16,17,62,24] 的按位与结果是 16 \u0026amp; 17 \u0026amp; 62 \u0026amp; 24 = 16 \u0026gt; 0 。 组合长度是 4 。 可以证明不存在按位与结果大于 0 且长度大于 4 的组合。 注意，符合长度最大的组合可能不止一种。 例如，组合 [62,12,24,14] 的按位与结果是 62 \u0026amp; 12 \u0026amp; 24 \u0026amp; 14 = 8 \u0026gt; 0 。 示例 2：\n1 2 3 4 输入：candidates = [8,8] 输出：2 解释：最长组合是 [8,8] ，按位与结果 8 \u0026amp; 8 = 8 \u0026gt; 0 。 组合长度是 2 ，所以返回 2 。 提示：\n1 \u0026lt;= candidates.length \u0026lt;= 10^5 1 \u0026lt;= candidates[i] \u0026lt;= 10^7 解题思路 看完题后第一时间还没想好思路，但看了下一开始通过率高的吓人，就冷静下来想了一下\n如果考虑每一种数字组合的话，复杂度会过高，不可能的。换个角度想\n按位与结果最后要大于0，说明它们的与运算结果的二进制表示中至少有1位不能为0\n由于数的范围是10^7，没有超过int，那么最多可以考虑32位，枚举每一位，使得该位不为0，为了数字组合长度最长，只要不使得该位按位与运算后变为0，那么可以尽量的将数字选进来。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int largestCombination(vector\u0026lt;int\u0026gt;\u0026amp; candidates) { int n = candidates.size(); int res=0; for(int i=0;i\u0026lt;32;i++){//枚举第i位不为0 int cur=0; for(auto \u0026amp;x: candidates){ if((x\u0026gt;\u0026gt;i)\u0026amp;1) cur++;//只要第i位不为0，就将其组合起来 } res=max(res,cur); } return res; } }; 【动态开点线段树】统计区间中的整数数目 题目 给你区间的 空 集，请你设计并实现满足要求的数据结构：\n新增：添加一个区间到这个区间集合中。 统计：计算出现在 至少一个 区间中的整数个数。 实现 CountIntervals 类：\nCountIntervals() 使用区间的空集初始化对象 void add(int left, int right) 添加区间 [left, right] 到区间集合之中。 int count() 返回出现在 至少一个 区间中的整数个数。 注意：区间 [left, right] 表示满足 left \u0026lt;= x \u0026lt;= right 的所有整数 x 。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 输入 [\u0026#34;CountIntervals\u0026#34;, \u0026#34;add\u0026#34;, \u0026#34;add\u0026#34;, \u0026#34;count\u0026#34;, \u0026#34;add\u0026#34;, \u0026#34;count\u0026#34;] [[], [2, 3], [7, 10], [], [5, 8], []] 输出 [null, null, null, 6, null, 8] 解释 CountIntervals countIntervals = new CountIntervals(); // 用一个区间空集初始化对象 countIntervals.add(2, 3); // 将 [2, 3] 添加到区间集合中 countIntervals.add(7, 10); // 将 [7, 10] 添加到区间集合中 countIntervals.count(); // 返回 6 // 整数 2 和 3 出现在区间 [2, 3] 中 // 整数 7、8、9、10 出现在区间 [7, 10] 中 countIntervals.add(5, 8); // 将 [5, 8] 添加到区间集合中 countIntervals.count(); // 返回 8 // 整数 2 和 3 出现在区间 [2, 3] 中 // 整数 5 和 6 出现在区间 [5, 8] 中 // 整数 7 和 8 出现在区间 [5, 8] 和区间 [7, 10] 中 // 整数 9 和 10 出现在区间 [7, 10] 中 提示：\n1 \u0026lt;= left \u0026lt;= right \u0026lt;= 10^9 最多调用 add 和 count 方法 总计 10^5 次 调用 count 方法至少一次 动态开点线段树 读完题就鉴定为可以用线段树做。\n由于值域范围达10^9，但询问次数为10^5，所以采用动态开点线段树\n节点维护区间中整数数目即可。\n本来代码很快就码好了，但是忽略了对tot，root的初始化，并且一开始将它们放在了类里面，造成了奇奇怪怪的错误。找了好久才发现，然后将它们移到类外，并进行显示初始化。（如果不进行显示初始化是不行的，力扣可能会测试多组用例，后面再初始化需要重置才行）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 const int INF = 1e9+2; const int MAXM = 4e6+6; int tot,root; struct node{ int sum;//区间中整数的数目 int tag; int ls,rs; }T[MAXM]; class CountIntervals { public: int minv,maxv; void push_up(int \u0026amp;p){ T[p].sum = T[T[p].ls].sum + T[T[p].rs].sum; } void push_down(int \u0026amp;p, int l, int r){ if(!T[p].tag) return; if(!T[p].ls){ T[p].ls=++tot; T[T[p].ls] = {0,0,0,0}; } if(!T[p].rs){ T[p].rs=++tot; T[T[p].rs] = {0,0,0,0}; } int mid=(l+r)\u0026gt;\u0026gt;1; T[T[p].ls].tag+=T[p].tag; T[T[p].rs].tag+=T[p].tag; T[T[p].ls].sum=(mid-l+1); T[T[p].rs].sum=r-mid; T[p].tag=0; } void update(int \u0026amp;p, int l, int r, int nl, int nr, int k){ if(!p){ p=++tot; T[p]={0,0,0,0}; } if(nl\u0026lt;=l\u0026amp;\u0026amp;nr\u0026gt;=r){ T[p].sum = r-l+1; T[p].tag = 1; return; } int mid = (l+r)\u0026gt;\u0026gt;1; push_down(p,l,r); if(nl\u0026lt;=mid) update(T[p].ls,l,mid,nl,nr,k); if(nr\u0026gt;mid) update(T[p].rs,mid+1,r,nl,nr,k); push_up(p); } int query(int p, int l, int r, int nl, int nr){ if(nl\u0026lt;=l\u0026amp;\u0026amp;nr\u0026gt;=r) return T[p].sum; push_down(p,l,r); int res=0,mid=(l+r)\u0026gt;\u0026gt;1; if(nl\u0026lt;=mid) res+=query(T[p].ls,l,mid,nl,nr); if(nr\u0026gt;mid) res+=query(T[p].rs,mid+1,r,nl,nr); return res; } CountIntervals() { minv=0,maxv=INF; tot=0,root=0; } void add(int left, int right) { update(root,1,INF,left,right,1); minv=min(minv,left); maxv=max(maxv,right); } int count() { return query(root,1,INF,minv,maxv); } }; /** * Your CountIntervals object will be instantiated and called as such: * CountIntervals* obj = new CountIntervals(); * obj-\u0026gt;add(left,right); * int param_2 = obj-\u0026gt;count(); */ 模拟 求区间并集 求区间并集模板题。用一个 set 有序地维护所有不相交的区间，当加入区间 [left, right] 时，通过 lower_bound 快速找到第一个右端点大于等于 left - 1 的区间，然后不断用接下来的区间和 [left, right] 合并，直到当前区间的左端点大于 right + 1。由于每个区间只会加入以及离开 set 一次，复杂度O(nlogn)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class CountIntervals { typedef pair\u0026lt;int, int\u0026gt; pii;//first：右端点 second：左端点 int ans = 0; set\u0026lt;pii\u0026gt; st; public: CountIntervals() { } void add(int left, int right) { int L = left, R = right; auto it = st.lower_bound(pii(left - 1, -2e9));//在旧区间中找到第一个右端点大于等于新加入区间left-1的区间索引 while (it != st.end()) {//找到了，开始合并 if (it-\u0026gt;second \u0026gt; right + 1) break; L = min(L, it-\u0026gt;second); R = max(R, it-\u0026gt;first); ans -= it-\u0026gt;first - it-\u0026gt;second + 1; st.erase(it++); } ans += R - L + 1; st.insert(pii(R, L)); } int count() { return ans; } }; /** * Your CountIntervals object will be instantiated and called as such: * CountIntervals* obj = new CountIntervals(); * obj-\u0026gt;add(left,right); * int param_2 = obj-\u0026gt;count(); */ // 作者：TsReaper // 链接：https://leetcode.cn/circle/discuss/sKLBSg/ // 来源：力扣（LeetCode） // 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2022-05-17T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC293%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220517_hu12244678109667973804.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC293%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第293场周赛总结"},{"content":"\n上大分上大分，刷新个人最好排名（虽然后面周赛又刷新了）\n5/18更新：不知怎么的，排名上升了。最好排名再度刷新。\n【模拟】找到一个数字的 K 美丽值 题目 一个整数 num 的 k 美丽值定义为 num 中符合以下条件的 子字符串 数目：\n子字符串长度为 k 。 子字符串能整除 num 。 给你整数 num 和 k ，请你返回 num 的 k 美丽值。\n注意：\n允许有 前缀 0 。 0 不能整除任何值。 一个 子字符串 是一个字符串里的连续一段字符序列。\n示例 1：\n1 2 3 4 5 6 输入：num = 240, k = 2 输出：2 解释：以下是 num 里长度为 k 的子字符串： - \u0026#34;240\u0026#34; 中的 \u0026#34;24\u0026#34; ：24 能整除 240 。 - \u0026#34;240\u0026#34; 中的 \u0026#34;40\u0026#34; ：40 能整除 240 。 所以，k 美丽值为 2 。 示例 2：\n1 2 3 4 5 6 7 8 9 输入：num = 430043, k = 2 输出：2 解释：以下是 num 里长度为 k 的子字符串： - \u0026#34;430043\u0026#34; 中的 \u0026#34;43\u0026#34; ：43 能整除 430043 。 - \u0026#34;430043\u0026#34; 中的 \u0026#34;30\u0026#34; ：30 不能整除 430043 。 - \u0026#34;430043\u0026#34; 中的 \u0026#34;00\u0026#34; ：0 不能整除 430043 。 - \u0026#34;430043\u0026#34; 中的 \u0026#34;04\u0026#34; ：4 不能整除 430043 。 - \u0026#34;430043\u0026#34; 中的 \u0026#34;43\u0026#34; ：43 能整除 430043 。 所以，k 美丽值为 2 。 提示：\n1 \u0026lt;= num \u0026lt;= 10^9 1 \u0026lt;= k \u0026lt;= num.length （将 num 视为字符串） 解题思路 按题意模拟即可。\n这次用着to_string和stoi函数，写代码提速不少\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int divisorSubstrings(int num, int k) { string str = to_string(num); int n = str.size(), res = 0; for(int i=0;i+k\u0026lt;=n;i++){ int cur = stoi(str.substr(i,k)); if(cur==0) continue; if(num%cur==0) res++; } return res; } }; 【枚举+前缀和】分割数组的方案数 题目 给你一个下标从 0 开始长度为 n 的整数数组 nums 。 如果以下描述为真，那么 nums 在下标 i 处有一个 合法的分割 ：\n前 i + 1 个元素的和 大于等于 剩下的 n - i - 1 个元素的和。 下标 i 的右边 至少有一个 元素，也就是说下标 i 满足 0 \u0026lt;= i \u0026lt; n - 1 。 请你返回 nums 中的 合法分割 方案数。\n示例 1：\n1 2 3 4 5 6 7 8 输入：nums = [10,4,-8,7] 输出：2 解释： 总共有 3 种不同的方案可以将 nums 分割成两个非空的部分： - 在下标 0 处分割 nums 。那么第一部分为 [10] ，和为 10 。第二部分为 [4,-8,7] ，和为 3 。因为 10 \u0026gt;= 3 ，所以 i = 0 是一个合法的分割。 - 在下标 1 处分割 nums 。那么第一部分为 [10,4] ，和为 14 。第二部分为 [-8,7] ，和为 -1 。因为 14 \u0026gt;= -1 ，所以 i = 1 是一个合法的分割。 - 在下标 2 处分割 nums 。那么第一部分为 [10,4,-8] ，和为 6 。第二部分为 [7] ，和为 7 。因为 6 \u0026lt; 7 ，所以 i = 2 不是一个合法的分割。 所以 nums 中总共合法分割方案受为 2 。 示例 2：\n1 2 3 4 5 6 输入：nums = [2,3,1,0] 输出：2 解释： 总共有 2 种 nums 的合法分割： - 在下标 1 处分割 nums 。那么第一部分为 [2,3] ，和为 5 。第二部分为 [1,0] ，和为 1 。因为 5 \u0026gt;= 1 ，所以 i = 1 是一个合法的分割。 - 在下标 2 处分割 nums 。那么第一部分为 [2,3,1] ，和为 6 。第二部分为 [0] ，和为 0 。因为 6 \u0026gt;= 0 ，所以 i = 2 是一个合法的分割。 提示：\n2 \u0026lt;= nums.length \u0026lt;= 10^5 -105 \u0026lt;= nums[i] \u0026lt;= 10^5 解题思路 预先计算好前缀和，计算判断即可\n注意数据范围，可能超int。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int waysToSplitArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;long long\u0026gt; sum(n+1,0); for(int i=1;i\u0026lt;=n;i++){ sum[i] = sum[i-1]+nums[i-1]; } int res = 0; for(int i=1;i\u0026lt;n;i++){ if(sum[i]\u0026gt;=sum[n]-sum[i]) res++; } return res; } }; 【动态开点线段树】毯子覆盖的最多白色砖块数 题目 给你一个二维整数数组 tiles ，其中 tiles[i] = [li, ri] ，表示所有在 li \u0026lt;= j \u0026lt;= ri 之间的每个瓷砖位置 j 都被涂成了白色。\n同时给你一个整数 carpetLen ，表示可以放在 任何位置 的一块毯子。\n请你返回使用这块毯子，最多 可以盖住多少块瓷砖。\n示例 1：\n1 2 3 4 5 6 输入：tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10 输出：9 解释：将毯子从瓷砖 10 开始放置。 总共覆盖 9 块瓷砖，所以返回 9 。 注意可能有其他方案也可以覆盖 9 块瓷砖。 可以看出，瓷砖无法覆盖超过 9 块瓷砖。 示例 2：\n1 2 3 4 输入：tiles = [[10,11],[1,1]], carpetLen = 2 输出：2 解释：将毯子从瓷砖 10 开始放置。 总共覆盖 2 块瓷砖，所以我们返回 2 。 提示：\n1 \u0026lt;= tiles.length \u0026lt;= 5 * 10^4 tiles[i].length == 2 1 \u0026lt;= li \u0026lt;= ri \u0026lt;= 10^9 1 \u0026lt;= carpetLen \u0026lt;= 10^9 tiles 互相 不会重叠 。 解题思路 首先可以预处理判断是否存在长度大于等于毛毯长度的瓷砖区间，若存在，直接返回毛毯长度即可。\n更一般地，一个长度单位的毛毯最多覆盖一个长度单位的瓷砖，所以每次将毛毯的末尾对准瓷砖区间[l , r]的r（右端点），考虑此时毛毯的起始位置pos（\u0026gt;=1，r+1-carpetLen），如果pos\u0026gt;=l，即毛毯可以被瓷砖”填满“，答案为carpetLen（即上述预处理的情况）；如果pos\u0026lt;l，此时[pos, l-1]处有瓷砖就加上，答案为[pos, r]区间内的瓷砖个数（前一种也是这样）。\n其实也就可以看成一个区间修改，区间求和问题，注意到值域的范围达到了10^9，但询问次数范围为5*10^4，所以要采用动态开点线段树。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 const int MAXM = 4e6+6; const int INF = 1e9+5; class Solution { public: int tot,root; struct node{ int sum; int tag; int ls,rs; }T[MAXM]; void push_up(int\u0026amp; p){ T[p].sum = T[T[p].ls].sum + T[T[p].rs].sum; } void push_down(int \u0026amp;p, int l, int r){ if(!T[p].tag) return; if(!T[p].ls){ T[p].ls=++tot; T[T[p].ls]={0,0,0,0}; } if(!T[p].rs){ T[p].rs=++tot; T[T[p].rs]={0,0,0,0}; } int mid=(l+r)\u0026gt;\u0026gt;1; T[T[p].ls].tag+=T[p].tag; T[T[p].rs].tag+=T[p].tag; T[T[p].ls].sum += T[p].tag*(mid-l+1); T[T[p].rs].sum += T[p].tag*(r-mid); T[p].tag=0; } void update(int\u0026amp; p, int l, int r, int nl, int nr, int k){ if(!p){ p=++tot; T[p]={0,0,0,0}; } if(nl\u0026lt;=l \u0026amp;\u0026amp; nr\u0026gt;=r){ T[p].sum = k*(r-l+1); T[p].tag = k; return; } int mid=(l+r)\u0026gt;\u0026gt;1; push_down(p,l,r); if(nl\u0026lt;=mid) update(T[p].ls, l, mid,nl,nr,k); if(nr\u0026gt;mid) update(T[p].rs,mid+1,r,nl,nr,k); push_up(p); } int query(int p, int l, int r, int nl, int nr){ if(nl\u0026lt;=l\u0026amp;\u0026amp;nr\u0026gt;=r) return T[p].sum; long long res = 0; int mid = (l+r)\u0026gt;\u0026gt;1; push_down(p,l,r); if(nl\u0026lt;=mid) res+=query(T[p].ls,l,mid,nl,nr); if(nr\u0026gt;mid) res+=query(T[p].rs,mid+1,r,nl,nr); return res; } int maximumWhiteTiles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; tiles, int carpetLen) { tot=0,root=0; int maxlen=-1; for(auto \u0026amp;vec: tiles){ maxlen=max(maxlen,vec[1]-vec[0]+1); } if(maxlen\u0026gt;=carpetLen) return carpetLen; for(auto \u0026amp;vec: tiles){ update(root,1,INF,vec[0],vec[1],1); } for(auto \u0026amp;vec: tiles){ int r = vec[1]; int l = max(1,r+1-carpetLen); maxlen = max(maxlen, query(root,1,INF,l,r)); } return maxlen; } }; 贪心+滑动窗口 枚举毯子的左端点和哪组瓷砖的左端点一致，并通过滑动窗口维护此时毯子右边最多覆盖到哪组瓷砖，取最大值作为答案即可\n枚举第i组瓷砖的左端点，窗口左边界i表示第i组瓷砖，右边界j随着毯子能覆盖的范围而增加，维护一个变量now记录当前毯子能覆盖的瓷砖范围。\n毯子无法完全覆盖第j组瓷砖时，有两种情况，1）碰都碰不到第j组瓷砖，此时加上0；2）可以碰到，此时可以覆盖部分，长度为：毛毯此时右端点 tiles[i][0]+carpetLen-1，第j组子串左端点 tiles[j][0]，前者减后者再加1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int maximumWhiteTiles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; tiles, int carpetLen) { sort(tiles.begin(), tiles.end()); long long now = 0, ans = 0; for (int i = 0, j = 0; i \u0026lt; tiles.size(); i++) { while (j \u0026lt; tiles.size() \u0026amp;\u0026amp; tiles[j][1] + 1 - tiles[i][0] \u0026lt;= carpetLen) now += tiles[j][1] - tiles[j][0] + 1, j++; // 毯子无法完全覆盖第 j 组瓷砖 if (j \u0026lt; tiles.size()) ans = max(ans, now + max(0, tiles[i][0] + carpetLen - tiles[j][0])); // 毯子可以完全覆盖第 j 组瓷砖 else ans = max(ans, now); now -= tiles[i][1] - tiles[i][0] + 1;//减去第i组瓷砖 } return ans; } }; // 作者：TsReaper // 链接：https://leetcode.cn/circle/discuss/Mmxf4g/ // 来源：力扣（LeetCode） // 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 【枚举+动态规划】最大波动的子字符串 题目 字符串的 波动 定义为子字符串中出现次数 最多 的字符次数与出现次数 最少 的字符次数之差。\n给你一个字符串 s ，它只包含小写英文字母。请你返回 s 里所有 子字符串的 最大波动 值。\n子字符串 是一个字符串的一段连续字符序列。\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：s = \u0026#34;aababbb\u0026#34; 输出：3 解释： 所有可能的波动值和它们对应的子字符串如以下所示： - 波动值为 0 的子字符串：\u0026#34;a\u0026#34; ，\u0026#34;aa\u0026#34; ，\u0026#34;ab\u0026#34; ，\u0026#34;abab\u0026#34; ，\u0026#34;aababb\u0026#34; ，\u0026#34;ba\u0026#34; ，\u0026#34;b\u0026#34; ，\u0026#34;bb\u0026#34; 和 \u0026#34;bbb\u0026#34; 。 - 波动值为 1 的子字符串：\u0026#34;aab\u0026#34; ，\u0026#34;aba\u0026#34; ，\u0026#34;abb\u0026#34; ，\u0026#34;aabab\u0026#34; ，\u0026#34;ababb\u0026#34; ，\u0026#34;aababbb\u0026#34; 和 \u0026#34;bab\u0026#34; 。 - 波动值为 2 的子字符串：\u0026#34;aaba\u0026#34; ，\u0026#34;ababbb\u0026#34; ，\u0026#34;abbb\u0026#34; 和 \u0026#34;babb\u0026#34; 。 - 波动值为 3 的子字符串 \u0026#34;babbb\u0026#34; 。 所以，最大可能波动值为 3 。 示例 2：\n1 2 3 4 输入：s = \u0026#34;abcde\u0026#34; 输出：0 解释： s 中没有字母出现超过 1 次，所以 s 中每个子字符串的波动值都是 0 。 提示：\n1 \u0026lt;= s.length \u0026lt;= 10^4 s 只包含小写英文字母。 解题思路 这次双周赛交完第3题看排名是三百多，太兴奋了，看完第4题，想到用动态规划做，思考了一会儿无果就放弃了。\n结束后看题解，这个枚举就很灵性，妙！找出变化范围少的变量，枚举固定它，以更好地观察其他变化范围更大的变量。\n枚举出现次数最多的字符和出现次数最少的字符，出现最多的字符每个贡献1，出现最少的字符每个贡献-1，其他字符可以忽略（看作0即可），将原数组转换成1，0，-1的序列a，此时，问题就转换成了，求最大子序和了（且至少含有1和-1两种不同元素）。\n令dp[i]表示以a[i]结尾的最大子序和（即常规子序和），初始化dp[0]=a[0]，递归关系为dp[i]=(dp[i-1]+a[i], a[i])，最大的子序和为转移过程中的最大值。\n为了保证子字符串中存在两种以上（含）的字符，即转换后的子数组中至少含有1和-1两种不同元素，令dp2[i]表示以a[i]结尾且至少含一个元素-1的最大子序和。不用管含不含元素1，含了最好，不含的话最大子序和一定也大不过最优解。\n初始化dp2[0]要分情况讨论，如果a[0]=-1，满足条件，那么dp2[0]=a[0]；如果a[0]!=-1，那么不存在，令dp2[0]=-INF，其中-INF表示”无穷小“。\n转移过程：\n1 2 3 4 5 if(a[i]==-1){ dp2[i]=max(dp2[i-1]+a[i], max(dp[i-1]+a[i], a[i]));//第i个元素为-1，那么前i-1个可以含或者不含，取最大值 }else{ dp2[i]=dp2[i-1]+a[i];//只能寄希望于前i-1个元素含-1了 } 最后答案即为转移过程中的最大值\n最大子序和（至少含一个-1） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 const int INF = 0x3f3f3f3f; class Solution { public: int largestVariance(string s) { int n = s.size(); if(n==1) return 0; int res=0; int dp[n],dp2[n]; for(char high=\u0026#39;a\u0026#39;;high\u0026lt;=\u0026#39;z\u0026#39;;high++){//枚举出现最多字符次数 for(char low=\u0026#39;a\u0026#39;;low\u0026lt;=\u0026#39;z\u0026#39;;low++){//枚举出现最少字符次数 if(high==low) continue; //highchar = 1; lowchar = -1 memset(dp,0,sizeof(dp)); memset(dp2,0,sizeof(dp)); //dp[i]：以a[i]结尾的最大子数组和 //dp2[i]：以a[i]结尾且至少含一个-1的最大子数组和 int a0=(s[0]==high)?1:((s[0]==low)?-1:0); dp[0]=a0; dp2[0]=a0==-1?-1:-INF; for(int i=1;i\u0026lt;n;i++){ int v = (s[i]==high)?1:((s[i]==low)?-1:0);//a[i] dp[i] = max(dp[i-1]+v, v); if(v!=-1){ dp2[i]=dp2[i-1]+v; }else{ dp2[i]=max(dp[i-1]+v,max(dp2[i-1]+v,v)); } res = max(res, dp2[i]); } } } return res; } }; 空间优化 由于两个dp数组都只与前一个相关，因此可以省去第一维，进行空间优化，注意dp2会用到前一个的dp，所以dp后更改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 const int INF = 0x3f3f3f3f; class Solution { public: int largestVariance(string s) { int n = s.size(); if(n==1) return 0; int res=0; for(char high=\u0026#39;a\u0026#39;;high\u0026lt;=\u0026#39;z\u0026#39;;high++){//枚举出现最多字符次数 for(char low=\u0026#39;a\u0026#39;;low\u0026lt;=\u0026#39;z\u0026#39;;low++){//枚举出现最少字符次数 if(high==low) continue; //highchar = 1; lowchar = -1 int dp,dp2; int a0=(s[0]==high)?1:((s[0]==low)?-1:0); dp=a0; dp2=a0==-1?-1:-INF; for(int i=1;i\u0026lt;n;i++){ int v = (s[i]==high)?1:((s[i]==low)?-1:0); if(v!=-1){ dp2=dp2+v; }else{ dp2=max(dp+v,max(dp2+v,v)); } dp = max(dp+v, v); res = max(res, dp2); } } } return res; } }; 关于运行时间 最开始我在循环内将dp数组定义为vector，26*26次枚举的初始化，第一次提交超时了，因为vector初始化什么的太慢了，超时的那个数据规模为10^4。\n然后改成普通数组，并将其定义放到循环外，循环内用memset进行初始化，速度快了不少。\n以后涉及到多次数组初始化的话，还是避免使用vector吧，效率太低了。\n空间优化后，避免了多次数组的初始化，时间也得到了提升。\n常规动态规划 如果不从最大子序和的角度出发的话：\n设a为最多字符，b为最少字符。 dp[0]表示当前位置结尾的，连续a字符的数量 dp[1]表示当前位置结尾的最大波动值\n如果仅仅定义表示当前位置结尾的最大波动值的变量是不够的，还需要一个辅助计数的变量，考虑如果还没出现b的时候，应该存储什么呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: int largestVariance(string s) { int n = s.size(), ans = 0; for(char a = \u0026#39;a\u0026#39;; a \u0026lt;= \u0026#39;z\u0026#39;; ++a){ for(char b = \u0026#39;a\u0026#39;; b \u0026lt;= \u0026#39;z\u0026#39;; ++b){ if(a == b) continue; int dp[2]{0,-114514}; for(char c: s){ if(c == b) { dp[1] = max(dp[1] - 1, dp[0] - 1); dp[0] = 0; } else if(c == a){ ++dp[0], ++dp[1]; } ans = max(ans, dp[1]); } } } return ans; } }; 作者：MuriyaTensei 链接：https://leetcode.cn/problems/substring-with-largest-variance/solution/c-dong-tai-gui-hua-by-muriyatensei-nuux/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2022-05-16T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC78%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220516_hu1394424372917765525.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC78%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第78场双周赛总结"},{"content":"前言 完全背包和01背包的区别在于完全背包问题种的物品可以拿多次，而不是只能拿0或1次\n1 2 3 dp[i][j] = max(dp[i-1][j],dp[i-1][j-k*v[i]]+k*w[i])//0\u0026lt;k*v[i]\u0026lt;=j (k\u0026gt;=1,k\u0026lt;=j/v[i]) = max(dp[i-1][j],dp[i][j-v[i]]+w[i]) dp[j] = max(dp[j],dp[j-v[i]]+w[i]) //维度消除 -\u0026gt; 常规解法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public int maxValue(int N, int C, int[] v, int[] w) { int[][] dp = new int[N][C + 1]; // 先预处理第一件物品 for (int j = 0; j \u0026lt;= C; j++) { // 显然当只有一件物品的时候，在容量允许的情况下，能选多少件就选多少件 int maxK = j / v[0]; dp[0][j] = maxK * w[0]; } // 处理剩余物品 for (int i = 1; i \u0026lt; N; i++) { for (int j = 0; j \u0026lt;= C; j++) { // 不考虑第 i 件物品的情况（选择 0 件物品 i） int n = dp[i - 1][j]; // 考虑第 i 件物品的情况 int y = 0; for (int k = 1 ;; k++) { if (j \u0026lt; v[i] * k) { break; } y = Math.max(y, dp[i - 1][j - k * v[i]] + k * w[i]); } dp[i][j] = Math.max(n, y); } } return dp[N - 1][C]; } } 滚动数组，和01背包类似。\n空间优化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int maxValue(int N, int C, int[] v, int[] w) { int[] dp = new int[C + 1]; for (int i = 0; i \u0026lt; N; i++) { for (int j = 0; j \u0026lt;= C; j++) { // 不考虑第 i 件物品的情况（选择 0 件物品 i） int n = dp[j]; // 考虑第 i 件物品的情况 int y = j - v[i] \u0026gt;= 0 ? dp[j - v[i]] + w[i] : 0; dp[j] = Math.max(n, y); } } return dp[C]; } } 形式上，我们只需要将 01 背包问题的「一维空间优化」解法中的「容量维度」遍历方向从「从大到小 改为 从小到大」就可以解决完全背包问题。\n但本质是因为两者进行状态转移时依赖了不同的格子：\n01 背包依赖的是「上一行正上方的格子」和「上一行左边的格子」。 完全背包依赖的是「上一行正上方的格子」和「本行左边的格子」。 我们可以发现通过「一维空间优化」方式，可以将求解「完全背包」问题的时间复杂度从O(N*C*C)降为O(N*C)\n参考自https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==\u0026amp;mid=2247486107\u0026amp;idx=1\u0026amp;sn=e5fa523008fc5588737b7ed801caf4c3\n【完全背包组合问题】零钱兑换II 题目 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。\n请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。\n假设每一种面额的硬币有无限个。\n题目数据保证结果符合 32 位带符号整数。\n示例 1：\n输入：amount = 5, coins = [1, 2, 5] 输出：4 解释：有四种方式可以凑成总金额： 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 示例 2：\n输入：amount = 3, coins = [2] 输出：0 解释：只用面额 2 的硬币不能凑成总金额 3 。 示例 3：\n输入：amount = 10, coins = [10] 输出：1\n提示：\n1 \u0026lt;= coins.length \u0026lt;= 300\n1 \u0026lt;= coins[i] \u0026lt;= 5000\ncoins 中的所有值 互不相同\n0 \u0026lt;= amount \u0026lt;= 5000\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/coin-change-2 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 转化为完全背包问题\n求组合数\n令dp[i,j]表示前i种面额硬币能凑成总金额为j的方案数\n初始化：\n1 2 for(int j=0;j\u0026lt;=amount;j++) if(j%coins[0]==0) dp[0][j]=1; 考虑第i种面额硬币，可以不选，可以选1，2，\u0026hellip;，k张\n1 2 3 4 5 6 7 8 for(int i=1;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;=amount;j++){ dp[i][j] = dp[i-1][j];//不使用第i种 for(int k=1;j-k*coins[i]\u0026gt;=0;k++){//使用k张第i种 dp[i][j] += dp[i-1][j-k*coins[i]]; } } } 最后结果为dp[n-1,amount]\n代码1.0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int change(int amount, vector\u0026lt;int\u0026gt;\u0026amp; coins) { int n = coins.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n,vector\u0026lt;int\u0026gt;(amount+1,0)); //dp[i][j] 前i种面额硬币能凑成总金额为j的方案数 for(int j=0;j\u0026lt;=amount;j++) if(j%coins[0]==0) dp[0][j]=1; for(int i=1;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;=amount;j++){ dp[i][j] = dp[i-1][j];//不使用第i种 for(int k=1;j-k*coins[i]\u0026gt;=0;k++){//使用k张第i种 dp[i][j] += dp[i-1][j-k*coins[i]]; } } } return dp[n-1][amount]; } }; 代码2.0 消除重复计算\n1 2 3 dp[i][j-v[i]] = dp[i-1][j-v[i]]+dp[i-1][j-2*v[i]]+...+dp[i-1][j-k*v[i]] dp[i][j] = dp[i-1][j]+dp[i-1][j-v[i]]+...+dp[i-1][j-k*v[i]] = dp[i-1][j] + dp[i][j-v[i]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int change(int amount, vector\u0026lt;int\u0026gt;\u0026amp; coins) { int n = coins.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n,vector\u0026lt;int\u0026gt;(amount+1,0)); //dp[i][j] 前i种面额硬币能凑成总金额为j的方案数 for(int j=0;j\u0026lt;=amount;j++) if(j%coins[0]==0) dp[0][j]=1; for(int i=1;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;=amount;j++){ dp[i][j] = dp[i-1][j];//不使用第i种 if(j\u0026gt;=coins[i]) dp[i][j] += dp[i][j-coins[i]];//使用第i种 } } return dp[n-1][amount]; } }; 代码3.0（空间优化） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int change(int amount, vector\u0026lt;int\u0026gt;\u0026amp; coins) { int n = coins.size(); vector\u0026lt;int\u0026gt; dp(amount+1,0); //dp[j] 能凑成总金额为j的方案数 dp[0] = 1; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;=amount;j++){ if(j\u0026gt;=coins[i]) dp[j] += dp[j-coins[i]]; } } return dp[amount]; } }; 【完全背包最值问题】零钱兑换 题目 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。\n计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。\n你可以认为每种硬币的数量是无限的。\n示例 1：\n输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 示例 2：\n输入：coins = [2], amount = 3 输出：-1 示例 3：\n输入：coins = [1], amount = 0 输出：0\n提示：\n1 \u0026lt;= coins.length \u0026lt;= 12\n1 \u0026lt;= coins[i] \u0026lt;= 2^31 - 1\n0 \u0026lt;= amount \u0026lt;= 10^4\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/coin-change 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 转换为完全背包问题\n令dp[i, j]表示前i种硬币凑成j所需的最少硬币个数\n初始化：\n1 2 3 for(int j=0;j\u0026lt;=amount;j++){ if(j%coins[0]==0) dp[0][j]=j/coins[0]; }//其余值都设为极大值 状态转移：\n1 2 3 4 5 6 for(int i=1;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;=amount;j++){ dp[i][j] = min(dp[i][j],dp[i-1][j]);//不选第i种 if(j\u0026gt;=coins[i]) dp[i][j]=min(dp[i][j],dp[i][j-coins[i]]+1);//选第i种 } } 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const int INF = 0x3f3f3f3f; class Solution { public: int coinChange(vector\u0026lt;int\u0026gt;\u0026amp; coins, int amount) { int n = coins.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n,vector\u0026lt;int\u0026gt;(amount+1,INF)); //dp[i][j]前i种硬币凑成j所需的最少硬币个数 for(int j=0;j\u0026lt;=amount;j++){ if(j%coins[0]==0) dp[0][j]=j/coins[0]; } for(int i=1;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;=amount;j++){ dp[i][j] = min(dp[i][j],dp[i-1][j]); if(j\u0026gt;=coins[i]) dp[i][j]=min(dp[i][j],dp[i][j-coins[i]]+1); } } if(dp[n-1][amount]==INF) return -1; else return dp[n-1][amount]; } }; 空间优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const int INF = 0x3f3f3f3f; class Solution { public: int coinChange(vector\u0026lt;int\u0026gt;\u0026amp; coins, int amount) { int n = coins.size(); vector\u0026lt;int\u0026gt; dp(amount+1,INF); //dp[j] 凑成j所需的最少硬币个数 for(int j=0;j\u0026lt;=amount;j++){ if(j%coins[0]==0) dp[j]=j/coins[0]; } for(int i=1;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;=amount;j++){ if(j\u0026gt;=coins[i]) dp[j]=min(dp[j],dp[j-coins[i]]+1); } } if(dp[amount]==INF) return -1; else return dp[amount]; } }; 【完全背包排列问题】组合总和Ⅳ 题目 给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。\n题目数据保证答案符合 32 位整数范围。\n示例 1：\n输入：nums = [1,2,3], target = 4 输出：7 解释： 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。 示例 2：\n输入：nums = [9], target = 3 输出：0\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 200\n1 \u0026lt;= nums[i] \u0026lt;= 1000\nnums 中的所有元素 互不相同\n1 \u0026lt;= target \u0026lt;= 1000\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/combination-sum-iv 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n常规动态规划 在零钱兑换II问题种，可以用完全背包来求组合数，但这题求的是排列数。\n二维的完全背包不好直接用来求排列数，但空间优化后的完全背包小小改动一下就可用来求排列数，等下再提。\n以另外一种角度来定义dp数组\n令dp[i, j] 长度为i 和为j 的排列数\n初始化，显然dp[0, 0]=1，即没选数时和为0，就1种方案\n转移方程：\n对任意的dp[i, j]，考虑末尾的数，这个末尾的数可以是nums[0]，此时需加上dp[i-1, j-nums[0]]的方案数；也可以是nums[1]，此时需加上dp[i-1, j-nums[1]]的方案数。。。\n最后结果即是dp[i, targen]，其中i的范围是[1, len]，其中len表示最长排列的长度\n注意到求方案数什么的，方案数可能很大，除非题目说明，不然注意数据溢出，这题用long long 也会溢出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #define ull unsigned long long class Solution { public: int combinationSum4(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int len=target; vector\u0026lt;vector\u0026lt;ull\u0026gt;\u0026gt; dp(len+1,vector\u0026lt;ull\u0026gt;(target+1,0)); //dp[i][j] 长度为i 和为j 的排列数 dp[0][0] = 1; int res = 0; for(int i=1;i\u0026lt;=len;i++){ for(int j=0;j\u0026lt;=target;j++){ for(auto \u0026amp;x:nums){ if(j\u0026gt;=x) dp[i][j]+=dp[i-1][j-x]; } } res+=dp[i][target]; } return res; } }; 完全背包求排列数 如果求组合数就是外层for循环遍历物品，内层for遍历背包。\n如果求排列数就是外层for遍历背包，内层for循环遍历物品。\n（代码随想录中给的推论，这是建立在空间优化后一维数组的情况，二维经此题测试不适用）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #define ull unsigned long long class Solution { public: int combinationSum4(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); vector\u0026lt;ull\u0026gt; dp(target+1,0); //dp[i] 总和为i的排列数 dp[0]=1; for(int j=0;j\u0026lt;=target;j++){//先遍历背包 for(int i=0;i\u0026lt;n;i++){//再遍历物品 if(j\u0026gt;=nums[i]) dp[j] += dp[j-nums[i]]; } } return dp[target]; } }; 理解起来可以参考上一条\n即总和为i的排列数dp[i]，最后一个数可以选择nums[0]、nums[1]\u0026hellip;如果可以的话\n那么dp[i]的方案数就是dp[i-nums[0]]+dp[i-nums[1]]+\u0026hellip;如果可以的话\n【完全背包最值问题】完全平方数 题目 给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。\n完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\n示例 1：\n输入：n = 12 输出：3 解释：12 = 4 + 4 + 4 示例 2：\n输入：n = 13 输出：2 解释：13 = 4 + 9\n提示：\n1 \u0026lt;= n \u0026lt;= 10^4\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/perfect-squares 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 转化问题：从可选则的完全平方数中，选出最小个数使得其和为n\n和零钱兑换那题思路是一样的\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int numSquares(int n) { vector\u0026lt;int\u0026gt; v;//容量数组 for(int i=1;i*i\u0026lt;=n;i++){ v.push_back(i*i); } int len=v.size();//len件物品 int V=n;//容量限制 vector\u0026lt;int\u0026gt; dp(n+1); //dp[i] 和为i 的完全平方数的最少数量 for(int j=0;j\u0026lt;=V;j++){ dp[j]=j/v[0]; } for(int i=1;i\u0026lt;len;i++){ for(int j=0;j\u0026lt;=V;j++){ if(j\u0026gt;=v[i]) dp[j]=min(dp[j],dp[j-v[i]]+1); } } return dp[n]; } }; 【完全背包存在问题】单词拆分 题目 给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。\n注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。\n示例 1：\n输入: s = \u0026ldquo;leetcode\u0026rdquo;, wordDict = [\u0026ldquo;leet\u0026rdquo;, \u0026ldquo;code\u0026rdquo;] 输出: true 解释: 返回 true 因为 \u0026ldquo;leetcode\u0026rdquo; 可以由 \u0026ldquo;leet\u0026rdquo; 和 \u0026ldquo;code\u0026rdquo; 拼接成。 示例 2：\n输入: s = \u0026ldquo;applepenapple\u0026rdquo;, wordDict = [\u0026ldquo;apple\u0026rdquo;, \u0026ldquo;pen\u0026rdquo;] 输出: true 解释: 返回 true 因为 \u0026ldquo;applepenapple\u0026rdquo; 可以由 \u0026ldquo;apple\u0026rdquo; \u0026ldquo;pen\u0026rdquo; \u0026ldquo;apple\u0026rdquo; 拼接成。 注意，你可以重复使用字典中的单词。 示例 3：\n输入: s = \u0026ldquo;catsandog\u0026rdquo;, wordDict = [\u0026ldquo;cats\u0026rdquo;, \u0026ldquo;dog\u0026rdquo;, \u0026ldquo;sand\u0026rdquo;, \u0026ldquo;and\u0026rdquo;, \u0026ldquo;cat\u0026rdquo;] 输出: false\n提示：\n1 \u0026lt;= s.length \u0026lt;= 300\n1 \u0026lt;= wordDict.length \u0026lt;= 1000\n1 \u0026lt;= wordDict[i].length \u0026lt;= 20\ns 和 wordDict[i] 仅有小写英文字母组成\nwordDict 中的所有字符串 互不相同\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/word-break 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 物品：字典中的字符串\n背包：字符串s\n每个单词可以重复选择，所以是完全背包。但感觉也不是标准的完全背包。\n一开始将字典中字符串看做物品是没问题的，然后将字符串s看做背包的限制，一直在思考如果合理地表示状态，如何转移，思索无果\n竟是要直接将字符串s看做背包，而不是像数字那样看成背包的容量\n令dp[i]表示字符串s的前i位（不含）是否可由字典中的字符串列表拼接得出\n初始化：dp[0]=true（字符串为空的话，应该是可以的）\n状态转移：dp[i] = dp[i] | ( dp[j] \u0026amp; check(j,i) )，其中check(j+1,i)表示判断子字符串s[j+1, i]是否是字典中的字符串\n最后结果即是dp[s.size()]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: bool wordBreak(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { unordered_set\u0026lt;string\u0026gt; tab(wordDict.begin(),wordDict.end()); int n = s.size(); vector\u0026lt;bool\u0026gt; dp(n+1,false); //dp[i] 前i位（不含）是否可由字典中的单词拼接而来 dp[0]=true; for(int i=1;i\u0026lt;=n;i++){ for(int j=0;j\u0026lt;i;j++){//子字符串的起始位置 string subs = s.substr(j,i-j); bool cur=false; if(tab.count(subs)) { cur=true \u0026amp; dp[j]; } dp[i]=dp[i]|cur; } } return dp[n]; } }; 这里顺便记下substr的时间复杂度：\nUnspecified, but generally linear in the length of the returned object.\n","date":"2022-05-13T00:00:00Z","image":"https://tetsuou.github.io/p/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/post-bg-20220513_hu16966806979706445251.png","permalink":"https://tetsuou.github.io/p/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/","title":"完全背包"},{"content":"前言 最基本的01背包：\n「01背包」是指给定物品价值与体积（对应了「给定价值与成本」），在规定容量下（对应了「限定决策规则」）如何使得所选物品的总价值最大。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int maxValue(int N, int C, int[] v, int[] w) { int[][] dp = new int[N][C+1]; // 先处理「考虑第一件物品」的情况 for (int i = 0; i \u0026lt;= C; i++) { dp[0][i] = i \u0026gt;= v[0] ? w[0] : 0; } // 再处理「考虑其余物品」的情况 for (int i = 1; i \u0026lt; N; i++) { for (int j = 0; j \u0026lt; C + 1; j++) { // 不选该物品 int n = dp[i-1][j]; // 选择该物品，前提「剩余容量」大于等于「物品体积」 int y = j \u0026gt;= v[i] ? dp[i-1][j-v[i]] + w[i] : 0; dp[i][j] = Math.max(n, y); } } return dp[N-1][C]; } } 滚动数组版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int maxValue(int N, int C, int[] v, int[] w) { int[][] dp = new int[2][C+1]; // 先处理「考虑第一件物品」的情况 for (int i = 0; i \u0026lt; C + 1; i++) { dp[0][i] = i \u0026gt;= v[0] ? w[0] : 0; } // 再处理「考虑其余物品」的情况 for (int i = 1; i \u0026lt; N; i++) { for (int j = 0; j \u0026lt; C + 1; j++) { // 不选该物品 int n = dp[(i-1)\u0026amp;1][j]; // 选择该物品 int y = j \u0026gt;= v[i] ? dp[(i-1)\u0026amp;1][j-v[i]] + w[i] : 0; dp[i\u0026amp;1][j] = Math.max(n, y); } } return dp[(N-1)\u0026amp;1][C]; } } 一维数组版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int maxValue(int N, int C, int[] v, int[] w) { int[] dp = new int[C + 1]; for (int i = 0; i \u0026lt; N; i++) { for (int j = C; j \u0026gt;= v[i]; j--) {//从大往小 // 不选该物品 int n = dp[j]; // 选择该物品 int y = dp[j-v[i]] + w[i]; dp[j] = Math.max(n, y); } } return dp[C]; } } 参考自https://mp.weixin.qq.com/s/xmgK7SrTnFIM3Owpk-emmg\n就是决策第i种物品选不选\n【01背包存在问题】分割等和子集 题目 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n示例 1：\n输入：nums = [1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。 示例 2：\n输入：nums = [1,2,3,5] 输出：false 解释：数组不能分割成两个元素和相等的子集。\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 200\n1 \u0026lt;= nums[i] \u0026lt;= 100\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/partition-equal-subset-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 令sum为数组总和，原问题可转化为是否可以找出子序列，使得其和为sum/2（可预先判断sum是否为偶数）\n进一步地，可转换为01背包问题，能否在背包容量为sum/2的前提下装满背包，与普通的01背包的区别在于这里的物品价值与体积是一致的。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: bool canPartition(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n=nums.size(); int sum=0,maxv=*max_element(nums.begin(),nums.end()); for(auto \u0026amp;x:nums) sum+=x; if(sum\u0026amp;1 || maxv\u0026gt;sum/2) return false; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n,vector\u0026lt;int\u0026gt;(sum/2+1,0)); //dp[i][j] 前i个数不超过j的最大和 //如果有dp[i][sum/2]=sum/2说明可以分割出等和子集 for(int j=0;j\u0026lt;=sum/2;j++){ if(j\u0026gt;=nums[0]) dp[0][nums[0]]=nums[0]; } for(int i=1;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;=sum/2;j++){ if(j-nums[i]\u0026gt;=0) dp[i][j]=max(dp[i-1][j],dp[i-1][j-nums[i]]+nums[i]); else dp[i][j]=dp[i-1][j]; } } if(dp[n-1][sum/2]==sum/2) return true; else return false; } }; 也可以这样写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: bool canPartition(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if(n==1) return false; int sum=0; for(auto \u0026amp;x:nums) sum+=x; if(sum\u0026amp;1) return false; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n,vector\u0026lt;int\u0026gt;(sum+1,0)); //dp[i][j] nums[0..i]中是否可以加起来等于j for(int i=0;i\u0026lt;n;i++){ dp[i][0] = 0; } dp[0][nums[0]] = 1; for(int i=1;i\u0026lt;n;i++){ for(int j=1;j\u0026lt;sum/2+1;j++){ if(nums[i]\u0026gt;j) dp[i][j] = dp[i-1][j]; else dp[i][j] = dp[i-1][j]|dp[i-1][j-nums[i]]; } } return dp[n-1][sum/2]; } }; 【01背包最值问题】最后一块石头的重量II 题目 有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。\n每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x \u0026lt;= y。那么粉碎的可能结果如下：\n如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。\n示例 1：\n输入：stones = [2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。 示例 2：\n输入：stones = [31,26,33,21,40] 输出：5\n提示：\n1 \u0026lt;= stones.length \u0026lt;= 30\n1 \u0026lt;= stones[i] \u0026lt;= 100\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/last-stone-weight-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 任意选i块石头，使得他们的重量趋近于总重量的一半，因为这样和另一半抵消的差值就是最小的\n从而转化为01背包问题\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int lastStoneWeightII(vector\u0026lt;int\u0026gt;\u0026amp; stones) { int n = stones.size(), sum = 0; for(auto \u0026amp;x:stones) sum+=x; int target = sum/2; vector\u0026lt;int\u0026gt; dp(target+1,0); for(int i=0;i\u0026lt;n;i++){ for(int j=target;j\u0026gt;=stones[i];--j){ dp[j] = max(dp[j],dp[j-stones[i]]+stones[i]); } } //dp[target] 背包容量为target的最大石头重量 return abs(sum-dp[target]-dp[target]); } }; 【01背包组合问题】目标和 题目 给你一个整数数组 nums 和一个整数 target 。\n向数组中的每个整数前添加 \u0026lsquo;+\u0026rsquo; 或 \u0026lsquo;-\u0026rsquo; ，然后串联起所有整数，可以构造一个 表达式 ：\n例如，nums = [2, 1] ，可以在 2 之前添加 \u0026lsquo;+\u0026rsquo; ，在 1 之前添加 \u0026lsquo;-\u0026rsquo; ，然后串联起来得到表达式 \u0026ldquo;+2-1\u0026rdquo; 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。\n示例 1：\n输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3 示例 2：\n输入：nums = [1], target = 1 输出：1\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 20\n0 \u0026lt;= nums[i] \u0026lt;= 1000\n0 \u0026lt;= sum(nums[i]) \u0026lt;= 1000\n-1000 \u0026lt;= target \u0026lt;= 1000\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/target-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 原数组需要分为两部分：负数部分neg 和 非负数部分pos，再令原数组总和为sum，由题意有：\npos+neg=target;\npos-neg=sum;\n去掉pos，联立可得neg=(target-sum)/2 （注意，这里求得的neg是带符号的）\n因此原问题转化成了 在原数组中找出子序列的和等于-neg（使其变为非负数，后用neg代替）的方案数\n首先预处理判断neg的合法性，然后进行动态规划\n和普通01背包的定义不同，这里定义dp[i,j]表示前i个（不包括第i个）数中子序列的和等于j的方案数\n有两个不同的点：1）第一维不包括第i个；2）第二维表示刚好等于j，而不是不超过j\n这是为了方便表示什么都没选的时候，也是一种方案\n初始化dp[0,0]=1，dp[0,y]=0(y\u0026gt;0)，表示哪个数都没选时，子序列和和只可能等于0且只有1种方案。\n转移方程：\n1 2 3 4 5 6 for(int i=1;i\u0026lt;=n;i++){ for(int j=0;j\u0026lt;=neg;j++){ if(j-nums[i-1]\u0026gt;=0) dp[i][j]=dp[i-1][j]+dp[i-1][j-nums[i-1]];//可以选第i-1个数，选中的方案数+不选的方案数 else dp[i][j]=dp[i-1][j];//选不了第i-1个数 } } 最后结果即为dp[n,neg]\n其实第一维还是可以像原来背包那样，定义dp[i,j]表示前i个（包括第i个）数中子序列的和等于j的方案数\n但初始化要改一下：\n1 2 3 //dp[i][j] 前i个数总和为j的方案数 dp[0][0]=1; dp[0][nums[0]]=nums[0]==0?2:1; 即第0个数也有选还是不选两种情况，不选的话，和为0，即dp[0,0]=1；如果选，不能简单的令dp[0, nums[0]]=1，因为此时nums[0]可能等于0，选或不选是不同的方案。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int findTargetSumWays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(), sum=0; for(auto \u0026amp;x:nums) sum+=x; if(sum\u0026lt;target||(target-sum)\u0026amp;1) return 0; int neg = -(target-sum)/2; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n+1,vector\u0026lt;int\u0026gt;(neg+1,0)); // cout\u0026lt;\u0026lt;neg\u0026lt;\u0026lt;endl; //dp[i][j] 前i-1个数总和为j的方案数 dp[0][0]=1; for(int i=1;i\u0026lt;=n;i++){ for(int j=0;j\u0026lt;=neg;j++){ if(j-nums[i-1]\u0026gt;=0) dp[i][j]=dp[i-1][j]+dp[i-1][j-nums[i-1]]; else dp[i][j]=dp[i-1][j]; } } return dp[n][neg]; } }; 或者\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int findTargetSumWays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(), sum=0; for(auto \u0026amp;x:nums) sum+=x; if(sum\u0026lt;target||(target-sum)\u0026amp;1) return 0; int neg = -(target-sum)/2; //这里将第2维拓展到了最大值，是为了避免后面赋值dp[0][nums[0]]越界 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n,vector\u0026lt;int\u0026gt;(1001,0)); // cout\u0026lt;\u0026lt;neg\u0026lt;\u0026lt;endl; //dp[i][j] 前i个数总和为j的方案数 dp[0][0]=1; dp[0][nums[0]]=nums[0]==0?2:1; for(int i=1;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;=neg;j++){ if(j-nums[i]\u0026gt;=0) dp[i][j]=dp[i-1][j]+dp[i-1][j-nums[i]]; else dp[i][j]=dp[i-1][j]; } } return dp[n-1][neg]; } }; 空间优化 01背包空间优化，内循环变为从大到小\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int findTargetSumWays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(), sum=0; for(auto \u0026amp;x:nums) sum+=x; if(sum\u0026lt;target||(target-sum)\u0026amp;1) return 0; int neg = -(target-sum)/2; vector\u0026lt;int\u0026gt; dp(neg+1,0); // cout\u0026lt;\u0026lt;neg\u0026lt;\u0026lt;endl; //dp[j] 总和为j的方案数 dp[0]=1; for(int i=1;i\u0026lt;=n;i++){ for(int j=neg;j\u0026gt;=nums[i-1];j--){ dp[j]+=dp[j-nums[i-1]]; } } return dp[neg]; } }; 【01二维费用背包最值问题】一和零 题目 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。\n请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。\n如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。\n示例 1：\n输入：strs = [\u0026ldquo;10\u0026rdquo;, \u0026ldquo;0001\u0026rdquo;, \u0026ldquo;111001\u0026rdquo;, \u0026ldquo;1\u0026rdquo;, \u0026ldquo;0\u0026rdquo;], m = 5, n = 3 输出：4 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {\u0026ldquo;10\u0026rdquo;,\u0026ldquo;0001\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;} ，因此答案是 4 。 其他满足题意但较小的子集包括 {\u0026ldquo;0001\u0026rdquo;,\u0026ldquo;1\u0026rdquo;} 和 {\u0026ldquo;10\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;} 。{\u0026ldquo;111001\u0026rdquo;} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。 示例 2：\n输入：strs = [\u0026ldquo;10\u0026rdquo;, \u0026ldquo;0\u0026rdquo;, \u0026ldquo;1\u0026rdquo;], m = 1, n = 1 输出：2 解释：最大的子集是 {\u0026ldquo;0\u0026rdquo;, \u0026ldquo;1\u0026rdquo;} ，所以答案是 2 。\n提示：\n1 \u0026lt;= strs.length \u0026lt;= 600\n1 \u0026lt;= strs[i].length \u0026lt;= 100\nstrs[i] 仅由 \u0026lsquo;0\u0026rsquo; 和 \u0026lsquo;1\u0026rsquo; 组成\n1 \u0026lt;= m, n \u0026lt;= 100\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/ones-and-zeroes 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 要将此问题转换为背包问题，需要抽象出【价值】与【容量】\n每个字符串的【价值】都是1，而【容量】对应的则是0的总数量以及1的总数量。\n和普通01背包受到单维度容量限制不同，此题容量限制有两个维度，0的总数量和1的总数量，所以定义dp数组时需要考虑到\n定义dp[i,j,k]表示前i个字符串（物品）中0的总数量不超过j，1的总数量不超过k的最大子集长度\n初始化：\n1 2 3 4 5 6 for(int j=0;j\u0026lt;=m;j++){ for(int k=0;k\u0026lt;=n;k++){ if(j\u0026gt;=zero[0]\u0026amp;\u0026amp;k\u0026gt;=one[0]) dp[0][j][k]=1; } } 转移方程：\n1 2 3 4 5 6 7 8 9 for(int i=1;i\u0026lt;len;i++){ for(int j=0;j\u0026lt;=m;j++){ for(int k=0;k\u0026lt;=n;k++){ if(j\u0026gt;=zero[i] \u0026amp;\u0026amp; k\u0026gt;=one[i]) dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-zero[i]][k-one[i]]+1); else dp[i][j][k]=dp[i-1][j][k]; } } } 最后结果即为dp[len-1, m, n]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public: int findMaxForm(vector\u0026lt;string\u0026gt;\u0026amp; strs, int m, int n) { int len=strs.size(); int dp[len][m+1][n+1]; //dp[i][j][k] 前i个字符串中，0的个数不大于m，1的个数不大于0 的最多字符串个数 memset(dp,0,sizeof(dp)); //每个字符串中0和1的个数 vector\u0026lt;int\u0026gt; zero,one; for(auto \u0026amp;str: strs){ int le = str.size(),cnt=0; for(auto \u0026amp;ch: str){ if(ch==\u0026#39;0\u0026#39;) cnt++; } zero.push_back(cnt); one.push_back(le-cnt); } //初始化 for(int j=0;j\u0026lt;=m;j++){ for(int k=0;k\u0026lt;=n;k++){ if(j\u0026gt;=zero[0]\u0026amp;\u0026amp;k\u0026gt;=one[0]) dp[0][j][k]=1; } } for(int i=1;i\u0026lt;len;i++){ for(int j=0;j\u0026lt;=m;j++){ for(int k=0;k\u0026lt;=n;k++){ if(j\u0026gt;=zero[i] \u0026amp;\u0026amp; k\u0026gt;=one[i]) dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-zero[i]][k-one[i]]+1); else dp[i][j][k]=dp[i-1][j][k]; } } } return dp[len-1][m][n]; } }; 为了避免对初始化的分类讨论，可以假设添加一个空字符串到最前面\n此时dp[i,j,k]表示前i-1个\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: int findMaxForm(vector\u0026lt;string\u0026gt;\u0026amp; strs, int m, int n) { int len=strs.size(); int dp[len+1][m+1][n+1]; //dp[i][j][k] 前i-1个字符串中，0的个数不大于m，1的个数不大于0 的最多字符串个数 memset(dp,0,sizeof(dp)); vector\u0026lt;int\u0026gt; zero,one; for(auto \u0026amp;str: strs){ int le = str.size(),cnt=0; for(auto \u0026amp;ch: str){ if(ch==\u0026#39;0\u0026#39;) cnt++; } zero.push_back(cnt); one.push_back(le-cnt); } for(int i=1;i\u0026lt;=len;i++){ for(int j=0;j\u0026lt;=m;j++){ for(int k=0;k\u0026lt;=n;k++){ if(j\u0026gt;=zero[i-1] \u0026amp;\u0026amp; k\u0026gt;=one[i-1]) dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-zero[i-1]][k-one[i-1]]+1); else dp[i][j][k]=dp[i-1][j][k]; } } } return dp[len][m][n]; } }; 空间优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: int findMaxForm(vector\u0026lt;string\u0026gt;\u0026amp; strs, int m, int n) { int len=strs.size(); int dp[m+1][n+1]; //[j][k] 0的个数不大于m，1的个数不大于0 的最多字符串个数 memset(dp,0,sizeof(dp)); vector\u0026lt;int\u0026gt; zero,one; for(auto \u0026amp;str: strs){ int le = str.size(),cnt=0; for(auto \u0026amp;ch: str){ if(ch==\u0026#39;0\u0026#39;) cnt++; } zero.push_back(cnt); one.push_back(le-cnt); } //每个字符串中0和1的个数 for(int j=0;j\u0026lt;=m;j++){ for(int k=0;k\u0026lt;=n;k++){ if(j\u0026gt;=zero[0]\u0026amp;\u0026amp;k\u0026gt;=one[0]) dp[j][k]=1; } } for(int i=1;i\u0026lt;len;i++){ for(int j=m;j\u0026gt;=zero[i];j--){ for(int k=n;k\u0026gt;=one[i];k--){ dp[j][k]=max(dp[j][k],dp[j-zero[i]][k-one[i]]+1); } } } return dp[m][n]; } }; 【01二维费用背包组合问题】盈利计划 题目 集团里有 n 名员工，他们可以完成各种各样的工作创造利润。\n第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。\n工作的任何至少产生 minProfit 利润的子集称为 盈利计划 。并且工作的成员总数最多为 n 。\n有多少种计划可以选择？因为答案很大，所以 返回结果模 10^9 + 7 的值。\n示例 1：\n输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3] 输出：2 解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。 总的来说，有两种计划。 示例 2：\n输入：n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8] 输出：7 解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。 有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。\n提示：\n1 \u0026lt;= n \u0026lt;= 100\n0 \u0026lt;= minProfit \u0026lt;= 100\n1 \u0026lt;= group.length \u0026lt;= 100\n1 \u0026lt;= group[i] \u0026lt;= 100\nprofit.length == group.length\n0 \u0026lt;= profit[i] \u0026lt;= 100\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/profitable-schemes 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 令dp[i,j,k] 表示前i项工作，人数不超过j，利润至少为k的总方案数\n这题也有两个约束，一个是人数，一个是利润，但其中的利润又不是绝对性的限制\n这种组合问题的初始化有点麻烦，需要想清楚：\n1 2 3 4 5 6 7 8 for(int j=0;j\u0026lt;=n;j++){//成员人数 dp[0][j][0]=1;//第0项工作不做，利润恒为0，方案数为1 if(j\u0026gt;=group[0]){//人数够做第0项工作了 //做一下吧 for(int k=0;k\u0026lt;=profit[0];k++) dp[0][j][k]=1; dp[0][j][0]++;//还是选择不做，利润为0的方案数加1 } } 状态转移方程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 for(int i=1;i\u0026lt;len;i++){ for(int j=0;j\u0026lt;=n;j++){ for(int k=0;k\u0026lt;=100;k++){ dp[i][j][k]=dp[i-1][j][k];//第i个工作不选 if(j\u0026gt;=group[i]){//选第i个工作 if(k\u0026gt;=profit[i])//如果总利润要达到k，第i份工作产生利润pi小于总利润，那么只需要前i-1份工作达到至少k-pi的利润 dp[i][j][k] += dp[i-1][j-group[i]][k-profit[i]]; //如果要达到的总利润k小于第i份工作产生的利润，那么前i-1份工作利润随便，不小于0即可，事实上，pi\u0026gt;=0 else dp[i][j][k] += dp[i-1][j-group[i]][0]; dp[i][j][k] %= MOD; } } } } 最后的结果即为dp[len-1,n, minProfit]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 const int MOD = 1e9+7; class Solution { public: int profitableSchemes(int n, int minProfit, vector\u0026lt;int\u0026gt;\u0026amp; group, vector\u0026lt;int\u0026gt;\u0026amp; profit) { int len = group.size(); long long dp[len+1][n+1][101];//dp[i,j,k] 表示前i项工作，人数不超过j，利润至少为k的总方案数 memset(dp,0,sizeof(dp)); for(int j=0;j\u0026lt;=n;j++){//成员人数 dp[0][j][0]=1;//第0项工作不做，利润恒为0，方案数为1 if(j\u0026gt;=group[0]){//人数够做第0项工作了 //做一下吧 for(int k=0;k\u0026lt;=profit[0];k++) dp[0][j][k]=1; dp[0][j][0]++;//还是选择不做，利润为0的方案数加1 } } for(int i=1;i\u0026lt;len;i++){ for(int j=0;j\u0026lt;=n;j++){ for(int k=0;k\u0026lt;=100;k++){ dp[i][j][k]=dp[i-1][j][k];//第i个工作不选 if(j\u0026gt;=group[i]){//选第i个工作 if(k\u0026gt;=profit[i])//如果总利润要达到k，第i份工作产生利润pi小于总利润，那么只需要前i-1份工作达到至少k-pi的利润 dp[i][j][k] += dp[i-1][j-group[i]][k-profit[i]]; //如果要达到的总利润k小于第i份工作产生的利润，那么前i-1份工作利润随便，不小于0即可，事实上，pi\u0026gt;=0 else dp[i][j][k] += dp[i-1][j-group[i]][0]; dp[i][j][k] %= MOD; } } } } return dp[len-1][n][minProfit]; } }; 代码2.0 上一题也提到过，为了避免讨论初始化的麻烦，可以假想存在一个空工作，即所需人数为0，产生利润也为0，将该工作放在首位\n那么dp[i,j,k]就用来表示前i-1个（真）工作，人数不超过j，产生利润至少为k的方案数\n初始化就只需要令 dp[0,x,0]=1，其中x的范围为[0,n]，表示这项空工作，人数无论是多少，利润只能是0，方案数只有1\n后面循环注意将需要修改的i变为i-1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 const int MOD = 1e9+7; class Solution { public: int profitableSchemes(int n, int minProfit, vector\u0026lt;int\u0026gt;\u0026amp; group, vector\u0026lt;int\u0026gt;\u0026amp; profit) { int len = group.size(); long long dp[len+1][n+1][101]; memset(dp,0,sizeof(dp)); for(int j=0;j\u0026lt;=n;j++) dp[0][j][0]=1; for(int i=1;i\u0026lt;=len;i++){ for(int j=0;j\u0026lt;=n;j++){ for(int k=0;k\u0026lt;=100;k++){ dp[i][j][k]=dp[i-1][j][k];//第i个工作不选 if(j\u0026gt;=group[i-1]){//选第i个工作 if(k\u0026gt;=profit[i-1])//如果总利润要达到k，第i份工作产生利润pi小于总利润，那么只需要前i-1份工作达到至少k-pi的利润 dp[i][j][k] += dp[i-1][j-group[i-1]][k-profit[i-1]]; //如果要达到的总利润k小于第i份工作产生的利润，那么前i-1份工作利润随便，不小于0即可，事实上，pi\u0026gt;=0 else dp[i][j][k] += dp[i-1][j-group[i-1]][0]; dp[i][j][k] %= MOD; } } } } return dp[len][n][minProfit]; } }; 空间优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 const int MOD = 1e9+7; class Solution { public: int profitableSchemes(int n, int minProfit, vector\u0026lt;int\u0026gt;\u0026amp; group, vector\u0026lt;int\u0026gt;\u0026amp; profit) { int len = group.size(); long long dp[n+1][101]; memset(dp,0,sizeof(dp)); for(int j=0;j\u0026lt;=n;j++) dp[j][0]=1; for(int i=1;i\u0026lt;=len;i++){ for(int j=n;j\u0026gt;=group[i-1];j--){ for(int k=100;k\u0026gt;=0;k--){ dp[j][k]=dp[j][k]; if(k\u0026gt;=profit[i-1]) dp[j][k] += dp[j-group[i-1]][k-profit[i-1]]; else dp[j][k] += dp[j-group[i-1]][0]; dp[j][k] %= MOD; } } } return dp[n][minProfit]; } }; 另外一种定义方式 如果将dp[i,j,k]定义成前i-1项工作，人数恰好为j，利润至少为k的方案数\n初始化dp[0,0,0]=1，表示空工作时，不需要人数，人数恰好为0，利润为0，方案数为1\n转移方程和前面的方式没啥区别\n最后的需返回dp[len,x,minProfit]的和，其中x的范围是[0,n]\n官方题解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int profitableSchemes(int n, int minProfit, vector\u0026lt;int\u0026gt;\u0026amp; group, vector\u0026lt;int\u0026gt;\u0026amp; profit) { int len = group.size(), MOD = (int)1e9 + 7; vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; dp(len + 1, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n + 1, vector\u0026lt;int\u0026gt;(minProfit + 1))); dp[0][0][0] = 1; for (int i = 1; i \u0026lt;= len; i++) { int members = group[i - 1], earn = profit[i - 1]; for (int j = 0; j \u0026lt;= n; j++) { for (int k = 0; k \u0026lt;= minProfit; k++) { if (j \u0026lt; members) { dp[i][j][k] = dp[i - 1][j][k]; } else { dp[i][j][k] = (dp[i - 1][j][k] + dp[i - 1][j - members][max(0, k - earn)]) % MOD; } } } } int sum = 0; for (int j = 0; j \u0026lt;= n; j++) { sum = (sum + dp[len][j][minProfit]) % MOD; } return sum; } }; ","date":"2022-05-11T00:00:00Z","image":"https://tetsuou.github.io/p/01%E8%83%8C%E5%8C%85/post-bg-20220511_hu12522189966631514480.png","permalink":"https://tetsuou.github.io/p/01%E8%83%8C%E5%8C%85/","title":"01背包"},{"content":"\n【模拟】字符串中最大的3位相同数字 题目 给你一个字符串 num ，表示一个大整数。如果一个整数满足下述所有条件，则认为该整数是一个 优质整数 ：\n该整数是 num 的一个长度为 3 的 子字符串 。 该整数由唯一一个数字重复 3 次组成。 以字符串形式返回 最大的优质整数 。如果不存在满足要求的整数，则返回一个空字符串 \u0026quot;\u0026quot; 。\n注意：\n子字符串 是字符串中的一个连续字符序列。 num 或优质整数中可能存在 前导零 。 示例 1：\n1 2 3 4 输入：num = \u0026#34;6777133339\u0026#34; 输出：\u0026#34;777\u0026#34; 解释：num 中存在两个优质整数：\u0026#34;777\u0026#34; 和 \u0026#34;333\u0026#34; 。 \u0026#34;777\u0026#34; 是最大的那个，所以返回 \u0026#34;777\u0026#34; 。 示例 2：\n1 2 3 输入：num = \u0026#34;2300019\u0026#34; 输出：\u0026#34;000\u0026#34; 解释：\u0026#34;000\u0026#34; 是唯一一个优质整数。 示例 3：\n1 2 3 输入：num = \u0026#34;42352338\u0026#34; 输出：\u0026#34;\u0026#34; 解释：不存在长度为 3 且仅由一个唯一数字组成的整数。因此，不存在优质整数。 提示：\n3 \u0026lt;= num.length \u0026lt;= 1000 num 仅由数字（0 - 9）组成 解题思路 按题意模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: string largestGoodInteger(string num) { set\u0026lt;string\u0026gt; st; int n = num.size(); for(int i=0;i\u0026lt;n-2;i++){ if(num[i]==num[i+1] \u0026amp;\u0026amp; num[i+1]==num[i+2]){ st.insert(num.substr(i,3)); } } if(st.empty()) return \u0026#34;\u0026#34;; else return *st.rbegin(); } }; 偷学代码 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: string largestGoodInteger(string s) { string ans; for(int i = 2; i \u0026lt; s.size(); ++i) { if(s[i] == s[i-1] \u0026amp;\u0026amp; s[i-1] == s[i-2]) { ans = max(ans, string(3, s[i])); } } return ans; } }; 【DFS】统计值等于子树平均值的节点数 题目 给你一棵二叉树的根节点 root ，找出并返回满足要求的节点数，要求节点的值等于其 子树 中值的 平均值 。\n注意：\nn 个元素的平均值可以由 n 个元素 求和 然后再除以 n ，并 向下舍入 到最近的整数。 root 的 子树 由 root 和它的所有后代组成。 示例 1：\n1 2 3 4 5 6 7 8 输入：root = [4,8,5,0,1,null,6] 输出：5 解释： 对值为 4 的节点：子树的平均值 (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4 。 对值为 5 的节点：子树的平均值 (5 + 6) / 2 = 11 / 2 = 5 。 对值为 0 的节点：子树的平均值 0 / 1 = 0 。 对值为 1 的节点：子树的平均值 1 / 1 = 1 。 对值为 6 的节点：子树的平均值 6 / 1 = 6 。 示例 2：\n1 2 3 输入：root = [1] 输出：1 解释：对值为 1 的节点：子树的平均值 1 / 1 = 1。 提示：\n树中节点数目在范围 [1, 1000] 内 0 \u0026lt;= Node.val \u0026lt;= 1000 解题思路 DFS遍历，返回节点值的总和以及节点个数\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: const int MAXN = 1005; int res = 0; pair\u0026lt;int,int\u0026gt; dfs(TreeNode* root){//first:sum second:cnt if(!root) return {0,0}; auto ls = dfs(root-\u0026gt;left); auto rs = dfs(root-\u0026gt;right); int sum = root-\u0026gt;val+ls.first+rs.first; int cnt = 1 + ls.second+rs.second; if(sum/cnt==root-\u0026gt;val) res++; return make_pair(sum,cnt); } int averageOfSubtree(TreeNode* root) { dfs(root); return res; } }; 【DP+乘法原理】统计打字方案数 题目 Alice 在给 Bob 用手机打字。数字到字母的 对应 如下图所示。\n为了 打出 一个字母，Alice 需要 按 对应字母 i 次，i 是该字母在这个按键上所处的位置。\n比方说，为了按出字母 's' ，Alice 需要按 '7' 四次。类似的， Alice 需要按 '5' 两次得到字母 'k' 。 注意，数字 '0' 和 '1' 不映射到任何字母，所以 Alice 不 使用它们。 但是，由于传输的错误，Bob 没有收到 Alice 打字的字母信息，反而收到了 按键的字符串信息 。\n比方说，Alice 发出的信息为 \u0026quot;bob\u0026quot; ，Bob 将收到字符串 \u0026quot;2266622\u0026quot; 。 给你一个字符串 pressedKeys ，表示 Bob 收到的字符串，请你返回 Alice 总共可能发出多少种文字信息 。\n由于答案可能很大，将它对 10^9 + 7 取余 后返回。\n示例 1：\n1 2 3 4 5 6 输入：pressedKeys = \u0026#34;22233\u0026#34; 输出：8 解释： Alice 可能发出的文字信息包括： \u0026#34;aaadd\u0026#34;, \u0026#34;abdd\u0026#34;, \u0026#34;badd\u0026#34;, \u0026#34;cdd\u0026#34;, \u0026#34;aaae\u0026#34;, \u0026#34;abe\u0026#34;, \u0026#34;bae\u0026#34; 和 \u0026#34;ce\u0026#34; 。 由于总共有 8 种可能的信息，所以我们返回 8 。 示例 2：\n1 2 3 4 5 输入：pressedKeys = \u0026#34;222222222222222222222222222222222222\u0026#34; 输出：82876089 解释： 总共有 2082876103 种 Alice 可能发出的文字信息。 由于我们需要将答案对 109 + 7 取余，所以我们返回 2082876103 % (109 + 7) = 82876089 。 提示：\n1 \u0026lt;= pressedKeys.length \u0026lt;= 10^5 pressedKeys 只包含数字 '2' 到 '9' 。 解题思路 比赛的时候想到是动态规划，往整数拆分那边想，没有第一时间找到递推公式\n于是枚举前几项找规律，真发现了不得了的规律，对于2、3、4、5、6、8来说，令dp[i]表示长度为i的按键信息对应的不同文字信息的种数，有dp[i]=dp[i-1]+dp[i-2]+dp[i-3]。对于7、9来说类似。\n更正式地：\n思路和爬楼梯类似\n对于3字母数字来说，令dp[i]表示长度为i的按键信息对应的不同文字信息的种数，初始化dp[1]=1，dp[2]=2，dp[3]=4。考虑dp[i]，可以将末尾的1个、2个或3个字符单独视作一个字母，得出状态转移方程\n1 dp[i] = dp[i-1]+dp[i-2]+dp[i-3]; 4字母数字类似。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public: const int MAXN = 1e5+3; const int MOD = 1e9+7; vector\u0026lt;long long\u0026gt; dp; vector\u0026lt;long long\u0026gt; dp2; int countTexts(string pressedKeys) { int n = pressedKeys.size(); dp.assign(MAXN,0); dp[1]=1,dp[2]=2,dp[3]=4; for(int i=4;i\u0026lt;=n;i++) dp[i] = (dp[i-1]+dp[i-2]+dp[i-3])%MOD; dp2.assign(MAXN,0); dp2[1]=1,dp2[2]=2,dp2[3]=4,dp2[4]=8; for(int i=5;i\u0026lt;=n;i++) dp2[i] = (dp2[i-1]+dp2[i-2]+dp2[i-3]+dp2[i-4])%MOD; long long res = 1; unordered_map\u0026lt;string,int\u0026gt; tab; int start=0; for(int i=0;i\u0026lt;n-1;i++){//如果最后一个字符是单独的一个字符，会被忽略掉，但不会影响结果 if(pressedKeys[i]==pressedKeys[i+1]){ if(i==n-2){ string str = pressedKeys.substr(start,i+1-start+1); tab[str]++; } }else{ string str = pressedKeys.substr(start,i-start+1); tab[str]++; start=i+1; } } for(auto \u0026amp;x: tab){ string s = x.first; int cnt = x.second; if(s[0]==\u0026#39;7\u0026#39;||s[0]==\u0026#39;9\u0026#39;) { for(int i=1;i\u0026lt;=cnt;i++) res = (res*dp2[s.size()])%MOD; }else{ for(int i=1;i\u0026lt;=cnt;i++) res = (res*dp[s.size()])%MOD; } } return res; } }; 偷学代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int MOD = 1e9 + 7; class Solution { public: int countTexts(string a) { vector \u0026lt;int\u0026gt; dp0, dp1; dp0.resize(a.size() + 5); dp1.resize(a.size() + 5); dp0[0] = dp1[0] = 1; for (int i = 1; i \u0026lt; dp0.size(); i++) { for (int j = 1; j \u0026lt;= 3 \u0026amp;\u0026amp; j \u0026lt;= i; j++) { dp0[i] = (dp0[i] + dp0[i - j]) % MOD; } for (int j = 1; j \u0026lt;= 4 \u0026amp;\u0026amp; j \u0026lt;= i; j++) { dp1[i] = (dp1[i] + dp1[i - j]) % MOD; } } int ans = 1; for (int i = 0; i \u0026lt; a.size(); i++) { int j = i; while (j + 1 \u0026lt; a.size() \u0026amp;\u0026amp; a[j + 1] == a[i]) { j++; } int len = j - i + 1; i = j; if (a[i] == \u0026#39;7\u0026#39; || a[i] == \u0026#39;9\u0026#39;) { ans = (long long)ans * dp1[len] % MOD; } else { ans = (long long)ans * dp0[len] % MOD; } } return ans; } }; 【DP/DFS+有效括号】检查是否有合法括号字符串路径 题目 一个括号字符串是一个 非空 且只包含 '(' 和 ')' 的字符串。如果下面 任意 条件为 真 ，那么这个括号字符串就是 合法的 。\n字符串是 () 。 字符串可以表示为 AB（A 连接 B），A 和 B 都是合法括号序列。 字符串可以表示为 (A) ，其中 A 是合法括号序列。 给你一个 m x n 的括号网格图矩阵 grid 。网格图中一个 合法括号路径 是满足以下所有条件的一条路径：\n路径开始于左上角格子 (0, 0) 。 路径结束于右下角格子 (m - 1, n - 1) 。 路径每次只会向 下 或者向 右 移动。 路径经过的格子组成的括号字符串是 合法 的。 如果网格图中存在一条 合法括号路径 ，请返回 true ，否则返回 false 。\n示例 1：\n1 2 3 4 5 6 输入：grid = [[\u0026#34;(\u0026#34;,\u0026#34;(\u0026#34;,\u0026#34;(\u0026#34;],[\u0026#34;)\u0026#34;,\u0026#34;(\u0026#34;,\u0026#34;)\u0026#34;],[\u0026#34;(\u0026#34;,\u0026#34;(\u0026#34;,\u0026#34;)\u0026#34;],[\u0026#34;(\u0026#34;,\u0026#34;(\u0026#34;,\u0026#34;)\u0026#34;]] 输出：true 解释：上图展示了两条路径，它们都是合法括号字符串路径。 第一条路径得到的合法字符串是 \u0026#34;()(())\u0026#34; 。 第二条路径得到的合法字符串是 \u0026#34;((()))\u0026#34; 。 注意可能有其他的合法括号字符串路径。 示例 2：\n1 2 3 输入：grid = [[\u0026#34;)\u0026#34;,\u0026#34;)\u0026#34;],[\u0026#34;(\u0026#34;,\u0026#34;(\u0026#34;]] 输出：false 解释：两条可行路径分别得到 \u0026#34;))(\u0026#34; 和 \u0026#34;)((\u0026#34; 。由于它们都不是合法括号字符串，我们返回 false 。 提示：\nm == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 100 grid[i][j] 要么是 '(' ，要么是 ')' 。 解题思路 写第3题花了太多时间了，这题就没写。\n补题时补了一些括号匹配的题。\n前置知识：判断一个括号序列是否合法，只需要判断每个位置上左括号总数量大于等于右括号总数量，并且最后左括号数量和右括号数量相等。\nDFS 如果知道如何判断括号序列是否合法的话，DFS框架还是很容易想的\n离谱的是，两种差不多的写法，一种超时，一种过了\n两者的区别是，过了的代码中，将now\u0026lt;0判错的语句提到了前面。\n下面这种过了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int n,m; vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; G; int dp[101][101][202]; bool dfs(int x, int y, int now){ if(x\u0026gt;=n||y\u0026gt;=m) return false; if(now\u0026gt;n-x+m-y-1 || now\u0026lt;0) return false; if(dp[x][y][now]) return false; if(x==n-1 \u0026amp;\u0026amp; y==m-1){ return now==1; } dp[x][y][now]=1; if(G[x][y]==\u0026#39;(\u0026#39;) now++; else now--; return dfs(x+1,y,now)||dfs(x,y+1,now); } bool hasValidPath(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { n = grid.size(), m = grid[0].size(); G = grid; if(grid[0][0]==\u0026#39;)\u0026#39;||grid[n-1][m-1]==\u0026#39;(\u0026#39;||(m+n-1)\u0026amp;1) return false; memset(dp,0,sizeof(dp)); return dfs(0,0,0); } }; 这种超时了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: int n,m; vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; G; int dp[101][101][202]; bool dfs(int x, int y, int now){ if(x\u0026gt;=n||y\u0026gt;=m) return false; if(now\u0026gt;n-x+m-y-1) return false; if(dp[x][y][now]) return false; if(x==n-1 \u0026amp;\u0026amp; y==m-1){ now--; if(now==0) return true; else return false; } if(G[x][y]==\u0026#39;(\u0026#39;) now++; else now--; if(now\u0026lt;0) { return false; } dp[x][y][now]=1; return dfs(x+1,y,now)||dfs(x,y+1,now); } bool hasValidPath(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { n = grid.size(), m = grid[0].size(); G = grid; if(grid[0][0]==\u0026#39;)\u0026#39;||grid[n-1][m-1]==\u0026#39;(\u0026#39;||(m+n-1)\u0026amp;1) return false; memset(dp,0,sizeof(dp)); return dfs(0,0,0); } }; DP 令dp[i,j,k]表示grid[i,j]且左括号净计数为k的状态是否存在\n最后判断dp[n-1][m-1][0]是否为真即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: bool hasValidPath(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(),m = grid[0].size(); if((n+m-1)\u0026amp;1||grid[0][0]==\u0026#39;)\u0026#39;||grid[n-1][m-1]==\u0026#39;(\u0026#39;) return false; int maxlen=m+n-1; bool dp[n][m][maxlen+1]; memset(dp,0,sizeof(dp)); //dp[i][j][k] grid[i][j]左括号净计数为k的状态是否存在 dp[0][0][1] = true; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ if(i==0\u0026amp;\u0026amp;j==0) continue; int c=grid[i][j]==\u0026#39;(\u0026#39;?1:-1; for(int k=0;k\u0026lt;=maxlen;k++){ if(k-c\u0026lt;0||k-c\u0026gt;maxlen) continue; if(i-1\u0026gt;=0)//上到下 dp[i][j][k] = dp[i][j][k]||dp[i-1][j][k-c]; if(j-1\u0026gt;=0)//左到右 dp[i][j][k] = dp[i][j][k]||dp[i][j-1][k-c]; } } } return dp[n-1][m-1][0]; } }; ","date":"2022-05-09T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC292%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220509_hu16359719281014770780.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC292%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第292场周赛总结"},{"content":"前言 计算贡献，如果是连续序列，一般也可从动态规划的视角进行求解。如果不是连续序列，具体情况具体分析。\n统计子串中的唯一字符 题目 我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。\n例如：s = \u0026ldquo;LEETCODE\u0026rdquo; ，则其中 \u0026ldquo;L\u0026rdquo;, \u0026ldquo;T\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;O\u0026rdquo;,\u0026ldquo;D\u0026rdquo; 都是唯一字符，因为它们只出现一次，所以 countUniqueChars(s) = 5 。\n本题将会给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的所有子字符串中的唯一字符）。\n由于答案可能非常大，请将结果 mod 10 ^ 9 + 7 后再返回。\n示例 1：\n输入: s = \u0026ldquo;ABC\u0026rdquo; 输出: 10 解释: 所有可能的子串为：\u0026ldquo;A\u0026rdquo;,\u0026ldquo;B\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;AB\u0026rdquo;,\u0026ldquo;BC\u0026rdquo; 和 \u0026ldquo;ABC\u0026rdquo;。 其中，每一个子串都由独特字符构成。 所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10 示例 2：\n输入: s = \u0026ldquo;ABA\u0026rdquo; 输出: 8 解释: 除了 countUniqueChars(\u0026ldquo;ABA\u0026rdquo;) = 1 之外，其余与示例 1 相同。 示例 3：\n输入：s = \u0026ldquo;LEETCODE\u0026rdquo; 输出：92\n提示：\n0 \u0026lt;= s.length \u0026lt;= 10^5 s 只包含大写英文字符\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/count-unique-characters-of-all-substrings-of-a-given-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 令dp[i,j]表示子字符串s[0..i]中字符\u0026rsquo;A\u0026rsquo;+j的贡献度\n初始化很显然dp[0][s[0]-\u0026lsquo;A\u0026rsquo;]=1，dp[0][其他]=0\n考虑字符s[i]造成的贡献，如果[0,i-1]中没有相同字符，显然新增贡献为[0,i]区间的长度（加在末尾），即i+1 而如果[0,i-1]中出现相同字符，设位置为p，那么不会对[0,p]区间新增贡献，贡献变为没有相同字符的区间[p+1,i]长度，即i-p\n答案即是所有的dp之和\npos数组记录左侧第一个相同字符的位置\n和这题很像的有一题是，291场周赛第4题。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 const int MOD = 1e9+7; class Solution { public: int uniqueLetterString(string s) { int n = s.size(); if(!n) return 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n,vector\u0026lt;int\u0026gt;(26,0)); vector\u0026lt;int\u0026gt; pos(26,-1); //dp[i][j] s[0..i]的所有子字符串中字符\u0026#39;A\u0026#39;+j的贡献度 //pos[i] 与s[i]相同字符的左侧最近位置，辅助 dp[0][s[0]-\u0026#39;A\u0026#39;]=1; pos[s[0]-\u0026#39;A\u0026#39;]=0; int res = 1; for(int i=1;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;26;j++){ dp[i][j] = dp[i-1][j]; } if(pos[s[i]-\u0026#39;A\u0026#39;]\u0026gt;-1) dp[i][s[i]-\u0026#39;A\u0026#39;]=i-pos[s[i]-\u0026#39;A\u0026#39;]; else dp[i][s[i]-\u0026#39;A\u0026#39;]+=i+1; res += accumulate(dp[i].begin(),dp[i].end(),0)%MOD; pos[s[i]-\u0026#39;A\u0026#39;]=i; } return res; } }; 子数组的最小值之和 题目 给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。\n由于答案可能很大，因此 返回答案模 10^9 + 7 。\n示例 1：\n输入：arr = [3,1,2,4] 输出：17 解释： 子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。 示例 2：\n输入：arr = [11,81,94,43,3] 输出：444\n提示：\n1 \u0026lt;= arr.length \u0026lt;= 3 * 10^4\n1 \u0026lt;= arr[i] \u0026lt;= 3 * 10^4\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sum-of-subarray-minimums 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 令dp[i]表示arr[0..i]所有子数组的最小值之和\n初始化显然dp[0] = arr[0]\n考虑第i个数arr[i]，如果左侧的数都比它大，即它是区间[0,i]上的最小值，那么dp[i]的贡献完全由arr[i]提供，即arr[i]*(i+1) 如果向左侧第一个比它小（或等于）的数的下标为p，那么它只在[p+1,i]上新增贡献，则dp[i]=dp[p]+(i-p)*arr[i]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const int MOD = 1e9+7; class Solution { public: int sumSubarrayMins(vector\u0026lt;int\u0026gt;\u0026amp; arr) { int n = arr.size(); vector\u0026lt;int\u0026gt; dp(n,0);//dp[i] arr[0..i]所有子数组的最小值之和 vector\u0026lt;int\u0026gt; L(n,-1);//L[i] 向左侧第一个比arr[i]小的数的位置 dp[0] = arr[0]; int res = dp[0]; stack\u0026lt;int\u0026gt; st; st.push(0); for(int i=1;i\u0026lt;n;i++){ while(!st.empty() \u0026amp;\u0026amp; arr[st.top()]\u0026gt;=arr[i]) st.pop(); if(st.empty()) L[i] = -1; else L[i] = st.top(); st.push(i); } for(int i=1;i\u0026lt;n;i++){ int p=L[i]; if(p == -1){//前面的全部都大，arr[i]在[0,i]做贡献 dp[i] = arr[i]*(i+1); }else{//arr[i]在[p+1,i]上做贡献 dp[i] = (i-p)*arr[i]+dp[p]; } res = (res+dp[i])%MOD; } return res; } }; 子数组范围和 题目 给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。\n返回 nums 中 所有 子数组范围的 和 。\n子数组是数组中一个连续 非空 的元素序列。\n示例 1：\n输入：nums = [1,2,3] 输出：4 解释：nums 的 6 个子数组如下所示： [1]，范围 = 最大 - 最小 = 1 - 1 = 0 [2]，范围 = 2 - 2 = 0 [3]，范围 = 3 - 3 = 0 [1,2]，范围 = 2 - 1 = 1 [2,3]，范围 = 3 - 2 = 1 [1,2,3]，范围 = 3 - 1 = 2 所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4 示例 2：\n输入：nums = [1,3,3] 输出：4 解释：nums 的 6 个子数组如下所示： [1]，范围 = 最大 - 最小 = 1 - 1 = 0 [3]，范围 = 3 - 3 = 0 [3]，范围 = 3 - 3 = 0 [1,3]，范围 = 3 - 1 = 2 [3,3]，范围 = 3 - 3 = 0 [1,3,3]，范围 = 3 - 1 = 2 所有范围的和是 0 + 0 + 0 + 2 + 0 + 2 = 4 示例 3：\n输入：nums = [4,-2,-3,4,1] 输出：59 解释：nums 中所有子数组范围的和是 59\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 1000\n-109 \u0026lt;= nums[i] \u0026lt;= 10^9\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sum-of-subarray-ranges 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 这里的范围和，即所有的最大值之和减去所有的最小值之和\n大体思路和上一题一样\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: long long subArrayRanges(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; Lmax(n,-1),Lmin(n,-1); stack\u0026lt;int\u0026gt; stk; stk.push(0); for(int i=1;i\u0026lt;n;i++){ while(!stk.empty()\u0026amp;\u0026amp;nums[i]\u0026gt;=nums[stk.top()]) stk.pop(); if(stk.empty()) Lmax[i]=-1; else Lmax[i]=stk.top(); stk.push(i); } stack\u0026lt;int\u0026gt; stk2; stk2.push(0); for(int i=1;i\u0026lt;n;i++){ while(!stk2.empty()\u0026amp;\u0026amp;nums[i]\u0026lt;=nums[stk2.top()]) stk2.pop(); if(stk2.empty()) Lmin[i]=-1; else Lmin[i]=stk2.top(); stk2.push(i); } long long res = 0; vector\u0026lt;long long\u0026gt; dpmax(n,0),dpmin(n,0); dpmax[0]=nums[0],dpmin[0]=nums[0]; for(int i=1;i\u0026lt;n;i++){ if(Lmax[i]==-1) dpmax[i]=1LL*(i+1)*nums[i]; else dpmax[i]=1LL*(i-Lmax[i])*nums[i]+dpmax[Lmax[i]]; if(Lmin[i]==-1) dpmin[i]=1LL*(i+1)*nums[i]; else dpmin[i]=1LL*(i-Lmin[i])*nums[i]+dpmin[Lmin[i]]; res += dpmax[i]-dpmin[i]; } return res; } }; ","date":"2022-05-06T00:00:00Z","image":"https://tetsuou.github.io/p/%E8%AE%A1%E7%AE%97%E8%B4%A1%E7%8C%AE/post-bg-20220506_hu9537068965142205840.png","permalink":"https://tetsuou.github.io/p/%E8%AE%A1%E7%AE%97%E8%B4%A1%E7%8C%AE/","title":"计算贡献"},{"content":"\n这场状态真差，掉大分\n【模拟】移除指定数字得到的最大结果 题目 给你一个表示某个正整数的字符串 number 和一个字符 digit 。\n从 number 中 恰好 移除 一个 等于 digit 的字符后，找出并返回按 十进制 表示 最大 的结果字符串。生成的测试用例满足 digit 在 number 中出现至少一次。\n示例 1：\n1 2 3 输入：number = \u0026#34;123\u0026#34;, digit = \u0026#34;3\u0026#34; 输出：\u0026#34;12\u0026#34; 解释：\u0026#34;123\u0026#34; 中只有一个 \u0026#39;3\u0026#39; ，在移除 \u0026#39;3\u0026#39; 之后，结果为 \u0026#34;12\u0026#34; 。 示例 2：\n1 2 3 4 输入：number = \u0026#34;1231\u0026#34;, digit = \u0026#34;1\u0026#34; 输出：\u0026#34;231\u0026#34; 解释：可以移除第一个 \u0026#39;1\u0026#39; 得到 \u0026#34;231\u0026#34; 或者移除第二个 \u0026#39;1\u0026#39; 得到 \u0026#34;123\u0026#34; 。 由于 231 \u0026gt; 123 ，返回 \u0026#34;231\u0026#34; 。 示例 3：\n1 2 3 4 输入：number = \u0026#34;551\u0026#34;, digit = \u0026#34;5\u0026#34; 输出：\u0026#34;51\u0026#34; 解释：可以从 \u0026#34;551\u0026#34; 中移除第一个或者第二个 \u0026#39;5\u0026#39; 。 两种方案的结果都是 \u0026#34;51\u0026#34; 。 提示：\n2 \u0026lt;= number.length \u0026lt;= 100 number 由数字 '1' 到 '9' 组成 digit 是 '1' 到 '9' 中的一个数字 digit 在 number 中出现至少一次 解题思路 比赛的时候想的太琐碎了，WA了两发\n其实遍历一遍，所有情况拿出来比一下不就好了\n难受\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: string removeDigit(string number, char digit) { int n = number.size(); int idx=-1; for(int i=0;i\u0026lt;n;i++){ if(number[i] == digit){ if(idx==-1){ idx = i; if(number[i]\u0026lt;number[i+1]){ idx=i;break; } }else { if(i!=n-1 \u0026amp;\u0026amp; number[i]\u0026lt;number[i+1]){ idx = i; break; } else { idx = i; } } } } number.erase(idx,1); return number; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: string removeDigit(string number, char digit) { set\u0026lt;string\u0026gt; se; for(int i=0;i\u0026lt;number.size();i++){ if(number[i]==digit){ string s = number; s.erase(s.begin()+i); se.insert(s); } } return *se.rbegin(); } }; 【滑动窗口】必须拿起的最小连续卡牌数 题目 给你一个整数数组 cards ，其中 cards[i] 表示第 i 张卡牌的 值 。如果两张卡牌的值相同，则认为这一对卡牌 匹配 。\n返回你必须拿起的最小连续卡牌数，以使在拿起的卡牌中有一对匹配的卡牌。如果无法得到一对匹配的卡牌，返回 -1 。\n示例 1：\n1 2 3 输入：cards = [3,4,2,3,4,7] 输出：4 解释：拿起卡牌 [3,4,2,3] 将会包含一对值为 3 的匹配卡牌。注意，拿起 [4,2,3,4] 也是最优方案。 示例 2：\n1 2 3 输入：cards = [1,0,5,3] 输出：-1 解释：无法找出含一对匹配卡牌的一组连续卡牌。 提示：\n1 \u0026lt;= cards.length \u0026lt;= 10^5 0 \u0026lt;= cards[i] \u0026lt;= 10^6 解题思路 刚好上周刷了一些滑动窗口的题，看到可以用滑动窗口做，就用滑动窗口了\n维护一个滑动窗口，再维护一个哈希表存储卡牌信息即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int minimumCardPickup(vector\u0026lt;int\u0026gt;\u0026amp; cards) { int n = cards.size(); unordered_map\u0026lt;int,int\u0026gt; tab; int l=0,r=0,res=n+1; while(r\u0026lt;n){ int cur = cards[r]; r++; tab[cur]++; while(tab[cur]\u0026gt;1){//有两张卡牌的值相同了，开始收缩窗口 res = min(res,r-l); tab[cards[l]]--; l++; } } return res==n+1?-1:res; } }; 【模拟】含最多 K 个可整除元素的子数组 题目 给你一个整数数组 nums 和两个整数 k 和 p ，找出并返回满足要求的不同的子数组数，要求子数组中最多 k 个可被 p 整除的元素。\n如果满足下述条件之一，则认为数组 nums1 和 nums2 是 不同 数组：\n两数组长度 不同 ，或者 存在 至少 一个下标 i 满足 nums1[i] != nums2[i] 。 子数组 定义为：数组中的连续元素组成的一个 非空 序列。\n示例 1：\n1 2 3 4 5 6 7 8 输入：nums = [2,3,3,2,2], k = 2, p = 2 输出：11 解释： 位于下标 0、3 和 4 的元素都可以被 p = 2 整除。 共计 11 个不同子数组都满足最多含 k = 2 个可以被 2 整除的元素： [2]、[2,3]、[2,3,3]、[2,3,3,2]、[3]、[3,3]、[3,3,2]、[3,3,2,2]、[3,2]、[3,2,2] 和 [2,2] 。 注意，尽管子数组 [2] 和 [3] 在 nums 中出现不止一次，但统计时只计数一次。 子数组 [2,3,3,2,2] 不满足条件，因为其中有 3 个元素可以被 2 整除。 示例 2：\n1 2 3 4 5 6 输入：nums = [1,2,3,4], k = 4, p = 1 输出：10 解释： nums 中的所有元素都可以被 p = 1 整除。 此外，nums 中的每个子数组都满足最多 4 个元素可以被 1 整除。 因为所有子数组互不相同，因此满足所有限制条件的子数组总数为 10 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 200 1 \u0026lt;= nums[i], p \u0026lt;= 200 1 \u0026lt;= k \u0026lt;= nums.length 解题思路 这题没细看，初看很烦，就一直想第4题去了\n其实这题很简单，模拟一下就好了，数据范围很小\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #define ull unsigned long long const ull B = 1e9+7; class Solution { public: int countDistinct(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, int p) { unordered_set\u0026lt;ull\u0026gt; tab; int n = nums.size(); for(int i=0;i\u0026lt;n;i++){//起点 for(int j=1;i+j-1\u0026lt;n;j++){//长度 ull Hash = 0; int cnt=0; for(int q=i;q\u0026lt;i+j;q++){ if(nums[q]%p==0) cnt++; if(cnt\u0026gt;k) break; Hash = Hash*B + nums[q]; } if(cnt\u0026lt;=k) tab.insert(Hash); } } return tab.size(); } }; 偷学代码 不必手动hash，但要注意加分隔符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int countDistinct(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, int p) { int n = nums.size(); unordered_set\u0026lt;string\u0026gt; st; for (int i = 0; i \u0026lt; n; i++) { string t; int cnt = 0; for (int j = i; j \u0026lt; n; j++) { if (nums[j] % p == 0) cnt++; if (cnt \u0026gt; k) break; t += to_string(nums[j]) + \u0026#34;|\u0026#34;; st.insert(t); } } return st.size(); } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int countDistinct(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, int p) { int n = nums.size(); map\u0026lt;vector\u0026lt;int\u0026gt;, int\u0026gt; mp; for (int i = 0; i \u0026lt; n; i++) { int cnt = 0; vector\u0026lt;int\u0026gt; v; for (int j = i; j \u0026lt; n; j++) { if (nums[j] % p == 0) cnt++; if (cnt \u0026gt; k) break; v.push_back(nums[j]); mp[v] = 1; } } return (int)mp.size(); } }; 【动态规划】字符串的总引力 题目 字符串的 引力 定义为：字符串中 不同 字符的数量。\n例如，\u0026quot;abbca\u0026quot; 的引力为 3 ，因为其中有 3 个不同字符 'a'、'b' 和 'c' 。 给你一个字符串 s ，返回 其所有子字符串的总引力 。\n子字符串 定义为：字符串中的一个连续字符序列。\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：s = \u0026#34;abbca\u0026#34; 输出：28 解释：\u0026#34;abbca\u0026#34; 的子字符串有： - 长度为 1 的子字符串：\u0026#34;a\u0026#34;、\u0026#34;b\u0026#34;、\u0026#34;b\u0026#34;、\u0026#34;c\u0026#34;、\u0026#34;a\u0026#34; 的引力分别为 1、1、1、1、1，总和为 5 。 - 长度为 2 的子字符串：\u0026#34;ab\u0026#34;、\u0026#34;bb\u0026#34;、\u0026#34;bc\u0026#34;、\u0026#34;ca\u0026#34; 的引力分别为 2、1、2、2 ，总和为 7 。 - 长度为 3 的子字符串：\u0026#34;abb\u0026#34;、\u0026#34;bbc\u0026#34;、\u0026#34;bca\u0026#34; 的引力分别为 2、2、3 ，总和为 7 。 - 长度为 4 的子字符串：\u0026#34;abbc\u0026#34;、\u0026#34;bbca\u0026#34; 的引力分别为 3、3 ，总和为 6 。 - 长度为 5 的子字符串：\u0026#34;abbca\u0026#34; 的引力为 3 ，总和为 3 。 引力总和为 5 + 7 + 7 + 6 + 3 = 28 。 示例 2：\n1 2 3 4 5 6 7 8 输入：s = \u0026#34;code\u0026#34; 输出：20 解释：\u0026#34;code\u0026#34; 的子字符串有： - 长度为 1 的子字符串：\u0026#34;c\u0026#34;、\u0026#34;o\u0026#34;、\u0026#34;d\u0026#34;、\u0026#34;e\u0026#34; 的引力分别为 1、1、1、1 ，总和为 4 。 - 长度为 2 的子字符串：\u0026#34;co\u0026#34;、\u0026#34;od\u0026#34;、\u0026#34;de\u0026#34; 的引力分别为 2、2、2 ，总和为 6 。 - 长度为 3 的子字符串：\u0026#34;cod\u0026#34;、\u0026#34;ode\u0026#34; 的引力分别为 3、3 ，总和为 6 。 - 长度为 4 的子字符串：\u0026#34;code\u0026#34; 的引力为 4 ，总和为 4 。 引力总和为 4 + 6 + 6 + 4 = 20 。 提示：\n1 \u0026lt;= s.length \u0026lt;= 10^5 s 由小写英文字母组成 解题思路 比赛的时候想到了主体思路，那就是想方法计算出单个字符的贡献，最后加一起。\n补题的时候发现这类计算贡献的题，用动态规划的效果很不错\n令dp[i]表示s[0..i]的所有子字符串的总引力\n那么最终结果为dp[0]+dp[1]+\u0026hellip;+dp[n-1]\n即所有的子字符串 由 以s[0]结尾的字符串、以s[1]结尾的字符串、\u0026hellip;。以s[n-1]结尾的字符串组成\ndp[0]=1显然可得\n递推关系怎么得呢，考虑第i个字符s[i]，它会加在前面组成的字符串末尾，假设前面第j个字符s[j]==s[i]，那么s[i]会对在区间[j+1,i]结尾的子字符串提供贡献，即i-j\n这个j代表的就是s[i]左侧第一个出现的相同字符的位置\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: long long appealSum(string s) { int n = s.size(); vector\u0026lt;long long\u0026gt; dp(n,0),pos(26,-1); //dp[i] s[0..i]的所有子字符串的总引力 //pos[i] 与s[i]相同字符的左侧最近位置，辅助 dp[0] = 1; pos[s[0]-\u0026#39;a\u0026#39;] = 0; for(int i=1;i\u0026lt;n;i++){ dp[i] = dp[i-1]+i-pos[s[i]-\u0026#39;a\u0026#39;]; pos[s[i]-\u0026#39;a\u0026#39;]=i; } return accumulate(dp.begin(),dp.end(),(long long)0); } }; ","date":"2022-05-04T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC291%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220504_hu13526676199992533271.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC291%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第291场周赛总结"},{"content":"\n【模拟】统计是给定字符串前缀的字符串数目 题目 给你一个字符串数组 words 和一个字符串 s ，其中 words[i] 和 s 只包含 小写英文字母 。\n请你返回 words 中是字符串 s 前缀 的 字符串数目 。\n一个字符串的 前缀 是出现在字符串开头的子字符串。子字符串 是一个字符串中的连续一段字符序列。\n示例 1：\n1 2 3 4 5 6 输入：words = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;ab\u0026#34;,\u0026#34;bc\u0026#34;,\u0026#34;abc\u0026#34;], s = \u0026#34;abc\u0026#34; 输出：3 解释： words 中是 s = \u0026#34;abc\u0026#34; 前缀的字符串为： \u0026#34;a\u0026#34; ，\u0026#34;ab\u0026#34; 和 \u0026#34;abc\u0026#34; 。 所以 words 中是字符串 s 前缀的字符串数目为 3 。 示例 2：\n1 2 3 4 5 输入：words = [\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;], s = \u0026#34;aa\u0026#34; 输出：2 解释： 两个字符串都是 s 的前缀。 注意，相同的字符串可能在 words 中出现多次，它们应该被计数多次。 提示：\n1 \u0026lt;= words.length \u0026lt;= 1000 1 \u0026lt;= words[i].length, s.length \u0026lt;= 10 words[i] 和 s 只 包含小写英文字母。 解题思路 简单模拟即可\n比赛过程中还是脑袋转的慢\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: bool isok(string s, string t){ if(s.size()\u0026gt;t.size()) return false; for(int i=0;i\u0026lt;s.size();i++){ if(s[i]!=t[i]) return false; } return true; } int countPrefixes(vector\u0026lt;string\u0026gt;\u0026amp; words, string s) { int res = 0; for(auto \u0026amp;str:words){ if(isok(str,s)) res++; } return res; } }; 偷学代码 1 2 3 4 5 6 7 8 class Solution { public: int countPrefixes(vector\u0026lt;string\u0026gt;\u0026amp; words, string s) { int ret=0; for(auto i:words)ret+=(s.substr(0,i.size())==i); return ret; } }; 【枚举、前缀和】最小平均差 题目 给你一个下标从 0 开始长度为 n 的整数数组 nums 。\n下标 i 处的 平均差 指的是 nums 中 前 i + 1 个元素平均值和 后 n - i - 1 个元素平均值的 绝对差 。两个平均值都需要 向下取整 到最近的整数。\n请你返回产生 最小平均差 的下标。如果有多个下标最小平均差相等，请你返回 最小 的一个下标。\n注意：\n两个数的 绝对差 是两者差的绝对值。 n 个元素的平均值是 n 个元素之 和 除以（整数除法） n 。 0 个元素的平均值视为 0 。 示例 1：\n1 2 3 4 5 6 7 8 9 10 输入：nums = [2,5,3,9,5,3] 输出：3 解释： - 下标 0 处的平均差为：|2 / 1 - (5 + 3 + 9 + 5 + 3) / 5| = |2 / 1 - 25 / 5| = |2 - 5| = 3 。 - 下标 1 处的平均差为：|(2 + 5) / 2 - (3 + 9 + 5 + 3) / 4| = |7 / 2 - 20 / 4| = |3 - 5| = 2 。 - 下标 2 处的平均差为：|(2 + 5 + 3) / 3 - (9 + 5 + 3) / 3| = |10 / 3 - 17 / 3| = |3 - 5| = 2 。 - 下标 3 处的平均差为：|(2 + 5 + 3 + 9) / 4 - (5 + 3) / 2| = |19 / 4 - 8 / 2| = |4 - 4| = 0 。 - 下标 4 处的平均差为：|(2 + 5 + 3 + 9 + 5) / 5 - 3 / 1| = |24 / 5 - 3 / 1| = |4 - 3| = 1 。 - 下标 5 处的平均差为：|(2 + 5 + 3 + 9 + 5 + 3) / 6 - 0| = |27 / 6 - 0| = |4 - 0| = 4 。 下标 3 处的平均差为最小平均差，所以返回 3 。 示例 2：\n1 2 3 4 5 输入：nums = [0] 输出：0 解释： 唯一的下标是 0 ，所以我们返回 0 。 下标 0 处的平均差为：|0 / 1 - 0| = |0 - 0| = 0 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 0 \u0026lt;= nums[i] \u0026lt;= 10^5 解题思路 枚举分割点，利用前缀和计算区间和即可\n注意前缀和的数据范围可能会超int\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: long long abs(long long a){ if(a\u0026gt;0) return a; else return -a; } int minimumAverageDifference(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if(nums.size()==1) return 0; vector\u0026lt;long long\u0026gt; dis(nums.size()); dis[0] = nums[0]; for(int i=1;i\u0026lt;nums.size();i++) dis[i] = dis[i-1]+nums[i]; long long sum = dis[nums.size()-1]; int idx=0; long long minValue=0x3f3f3f3f,cur; for(int i=0;i\u0026lt;nums.size();i++){ if(i==nums.size()-1) cur = abs(sum/nums.size()); else{ cur = abs(1LL*dis[i]/(i+1)-1LL*(sum-dis[i])/(nums.size()-i-1)); } // cout\u0026lt;\u0026lt;cur\u0026lt;\u0026lt;endl; if(cur\u0026lt;minValue){ minValue = cur; idx = i; } } return idx; } }; 【模拟】统计网格中没有被保卫的格子数 题目 给你两个整数 m 和 n 表示一个下标从 0 开始的 m x n 网格图。同时给你两个二维整数数组 guards 和 walls ，其中 guards[i] = [rowi, coli] 且 walls[j] = [rowj, colj] ，分别表示第 i 个警卫和第 j 座墙所在的位置。\n一个警卫能看到 4 个坐标轴方向（即东、南、西、北）的 所有 格子，除非他们被一座墙或者另外一个警卫 挡住 了视线。如果一个格子能被 至少 一个警卫看到，那么我们说这个格子被 保卫 了。\n请你返回空格子中，有多少个格子是 没被保卫 的。\n示例 1：\n1 2 3 4 输入：m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]] 输出：7 解释：上图中，被保卫和没有被保卫的格子分别用红色和绿色表示。 总共有 7 个没有被保卫的格子，所以我们返回 7 。 示例 2：\n1 2 3 4 输入：m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]] 输出：4 解释：上图中，没有被保卫的格子用绿色表示。 总共有 4 个没有被保卫的格子，所以我们返回 4 。 提示：\n1 \u0026lt;= m, n \u0026lt;= 10^5 2 \u0026lt;= m * n \u0026lt;= 10^5 1 \u0026lt;= guards.length, walls.length \u0026lt;= 5 * 10^4 2 \u0026lt;= guards.length + walls.length \u0026lt;= m * n guards[i].length == walls[j].length == 2 0 \u0026lt;= rowi, rowj \u0026lt; m 0 \u0026lt;= coli, colj \u0026lt; n guards 和 walls 中所有位置 互不相同 。 解题思路 比赛的时候这题一开始通过率很高啊，第一眼看以为要用DFS做，后来看四个方向是一条路走到黑的，就想着模拟就好了\n这题注意到数据规模了，mn不超过10^5，但是复杂度想错了\n想着是枚举每一个警卫，然后对每个警卫的4个方向进行遍历，直到碰到墙或出界，以为会超时，时间复杂度最坏可能达到10^9。\n需要想清楚的是，其实每个点最多被扫4次就够了\n看到一个比喻：\n5个人大家朝着同一个站成一队，你站在队伍的第4个位置，此时你会看到前方的人的后背；在这个情况下，站在你前面的人相当于替你看了前面的风景；\n所以其实复杂度O(nm)就解决了这题\n偷学代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public: int countUnguarded(int m, int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; gs, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; ws) { vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g(m, vector\u0026lt;int\u0026gt;(n, 0)); const int guard = 1; const int wall = 2; for (int i = 0; i \u0026lt; gs.size(); ++i) { int x = gs[i][0], y = gs[i][1]; g[x][y] = guard; } for (int i = 0; i \u0026lt; ws.size(); ++i) { int x = ws[i][0], y = ws[i][1]; g[x][y] = wall; } const int dx[4] = {1, -1, 0, 0}; const int dy[4] = {0, 0, 1, -1}; for (int i = 0; i \u0026lt; gs.size(); ++i) { int x = gs[i][0], y = gs[i][1]; int xx, yy; for (int d = 0; d \u0026lt; 4; ++d) { for (int j = 1; ; ++j) { xx = x + dx[d] * j; yy = y + dy[d] * j; if (xx \u0026lt; 0 || xx \u0026gt;= m || yy \u0026lt; 0 || yy \u0026gt;= n || g[xx][yy] == guard || g[xx][yy] == wall) { break; } g[xx][yy] = 3; } } } int res = 0; for (int i = 0; i \u0026lt; m; ++i) { for (int j = 0; j \u0026lt; n; ++j) { if (g[i][j] == 0) { ++res; } } } return res; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public: int countUnguarded(int m, int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; guards, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; walls) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; grid(m,vector\u0026lt;int\u0026gt;(n,0)); for(auto v:guards) grid[v[0]][v[1]]=1; for(auto v:walls) grid[v[0]][v[1]]=2; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; f(m,vector\u0026lt;bool\u0026gt;(n,false)); for(int i=0;i\u0026lt;m;i++){ bool t=false; for(int j=0;j\u0026lt;n;j++){ if(grid[i][j]==1) t=true; else if(grid[i][j]==2) t=false; if(t) f[i][j]=true; } t=false; for(int j=n-1;j\u0026gt;=0;j--){ if(grid[i][j]==1) t=true; else if(grid[i][j]==2) t=false; if(t) f[i][j]=true; } } for(int j=0;j\u0026lt;n;j++){ bool t=false; for(int i=0;i\u0026lt;m;i++) { if(grid[i][j]==1) t=true; else if(grid[i][j]==2) t=false; if(t) f[i][j]=true; } t=false; for(int i=m-1;i\u0026gt;=0;i--){ if(grid[i][j]==1) t=true; else if(grid[i][j]==2) t=false; if(t) f[i][j]=true; } } int ans=0; for(int i=0;i\u0026lt;m;i++) for(int j=0;j\u0026lt;n;j++){ if(grid[i][j]==0\u0026amp;\u0026amp;!f[i][j]) ans++; } return ans; } }; 另一种思路 比赛中后来我用的是另外一种思路\n考虑每一个网格，找到它四个方向最近的物体，如果有警卫，就说明被保护到了\n找最近的物体，可以对排序后的数组进行二分查找即可\n这样的时间复杂度是O(n*m*max(log m, log n))，比前一种方法复杂度高\n比赛的时候写麻了，变量整太多，没写注释都忘记啥意思了，然后一直编译错误，结束后冷静整理了一下一次过了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #define P pair\u0026lt;int,int\u0026gt; class Solution { public: int m,n;//m行n列 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G,W,grid; bool rfun(int row, int col, vector\u0026lt;int\u0026gt;\u0026amp; arr){//行坐标，列坐标，网格[row,col]能否被第row行的警卫看到 auto idx_max = upper_bound(arr.begin(),arr.end(),col); if(idx_max != arr.end()){ if(grid[row][*idx_max]==2) return true; } auto idx_min = lower_bound(arr.begin(),arr.end(),col); if(idx_min!=arr.begin()){ if(grid[row][*(--idx_min)]==2) return true; } return false; } bool cfun(int row, int col, vector\u0026lt;int\u0026gt;\u0026amp; arr){//行坐标，列坐标，网格[row,col]能否被第col列的警卫看到 auto idx_max = upper_bound(arr.begin(),arr.end(),row); if(idx_max != arr.end()){ if(grid[*idx_max][col]==2) return true; } auto idx_min = lower_bound(arr.begin(),arr.end(),row); if(idx_min!=arr.begin()){ if(grid[*(--idx_min)][col]==2) return true; } return false; } int countUnguarded(int m, int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; guards, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; walls) { this-\u0026gt;m = m; this-\u0026gt;n = n; G=guards,W=walls; grid.resize(m); for(int i=0;i\u0026lt;m;i++) grid[i].resize(n,0); //r[i] 行坐标为i的 警卫、墙的列数组 //c[i] 列坐标为i的 警卫、墙的行数组 unordered_map\u0026lt; int,vector\u0026lt;int\u0026gt; \u0026gt; r,c; for(auto \u0026amp;x:walls){ grid[x[0]][x[1]] = 1; r[x[0]].push_back(x[1]);//列坐标 c[x[1]].push_back(x[0]); } for(auto \u0026amp;x:guards){ grid[x[0]][x[1]] = 2; r[x[0]].push_back(x[1]); c[x[1]].push_back(x[0]); } //排序以用于二分查找 for(auto \u0026amp;x:r){ sort(x.second.begin(),x.second.end()); } for(auto \u0026amp;x:c){ sort(x.second.begin(),x.second.end()); } int res = 0; for(int i=0;i\u0026lt;m;i++){ for(int j=0;j\u0026lt;n;j++){ if(grid[i][j]) continue; if(rfun(i,j,r[i])) {//网格[i][j]在第i行上有被警卫保护 }else if(cfun(i,j,c[j])){//网格[i][j]在第j列上有被警卫保护 }else{ res++; } } } return res; } }; 【二分+BFS】逃离火灾 题目 给你一个下标从 0 开始大小为 m x n 的二维整数数组 grid ，它表示一个网格图。每个格子为下面 3 个值之一：\n0 表示草地。 1 表示着火的格子。 2 表示一座墙，你跟火都不能通过这个格子。 一开始你在最左上角的格子 (0, 0) ，你想要到达最右下角的安全屋格子 (m - 1, n - 1) 。每一分钟，你可以移动到 相邻 的草地格子。每次你移动 之后 ，着火的格子会扩散到所有不是墙的 相邻 格子。\n请你返回你在初始位置可以停留的 最多 分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回 -1 。如果不管你在初始位置停留多久，你 总是 能到达安全屋，请你返回 109 。\n注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。\n如果两个格子有共同边，那么它们为 相邻 格子。\n示例 1：\n1 2 3 4 5 输入：grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]] 输出：3 解释：上图展示了你在初始位置停留 3 分钟后的情形。 你仍然可以安全到达安全屋。 停留超过 3 分钟会让你无法安全到达安全屋。 示例 2：\n1 2 3 4 5 输入：grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]] 输出：-1 解释：上图展示了你马上开始朝安全屋移动的情形。 火会蔓延到你可以移动的所有格子，所以无法安全到达安全屋。 所以返回 -1 。 示例 3：\n1 2 3 4 5 输入：grid = [[0,0,0],[2,2,0],[1,2,0]] 输出：1000000000 解释：上图展示了初始网格图。 注意，由于火被墙围了起来，所以无论如何你都能安全到达安全屋。 所以返回 109 。 提示：\nm == grid.length n == grid[i].length 2 \u0026lt;= m, n \u0026lt;= 300 4 \u0026lt;= m * n \u0026lt;= 2 * 10^4 grid[i][j] 是 0 ，1 或者 2 。 grid[0][0] == grid[m - 1][n - 1] == 0 解题思路 首先利用BFS预处理火势蔓延所需要的最小时间\n然后二分答案t\n利用BFS判断在原地停留t时间后，能否安全到达安全屋\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class Solution { public: int dir[4][2]={ {-1,0},{1,0},{0,-1},{0,1} }; int maximumMinutes(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(); int m = grid[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(n,vector\u0026lt;int\u0026gt;(m,INT_MAX)); queue\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; q; for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;m;j++) if(grid[i][j]==1) f[i][j]=0,q.emplace(i,j); auto bound = [\u0026amp;](int x, int y){ if(x\u0026lt;0||x\u0026gt;=n) return false; if(y\u0026lt;0||y\u0026gt;=m) return false; return true; }; while(!q.empty()){//spread fire auto [x,y] = q.front(); q.pop(); for(int i=0;i\u0026lt;4;i++){ int dx=x+dir[i][0],dy=y+dir[i][1]; if(!bound(dx,dy)) continue; if(f[dx][dy]!=INT_MAX) continue; if(grid[dx][dy]==2) continue; f[dx][dy] = f[x][y]+1; q.emplace(dx,dy); } } //f[i][j] 火蔓延至[i][j]的最短时间 //d[i][j] 人移动到[i][j]的最短时间 auto check = [\u0026amp;](int t){//等待t时间后是否安全 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; d(n,vector\u0026lt;int\u0026gt;(m,INT_MAX)); d[0][0] = t;//原地等t时间 queue\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; que; que.emplace(0,0); while(!que.empty()){ auto [x,y] = que.front();que.pop(); for(int i=0;i\u0026lt;4;i++){ int dx = x+dir[i][0]; int dy = y+dir[i][1]; if(!bound(dx,dy)) continue; if(grid[dx][dy]==2) continue; if(d[dx][dy]!=INT_MAX) continue; d[dx][dy] = d[x][y] + 1; if(dx==n-1 \u0026amp;\u0026amp; dy==m-1){//移动到安全屋时 if(d[dx][dy]\u0026lt;=f[dx][dy]) return true; else return false; } if(d[dx][dy]\u0026gt;=f[dx][dy]) {}//中途被烧，放弃这条路 else que.emplace(dx,dy);//这条路没被烧，继续走 } } return false;//到不了安全屋，或是所有路在中途都会被烧 }; int l=0,r=1e9+1;//左闭右开 while(l\u0026lt;r){ int mid = l+r\u0026gt;\u0026gt;1; if(check(mid)) l=mid+1;//如果可以停留mid时间，右移左边界，尝试增加时间 else r=mid; } //l-1 return l-1; } }; ","date":"2022-05-03T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC77%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220503_hu12275743792110453410.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC77%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第77场双周赛总结"},{"content":"前言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int left = 0, right = 0; //[left, right)左闭右开，区间长度为r while (right \u0026lt; s.size()) { // 增大窗口 var cur = s[right]; window.add(cur); right++; while (window needs shrink) { // 缩小窗口 window.remove(s[left]); left++; } } 注意窗口大小是固定的，还是不固定的\n即注意左边界的变化情况\n主要是看用什么数据结构维护窗口滑动过程中的变化量，以及什么时候更新答案\n最小覆盖子串 题目 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \u0026quot;\u0026quot; 。\n注意：\n对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。\n示例 1：\n输入：s = \u0026ldquo;ADOBECODEBANC\u0026rdquo;, t = \u0026ldquo;ABC\u0026rdquo; 输出：\u0026ldquo;BANC\u0026rdquo; 示例 2：\n输入：s = \u0026ldquo;a\u0026rdquo;, t = \u0026ldquo;a\u0026rdquo; 输出：\u0026ldquo;a\u0026rdquo; 示例 3:\n输入: s = \u0026ldquo;a\u0026rdquo;, t = \u0026ldquo;aa\u0026rdquo; 输出: \u0026quot;\u0026quot; 解释: t 中两个字符 \u0026lsquo;a\u0026rsquo; 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。\n提示：\n1 \u0026lt;= s.length, t.length \u0026lt;= 10^5\ns 和 t 由英文字母组成\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-window-substring 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 [left, right)维护字符串s上一个滑动窗口，判断该滑动窗口中的字符串是否涵盖t所有字符，最后求出这个最小长度的滑动窗口\n重点是如何判断滑动窗口中的字符串是否涵盖t所有字符\n对滑动窗口内的字符串和t分别维护一个哈希表，用来存储需要覆盖字符及个数\n窗口右边界增长时，判断新增字符是否为需要字符，若是，则添加进代表窗口内字符串的哈希表中，并且计算满足要求的字符种类数\n当窗口中字符串满足题意时，更新答案，并且尝试增长左边界，窗口进行滑动\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: string minWindow(string s, string t) { unordered_map\u0026lt;char,int\u0026gt; sm,tm; for(auto \u0026amp;c: t) tm[c]++; int left=0,right=0; int valid = 0;//涵盖t中字符种类个数，当valid==t中字符种类个数时说明已涵盖 int start=0,length=0x3f3f3f3f; while(right\u0026lt;s.size()){ char c = s[right]; right++; if(tm.count(c)){ sm[c]++; if(tm[c]==sm[c]) valid++; } while(valid == tm.size()){ if(right-left\u0026lt;length){ length = right-left; start = left; } if(tm.count(s[left])){ if(sm[s[left]] == tm[s[left]]) valid--; sm[s[left]]--; } left++; } } if(length == 0x3f3f3f3f) return \u0026#34;\u0026#34;; else return s.substr(start,length); } }; 字符串的排列 题目 给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。\n换句话说，s1 的排列之一是 s2 的 子串 。\n示例 1：\n输入：s1 = \u0026ldquo;ab\u0026rdquo; s2 = \u0026ldquo;eidbaooo\u0026rdquo; 输出：true 解释：s2 包含 s1 的排列之一 (\u0026ldquo;ba\u0026rdquo;). 示例 2：\n输入：s1= \u0026ldquo;ab\u0026rdquo; s2 = \u0026ldquo;eidboaoo\u0026rdquo; 输出：false\n提示：\n1 \u0026lt;= s1.length, s2.length \u0026lt;= 10^4\ns1 和 s2 仅包含小写字母\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/permutation-in-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 此题的窗口稳定之后大小是固定的\n同样的，可以利用哈希表来维护需要比较判断的东西\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: bool checkInclusion(string s1, string s2) { int len1=s1.size(),len2=s2.size(); if(len1\u0026gt;len2) return false; unordered_map\u0026lt;char,int\u0026gt; tab1,tab2; for(auto \u0026amp;x: s1) tab1[x]++; int l=0,r=0; while(r\u0026lt;len2){ tab2[s2[r]]++; r++; if(tab1==tab2){ return true; } if(r-l\u0026gt;=len1){//右边界开始增长 tab2[s2[l]]--; if(!tab2[s2[l]]) tab2.erase(s2[l]); l++; } } return false; } }; 无重复字符的最长子串 题目 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n示例 1:\n输入: s = \u0026ldquo;abcabcbb\u0026rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026ldquo;abc\u0026rdquo;，所以其长度为 3。 示例 2:\n输入: s = \u0026ldquo;bbbbb\u0026rdquo; 输出: 1 解释: 因为无重复字符的最长子串是 \u0026ldquo;b\u0026rdquo;，所以其长度为 1。 示例 3:\n输入: s = \u0026ldquo;pwwkew\u0026rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026ldquo;wke\u0026rdquo;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\u0026ldquo;pwke\u0026rdquo; 是一个子序列，不是子串。\n提示：\n0 \u0026lt;= s.length \u0026lt;= 5 * 10^4\ns 由英文字母、数字、符号和空格组成\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 利用哈希表判断串口内字符串中是否有字符数量超过1，有则开始增加左边界直到无重复字符\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int lengthOfLongestSubstring(string s) { int n = s.size(); unordered_map\u0026lt;char,int\u0026gt; tab; int l=0,r=0,res=0; while(r\u0026lt;n){ char cur = s[r]; r++; tab[cur]++; while(tab[cur]\u0026gt;1) { tab[s[l]]--; l++; } res = max(res,r-l); } return res; } }; 最大连续1的个数 III 题目 给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。\n示例 1：\n输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2 输出：6 解释：[1,1,1,0,0,1,1,1,1,1,1] 粗体数字从 0 翻转到 1，最长的子数组长度为 6。 示例 2：\n输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3 输出：10 解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1] 粗体数字从 0 翻转到 1，最长的子数组长度为 10。\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5\nnums[i] 不是 0 就是 1\n0 \u0026lt;= k \u0026lt;= nums.length\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/max-consecutive-ones-iii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 此题只需要一个int变量记录已经进行翻转0的个数即可（即0的个数）\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int longestOnes(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); int l=0,r=0; int res=0; int cnt=0;//翻转0的个数 while(r\u0026lt;n){ int cur = nums[r]; r++; if(cur==0) cnt++; while(cnt\u0026gt;k){ if(nums[l]==0) cnt--; l++; } res = max(res,r-l); } return res; } }; 存在重复元素 III 题目 给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) \u0026lt;= t ，同时又满足 abs(i - j) \u0026lt;= k 。\n如果存在则返回 true，不存在返回 false。\n示例 1：\n输入：nums = [1,2,3,1], k = 3, t = 0 输出：true 示例 2：\n输入：nums = [1,0,1,1], k = 1, t = 2 输出：true 示例 3：\n输入：nums = [1,5,9,1,5,9], k = 2, t = 3 输出：false\n提示：\n0 \u0026lt;= nums.length \u0026lt;= 2 * 10^4\n-231 \u0026lt;= nums[i] \u0026lt;= 2^31 - 1\n0 \u0026lt;= k \u0026lt;= 10^4\n0 \u0026lt;= t \u0026lt;= 2^31 - 1\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/contains-duplicate-iii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n滑动窗口1.0 注意数据范围，运算结果有可能超int，醉了\n利用map的有序性，维护每个数及出现的次数\n其实也可以只用一次二分判断，见2.0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: bool containsNearbyAlmostDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, int t) { int n = nums.size(); int l=0,r=0; map\u0026lt;long long,long long\u0026gt; tab; while(r\u0026lt;n){ int cur = nums[r]; r++; tab[cur]++; if(tab[cur]\u0026gt;1) {//窗口前面出现过相同的数，==0 return true; } auto idx1 = tab.upper_bound(cur); if(idx1!=tab.end() \u0026amp;\u0026amp; abs(idx1-\u0026gt;first-cur)\u0026lt;=t) {//大于cur的第一个数 return true; } auto idx2 = tab.lower_bound(cur); if(idx2!=tab.begin() \u0026amp;\u0026amp; abs((--idx2)-\u0026gt;first-cur)\u0026lt;=t){//小于cur的第一个数 return true; } if(r-l\u0026gt;k){ tab[nums[l]]--; if(tab[nums[l]]==0) tab.erase(nums[l]); l++; } } return false; } }; 滑动窗口2.0 窗口内每次添加进一个元素cur时，检查前面添加进窗口的元素中，是否存在pre，使得pre-cur\u0026lt;=t 且 cur-pre\u0026lt;=t\n则pre的范围为[cur-t, cur+t]\n此时只需要用一个set维护即可，但更新变化量的过程要放在答案更新的后面\n注意是两个不同下标\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: bool containsNearbyAlmostDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, int t) { int n = nums.size(); int l=0,r=0; set\u0026lt;long long\u0026gt; se; while(r\u0026lt;n){ long long cur = nums[r]; r++; auto idx = se.lower_bound(cur-t); if(idx!=se.end() \u0026amp;\u0026amp; *idx\u0026lt;=cur+t) return true; se.insert(cur); if(r-l\u0026gt;k){ se.erase(nums[l]); l++; } } return false; } }; 乘积小于K的子数组 题目 给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。\n示例 1：\n输入：nums = [10,5,2,6], k = 100 输出：8 解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。 需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。 示例 2：\n输入：nums = [1,2,3], k = 0 输出：0\n提示:\n1 \u0026lt;= nums.length \u0026lt;= 3 * 10^4\n1 \u0026lt;= nums[i] \u0026lt;= 1000\n0 \u0026lt;= k \u0026lt;= 10^6\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/subarray-product-less-than-k 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 维护区间[l,r-1]使得区间内乘积小于k，每次加上以a[r-1]结尾满足条件的子数组数目即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int numSubarrayProductLessThanK(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { if(k\u0026lt;=1) return 0; int n = nums.size(); int res = 0; int l=0,r=0; int prod=1; while(r\u0026lt;n){ int cur = nums[r]; r++; prod = prod*cur; while(prod\u0026gt;=k){ prod = prod/nums[l]; l++; } //[l,r-1]区间元素乘积小于k //加上以nums[r-1]结尾的所有子数组数目 res += r-l; } return res; } }; ","date":"2022-04-30T00:00:00Z","image":"https://tetsuou.github.io/p/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/post-bg-20220430_hu639987262276831392.png","permalink":"https://tetsuou.github.io/p/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","title":"滑动窗口"},{"content":"引言 差分是一种和前缀和相对的策略，可以当作是求和的逆运算 $$ \\begin{equation} b_i= \\begin{cases} a_i-a_{i-1} , \u0026amp; i\\in[2,n] \\ a_1 , \u0026amp; i = 1 \\end{cases} \\end{equation} $$ 简单性质：\n1）计算数列各项的值。 $$ \\begin{equation} a[n] = \\sum_{i=1}^{n} b[i] \\end{equation} $$ 2）计算数列的前缀和。 $$ \\begin{equation} sum_n = \\sum_{i=1}^{n}a_i = \\sum_{i=1}^{n}\\sum_{j=1}^{i}b_j = \\sum_{i=1}^{n}(n-i+1)b_i \\end{equation} $$ 用途：\n维护多次对数列的一个区间加上一个数，并在最后询问某一位的数或多次询问某一位的数\n$b_l+k$可看成[l,n]的变化量加k，这也导致了r后面也加了k，所以还要令$b_{r+1}-k$，表示[r+1,n]的变化量减k\n航班预定统计 题目 这里有 n 个航班，它们分别从 1 到 n 进行编号。\n有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。\n请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。\n示例 1：\n输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5 输出：[10,55,45,25,25] 解释： 航班编号 1 2 3 4 5 预订记录 1 ： 10 10 预订记录 2 ： 20 20 预订记录 3 ： 25 25 25 25 总座位数： 10 55 45 25 25 因此，answer = [10,55,45,25,25] 示例 2：\n输入：bookings = [[1,2,10],[2,2,15]], n = 2 输出：[10,25] 解释： 航班编号 1 2 预订记录 1 ： 10 10 预订记录 2 ： 15 总座位数： 10 25 因此，answer = [10,25]\n提示：\n1 \u0026lt;= n \u0026lt;= 2 * 10^4\n1 \u0026lt;= bookings.length \u0026lt;= 2 * 10^4\nbookings[i].length == 3\n1 \u0026lt;= firsti \u0026lt;= lasti \u0026lt;= n\n1 \u0026lt;= seatsi \u0026lt;= 10^4\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/corporate-flight-bookings 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 区间修改 单点查询\n差分模板题\n代码 注意编号，题中的航班编号从1开始\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: vector\u0026lt;int\u0026gt; corpFlightBookings(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; bookings, int n) { vector\u0026lt;int\u0026gt; diff(n+2); for(auto \u0026amp;book: bookings){ diff[book[0]] += book[2]; diff[book[1]+1] -= book[2]; } int now = 0; vector\u0026lt;int\u0026gt; res; for(int i=1;i\u0026lt;=n;i++){ now += diff[i]; res.push_back(now); } return res; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;int\u0026gt; corpFlightBookings(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; bookings, int n) { vector\u0026lt;int\u0026gt; nums(n); for (auto\u0026amp; booking : bookings) { nums[booking[0] - 1] += booking[2]; if (booking[1] \u0026lt; n) { nums[booking[1]] -= booking[2]; } } for (int i = 1; i \u0026lt; n; i++) { nums[i] += nums[i - 1]; } return nums; } }; 拼车 题目 车上最初有 capacity 个空座位。车 只能 向一个方向行驶（也就是说，不允许掉头或改变方向）\n给定整数 capacity 和一个数组 trips , trip[i] = [numPassengersi, fromi, toi] 表示第 i 次旅行有 numPassengersi 乘客，接他们和放他们的位置分别是 fromi 和 toi 。这些位置是从汽车的初始位置向东的公里数。\n当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。\n示例 1：\n输入：trips = [[2,1,5],[3,3,7]], capacity = 4 输出：false 示例 2：\n输入：trips = [[2,1,5],[3,3,7]], capacity = 5 输出：true\n提示：\n1 \u0026lt;= trips.length \u0026lt;= 1000\ntrips[i].length == 3\n1 \u0026lt;= numPassengersi \u0026lt;= 100\n0 \u0026lt;= fromi \u0026lt; toi \u0026lt;= 1000\n1 \u0026lt;= capacity \u0026lt;= 10^5\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/car-pooling 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 区间修改 单点查询\n这题和上一题有点不一样，如果同一距离有人上车也有人下车，是假设下车完再上车的，\n也就是说对差分数组diff，diff[start] += k 不变，start地点开始上车， 而diff[end] -= k（不是diff[end+1]-=k），表示end地点都可下车完。\n再判断每一单点距离是否超载\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: bool carPooling(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; trips, int capacity) { map\u0026lt;int,int\u0026gt; tab; int far = 0; for(auto \u0026amp;x:trips){ tab[x[1]]+=x[0]; tab[x[2]]-=x[0]; far = max(far,x[2]); } int cur=0; for(int i=0;i\u0026lt;=far;i++){ cur += tab[i]; if(cur\u0026gt;capacity) return false; } return true; } }; 我的日程安排表 II 题目 实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。\nMyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start \u0026lt;= x \u0026lt; end。\n当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。\n每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。\n请按照以下步骤调用MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(50, 60); // returns true MyCalendar.book(10, 40); // returns true MyCalendar.book(5, 15); // returns false MyCalendar.book(5, 10); // returns true MyCalendar.book(25, 55); // returns true 解释： 前两个日程安排可以添加至日历中。 第三个日程安排会导致双重预订，但可以添加至日历中。 第四个日程安排活动（5,15）不能添加至日历中，因为它会导致三重预订。 第五个日程安排（5,10）可以添加至日历中，因为它未使用已经双重预订的时间10。 第六个日程安排（25,55）可以添加至日历中，因为时间 [25,40] 将和第三个日程安排双重预订； 时间 [40,50] 将单独预订，时间 [50,55）将和第二个日程安排双重预订。 提示：\n每个测试用例，调用 MyCalendar.book 函数最多不超过 1000次。 调用函数 MyCalendar.book(start, end)时， start 和 end 的取值范围为 [0, 10^9]。\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/my-calendar-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 区间修改 单点查询\n还是可以用差分数组的思想\n注意数据范围，时间的数据范围达到了10^9，如果用int保存完整的差分数组的话空间会炸\n但是调用book函数最多不超过1000次。\n所以可以直接用map存储差分数组，只存储改变后的值即可\ndiff[start]++ 表示时间start后（含）预定数会加1\ndiff[end]\u0026ndash; 表示时间end后（含）预定数会减1，这样累加后只有[start, end)区间的预定数会加1\n累加时只需累加到end，并且只需要在每个时间点有变化量的时候更新即可，在这个过程中判断是否出现大于两次的预定\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class MyCalendarTwo { private: map\u0026lt;int,int\u0026gt; diff; public: MyCalendarTwo() { diff.clear(); } bool book(int start, int end) { diff[start]++,diff[end]--; int now=0; for(auto \u0026amp;x:diff){ if(x.first \u0026gt;= end) break; now += x.second; if(now \u0026gt; 2){//出现三重预定，复原并返回false diff[start]--; diff[end]++; return false; } } return true; } }; /** * Your MyCalendarTwo object will be instantiated and called as such: * MyCalendarTwo* obj = new MyCalendarTwo(); * bool param_1 = obj-\u0026gt;book(start,end); */ K连续位的最小翻转次数 题目 给定一个二进制数组 nums 和一个整数 k 。\nk位翻转 就是从 nums 中选择一个长度为 k 的 子数组 ，同时把子数组中的每一个 0 都改成 1 ，把子数组中的每一个 1 都改成 0 。\n返回数组中不存在 0 所需的最小 k位翻转 次数。如果不可能，则返回 -1 。\n子数组 是数组的 连续 部分。\n示例 1：\n输入：nums = [0,1,0], K = 1 输出：2 解释：先翻转 A[0]，然后翻转 A[2]。 示例 2：\n输入：nums = [1,1,0], K = 2 输出：-1 解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。 示例 3：\n输入：nums = [0,0,0,1,0,1,1,0], K = 3 输出：3 解释： 翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0] 翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0] 翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= k \u0026lt;= nums.length\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 首先是如何翻转，考虑贪心，每次找到第一个0的位置，以该位置为起点连续K个数进行翻转。可以举举例子，论证这样翻转是正确的。\n然后就涉及到了区间修改问题，注意数据规模，显然不能用O(n)的时间进行翻转。\n考虑用差分思想，进行区间修改。\n假设位置i的数为0，那么需要对区间[i,i+k)的数进行翻转，如果i+k大于数组长度（边界为i+k-1==len-1）说明剩下的数不能全部翻转为1了\n对区间[i,i+k）进行修改（加1即可，最后模2判断是否为0），令差分数组d[i]++, d[i+k]\u0026ndash;，这就完成了区间修改操作\n接下来需要进行单点查询操作，注意细节，因为是边修改边查询\n注意区间更新后，变化量也要及时更新\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const int MAXN = 1e5+5; class Solution { public: int minKBitFlips(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int len = nums.size(); int res = 0,now = 0; vector\u0026lt;int\u0026gt; diff(len+5,0);//差分数组 for(int i=0;i\u0026lt;len;i++){ now += diff[i];//累加变化量 // cout\u0026lt;\u0026lt;\u0026#34;i: \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; a[i]: \u0026#34;\u0026lt;\u0026lt;(nums[i]+now)%2\u0026lt;\u0026lt;endl; if((nums[i] + now)%2 == 0){ int r = i+k; if(r\u0026gt;len){ res = -1; break; } diff[i]++; diff[r]--;//[i,r) +1 now++;//i处的变化量发生变化了，记得加上新的变化 res ++;//翻转次数加1 } } return res; } }; or：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 const int MAXN = 1e5+5; class Solution { public: int minKBitFlips(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int len = nums.size(); int res = 0,now = 0; vector\u0026lt;int\u0026gt; diff(len+5,0);//差分数组 for(int i=0;i\u0026lt;len;i++){ now += diff[i];//累加变化量 // cout\u0026lt;\u0026lt;\u0026#34;i: \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; a[i]: \u0026#34;\u0026lt;\u0026lt;(nums[i]+now)%2\u0026lt;\u0026lt;endl; if((nums[i] + now)%2 == 0){ int r = i+k; if(r\u0026gt;len){ res = -1; break; } diff[i+1]++; diff[r]--;//[i+1,r) +1，默认i处已翻转完成 res ++;//翻转次数加1 } } return res; } }; ","date":"2022-04-27T00:00:00Z","image":"https://tetsuou.github.io/p/%E5%B7%AE%E5%88%86/post-bg-20220427_hu4540854004013710514.png","permalink":"https://tetsuou.github.io/p/%E5%B7%AE%E5%88%86/","title":"差分"},{"content":"\n【模拟】多个数组求交集 题目 给你一个二维整数数组 nums ，其中 nums[i] 是由 不同 正整数组成的一个非空数组，按 升序排列 返回一个数组，数组中的每个元素在 nums 所有数组 中都出现过。\n示例 1：\n1 2 3 4 输入：nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]] 输出：[3,4] 解释： nums[0] = [3,1,2,4,5]，nums[1] = [1,2,3,4]，nums[2] = [3,4,5,6]，在 nums 中每个数组中都出现的数字是 3 和 4 ，所以返回 [3,4] 。 示例 2：\n1 2 3 4 输入：nums = [[1,2,3],[4,5,6]] 输出：[] 解释： 不存在同时出现在 nums[0] 和 nums[1] 的整数，所以返回一个空列表 [] 。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 1000 1 \u0026lt;= sum(nums[i].length) \u0026lt;= 1000 1 \u0026lt;= nums[i][j] \u0026lt;= 1000 nums[i] 中的所有值 互不相同 解题思路 定义一个map，统计每个数出现的次数，最后判断是否为n即可\nmap会自动排序\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;int\u0026gt; intersection(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; nums) { int n = nums.size(); map\u0026lt;int,int\u0026gt; tab; for(auto \u0026amp;x: nums){ for(auto y:x){ tab[y]++; } } vector\u0026lt;int\u0026gt; res; for(auto \u0026amp;x: tab){ if(x.second == n){ res.push_back(x.first); } } return res; } }; 【枚举】统计圆内格点数目 题目 给你一个二维整数数组 circles ，其中 circles[i] = [xi, yi, ri] 表示网格上圆心为 (xi, yi) 且半径为 ri 的第 i 个圆，返回出现在 至少一个 圆内的 格点数目 。\n注意：\n格点 是指整数坐标对应的点。 圆周上的点 也被视为出现在圆内的点。 示例 1：\n1 2 3 4 5 6 7 输入：circles = [[2,2,1]] 输出：5 解释： 给定的圆如上图所示。 出现在圆内的格点为 (1, 2)、(2, 1)、(2, 2)、(2, 3) 和 (3, 2)，在图中用绿色标识。 像 (1, 1) 和 (1, 3) 这样用红色标识的点，并未出现在圆内。 因此，出现在至少一个圆内的格点数目是 5 。 示例 2：\n1 2 3 4 5 6 输入：circles = [[2,2,2],[3,4,1]] 输出：16 解释： 给定的圆如上图所示。 共有 16 个格点出现在至少一个圆内。 其中部分点的坐标是 (0, 2)、(2, 0)、(2, 4)、(3, 2) 和 (4, 4) 。 提示：\n1 \u0026lt;= circles.length \u0026lt;= 200 circles[i].length == 3 1 \u0026lt;= xi, yi \u0026lt;= 100 1 \u0026lt;= ri \u0026lt;= min(xi, yi) 解题思路 很难受啊，这题TLE了一发\n看数据规模是妥妥的暴力，没想到竟然TLE了，一开始是枚举200*200个点，再在最多200个圆里判断是否出现在其中，TLE了\n然后换了个遍历的思路，先枚举圆，再统计该圆覆盖的格点数目，最后再统计200*200个格点，看出现次数是否大于0，A了\n结束后，发现其实两种思路都能过的，毕竟数据范围就10^6，第一次TLE的原因是auto没加引用\n也就是说，以后用auto，能加引用就加，速度会快一点\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #define P pair\u0026lt;int,int\u0026gt; class Solution { public: bool isok(int x, int y, int r, P point){ int dis = (point.first-x)*(point.first-x) + (point.second-y)*(point.second-y); return dis\u0026lt;=r*r; } int countLatticePoints(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; circles) { int res = 0; for(int xi = 0; xi \u0026lt;= 205; xi++){ for(int yi = 0; yi\u0026lt;=205; yi++){ for(auto \u0026amp;cir: circles){//原先没加引用，超时了，加了后就过了 if(isok(cir[0],cir[1],cir[2],P(xi,yi))){ res++; break; } } } } return res; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #define P pair\u0026lt;int,int\u0026gt; class Solution { public: bool isok(int x, int y, int r, P point){ int dis = (point.first-x)*(point.first-x) + (point.second-y)*(point.second-y); return dis\u0026lt;=r*r; } int countLatticePoints(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; circles) { int res = 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; have(205); for(int i=0;i\u0026lt;205;i++) have[i].resize(205,0); for(auto cir:circles){//以后加引用 int x = cir[0],y=cir[1],r=cir[2]; for(int i = x-r; i\u0026lt;=x+r;i++){ for(int j = y-r;j\u0026lt;=y+r;j++){ if(isok(x,y,r,P(i,j))) have[i][j]++; } } } for(auto x:have){//以后加引用 for(auto y:x){ if(y) res++; } } return res; } }; 【枚举+二分】统计包含每个点的矩形数目 题目 给你一个二维整数数组 rectangles ，其中 rectangles[i] = [li, hi] 表示第 i 个矩形长为 li 高为 hi 。给你一个二维整数数组 points ，其中 points[j] = [xj, yj] 是坐标为 (xj, yj) 的一个点。\n第 i 个矩形的 左下角 在 (0, 0) 处，右上角 在 (li, hi) 。\n请你返回一个整数数组 count ，长度为 points.length，其中 count[j]是 包含 第 j 个点的矩形数目。\n如果 0 \u0026lt;= xj \u0026lt;= li 且 0 \u0026lt;= yj \u0026lt;= hi ，那么我们说第 i 个矩形包含第 j 个点。如果一个点刚好在矩形的 边上 ，这个点也被视为被矩形包含。\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]] 输出：[2,1] 解释： 第一个矩形不包含任何点。 第二个矩形只包含一个点 (2, 1) 。 第三个矩形包含点 (2, 1) 和 (1, 4) 。 包含点 (2, 1) 的矩形数目为 2 。 包含点 (1, 4) 的矩形数目为 1 。 所以，我们返回 [2, 1] 。 示例 2：\n1 2 3 4 5 6 7 8 9 输入：rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]] 输出：[1,3] 解释： 第一个矩形只包含点 (1, 1) 。 第二个矩形只包含点 (1, 1) 。 第三个矩形包含点 (1, 3) 和 (1, 1) 。 包含点 (1, 3) 的矩形数目为 1 。 包含点 (1, 1) 的矩形数目为 3 。 所以，我们返回 [1, 3] 。 提示：\n1 \u0026lt;= rectangles.length, points.length \u0026lt;= 5 * 10^4 rectangles[i].length == points[j].length == 2 1 \u0026lt;= li, xj \u0026lt;= 10^9 1 \u0026lt;= hi, yj \u0026lt;= 100 所有 rectangles 互不相同 。 所有 points 互不相同 。 解题思路 打比赛的时候一直在搞怎么排序好，但排完后也没想好接着怎么做\n注意数据范围，宽的范围是10^9，而高的范围是100。\n按高存储不同矩形，当高相同时，将宽按从小到大排序\n遍历点时，统计高度在[1,100]范围内，用二分计算每个高度合法的矩形数量\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const int MAXN = 101; class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; tab; vector\u0026lt;int\u0026gt; countRectangles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; rectangles, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; points) { tab.resize(101); for(auto \u0026amp;x:rectangles){ tab[x[1]].push_back(x[0]); } for(auto \u0026amp;x:tab){ sort(x.begin(),x.end()); } vector\u0026lt;int\u0026gt; res; for(auto \u0026amp;point:points){ int x = point[0], y = point[1], cnt = 0; for(int height=100;height\u0026gt;=1;height--){ if(height\u0026lt;y) break;//高度不够 if(tab[height].empty()) continue;//没有该高度的矩形 int idx = lower_bound(tab[height].begin(),tab[height].end(),x)-tab[height].begin();//第一个宽度大于等于该宽度的举行索引 cnt += tab[height].size()-idx; } res.push_back(cnt); } return res; } }; 【差分、线段树等】花期内花的数目 题目 给你一个下标从 0 开始的二维整数数组 flowers ，其中 flowers[i] = [starti, endi] 表示第 i 朵花的 花期 从 starti 到 endi （都 包含）。同时给你一个下标从 0 开始大小为 n 的整数数组 persons ，persons[i] 是第 i 个人来看花的时间。\n请你返回一个大小为 n 的整数数组 answer ，其中 answer[i]是第 i 个人到达时在花期内花的 数目 。\n示例 1：\n1 2 3 4 输入：flowers = [[1,6],[3,7],[9,12],[4,13]], persons = [2,3,7,11] 输出：[1,2,2,2] 解释：上图展示了每朵花的花期时间，和每个人的到达时间。 对每个人，我们返回他们到达时在花期内花的数目。 示例 2：\n1 2 3 4 输入：flowers = [[1,10],[3,3]], persons = [3,3,2] 输出：[2,2,1] 解释：上图展示了每朵花的花期时间，和每个人的到达时间。 对每个人，我们返回他们到达时在花期内花的数目。 提示：\n1 \u0026lt;= flowers.length \u0026lt;= 5 * 10^4 flowers[i].length == 2 1 \u0026lt;= starti \u0026lt;= endi \u0026lt;= 10^9 1 \u0026lt;= persons.length \u0026lt;= 5 * 10^4 1 \u0026lt;= persons[i] \u0026lt;= 10^9 排序+二分 正在开的花的个数 为所有在此时间节点及之前开放的花的个数减去在时间节点之前凋谢的花的个数\n先分别存下花期的开始时间和结束时间，排序\n然后二分查找满足条件的花\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: vector\u0026lt;int\u0026gt; fullBloomFlowers(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; flowers, vector\u0026lt;int\u0026gt;\u0026amp; persons) { vector\u0026lt;int\u0026gt; s,t; for(auto \u0026amp;x: flowers){ s.push_back(x[0]); t.push_back(x[1]); } sort(s.begin(),s.end()); sort(t.begin(),t.end()); vector\u0026lt;int\u0026gt; res; for(auto \u0026amp;time: persons){ int all = upper_bound(s.begin(),s.end(),time)-s.begin();//开花期第一个大于当前时间time的花的索引，即有all个开花期小于等于当前时间，也就是最多观赏到all朵花 int minus = upper_bound(t.begin(),t.end(),time-1)-t.begin();//凋谢时间第一个大于当前时间time-1的花的索引，即有minus个凋谢时间小于等于当前时间-1，也就是说minus个看不到，而这minus个一定在前面all个当中 // cout\u0026lt;\u0026lt;all\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;minus\u0026lt;\u0026lt;endl; res.push_back(all-minus); } return res; } }; 差分 把flowers[i]分成两个点：(flowers[i][0],-INF)表示花期的开始，(flowers[i][1],INF)表示花期的结束，每个询问看成一个点(person[i],i)\n这样做是为了方便排序。维护变量now，表示花的变化量，遇到花期开始则now++，遇到花期结束则now\u0026ndash;，询问答案就是当前now值\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 1e9; public: vector\u0026lt;int\u0026gt; fullBloomFlowers(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; flowers, vector\u0026lt;int\u0026gt;\u0026amp; persons) { vector\u0026lt;pii\u0026gt; vec; for (auto \u0026amp;f : flowers) vec.push_back(pii(f[0], -INF)), vec.push_back(pii(f[1], INF)); for (int i = 0; i \u0026lt; persons.size(); i++) vec.push_back(pii(persons[i], i)); sort(vec.begin(), vec.end()); vector\u0026lt;int\u0026gt; ans(persons.size()); int now = 0; for (pii p : vec) { if (p.second == -INF) now++; else if (p.second == INF) now--; else ans[p.second] = now; } return ans; } }; 动态开点线段树 记录在力扣题解上：\n动态开点线段树（C++）【区间修改+单点查询】\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #define ll long long const int MAXM = 4e6+5; const int MAXN = 1e9+5; struct{ int lson,rson; ll sum,tag; }T[MAXM]; int tot,root; class Solution { public: void push_up(int \u0026amp;p){ T[p].sum = T[T[p].lson].sum + T[T[p].rson].sum; } void push_down(int \u0026amp;p, int l, int r){ if(!T[p].tag) return; if(!T[p].lson){ T[p].lson = ++tot; T[T[p].lson] = {0,0,0,0}; } if(!T[p].rson){ T[p].rson = ++tot; T[T[p].rson] = {0,0,0,0}; } int mid = (l+r)\u0026gt;\u0026gt;1; T[T[p].lson].tag += T[p].tag; T[T[p].rson].tag += T[p].tag; T[T[p].lson].sum += (mid-l+1)*T[p].tag; T[T[p].rson].sum += (r-mid)*T[p].tag; T[p].tag = 0; } void update(int \u0026amp;p, int l, int r, int nl, int nr, int k){ if(!p){ p = ++tot; T[p] = {0,0,0,0}; } if(nl\u0026lt;=l \u0026amp;\u0026amp; nr\u0026gt;=r){ T[p].sum += k*(T[p].rson-T[p].lson+1); T[p].tag += k; return; } push_down(p,l,r); int mid = (l+r)\u0026gt;\u0026gt;1; if(nl\u0026lt;=mid) update(T[p].lson,l,mid,nl,nr,k); if(nr\u0026gt;mid) update(T[p].rson,mid+1,r,nl,nr,k); push_up(p); } int query(int p,int l, int r, int nl, int nr){ if(nl\u0026lt;=l \u0026amp;\u0026amp; nr\u0026gt;=r) return T[p].sum; int res = 0, mid = (l+r)\u0026gt;\u0026gt;1; push_down(p,l,r); if(nl\u0026lt;=mid) res+=query(T[p].lson,l,mid,nl,nr); if(nr\u0026gt;mid) res+=query(T[p].rson,mid+1,r,nl,nr); return res; } vector\u0026lt;int\u0026gt; fullBloomFlowers(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; flowers, vector\u0026lt;int\u0026gt;\u0026amp; persons) { tot = 0; root = 0; for(auto \u0026amp;x:flowers){ update(root,1,MAXN,x[0],x[1],1); } vector\u0026lt;int\u0026gt; res; for(auto \u0026amp;x:persons){ res.push_back(query(root,1,MAXN,x,x)); } return res; } }; 离散化+线段树 还可以利用离散化+线段树，它们的目的都是尽量减少所需要的节点数目。\n虽然时间值域很大，达$10^9$，但是注意到花期+每个人的到达时间 总共的时间数量不超过 $2\\times 5e4 + 5e4$，所以可以进行离散化，*将所有时间放在一起排序后，用它们在数组中的索引来代替原来的值即可*。\n然后可以进行去重，除掉重复的元素。\n有个细节是实现的线段树节点编号是以1开始索引的，所以后面使用区间范围时要+1（不然是0开始）\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #define ls(p) (p\u0026lt;\u0026lt;1) #define rs(p) (p\u0026lt;\u0026lt;1|1) const int MAXN = 150000+5;//2*5e4+5e4 vector\u0026lt;int\u0026gt; times; struct{ long long sum,tag; }T[MAXN\u0026lt;\u0026lt;2]; void push_up(int p){ T[p].sum = T[ls(p)].sum+T[rs(p)].sum; } void push_down(int p, int l, int r){ if(!T[p].tag) return; T[ls(p)].tag += T[p].tag; T[rs(p)].tag += T[p].tag; int mid = (l+r)\u0026gt;\u0026gt;1; T[ls(p)].sum += T[p].tag*(mid-l+1); T[rs(p)].sum += T[p].tag*(r-mid); T[p].tag = 0; } void build(int p, int l, int r){ if(l==r){ T[p].sum=0; T[p].tag=0; return; } T[p].sum=0,T[p].tag=0; int mid = (l+r)\u0026gt;\u0026gt;1; build(ls(p),l,mid); build(rs(p),mid+1,r); push_up(p); } void update(int p, int l, int r, int nl, int nr, int k){ if(nl\u0026lt;=l \u0026amp;\u0026amp; nr\u0026gt;=r){ T[p].tag += k; T[p].sum += (r-l+1)*k; return; } push_down(p,l,r); int mid = (l+r)\u0026gt;\u0026gt;1; if(nl\u0026lt;=mid) update(ls(p),l,mid,nl,nr,k); if(nr\u0026gt;mid) update(rs(p),mid+1,r,nl,nr,k); push_up(p); } int query(int p, int l, int r, int nl, int nr){ if(nl\u0026lt;=l \u0026amp;\u0026amp; nr\u0026gt;=r) return T[p].sum; push_down(p,l,r); int res = 0, mid = (l+r)\u0026gt;\u0026gt;1; if(nl\u0026lt;=mid) res += query(ls(p),l,mid,nl,nr); if(nr\u0026gt;mid) res += query(rs(p),mid+1,r,nl,nr); return res; } class Solution { public: vector\u0026lt;int\u0026gt; fullBloomFlowers(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; flowers, vector\u0026lt;int\u0026gt;\u0026amp; persons) { int n = flowers.size()*2+persons.size(); times.resize(n); for(int i=0;i\u0026lt;flowers.size();i++){ times[i\u0026lt;\u0026lt;1] = flowers[i][0]; times[i\u0026lt;\u0026lt;1|1] = flowers[i][1]; } for(int i=0;i\u0026lt;persons.size();i++){ times[(flowers.size()\u0026lt;\u0026lt;1)+i] = persons[i]; } sort(times.begin(),times.end()); times.erase(unique(times.begin(),times.end()),times.end()); n = times.size(); //离散化后排序去重，后面在用它们的值时利用它们在times数组中的索引即可 build(1,1,n); for(auto \u0026amp;x: flowers){ int nl = lower_bound(times.begin(),times.end(),x[0])-times.begin()+1; int nr = lower_bound(times.begin(),times.end(),x[1])-times.begin()+1; update(1,1,n,nl,nr,1); } vector\u0026lt;int\u0026gt; res; for(auto \u0026amp;x:persons){ int idx = lower_bound(times.begin(),times.end(),x)-times.begin()+1; res.push_back(query(1,1,n,idx,idx)); } return res; } }; ","date":"2022-04-25T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC290%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220425_hu10007172685289977783.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC290%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第290场周赛总结"},{"content":"【模拟】找到最接近0的数字 题目 给你一个长度为 n 的整数数组 nums ，请你返回 nums 中最 接近 0 的数字。如果有多个答案，请你返回它们中的 最大值 。\n示例 1：\n1 2 3 4 5 6 7 8 9 输入：nums = [-4,-2,1,4,8] 输出：1 解释： -4 到 0 的距离为 |-4| = 4 。 -2 到 0 的距离为 |-2| = 2 。 1 到 0 的距离为 |1| = 1 。 4 到 0 的距离为 |4| = 4 。 8 到 0 的距离为 |8| = 8 。 所以，数组中距离 0 最近的数字为 1 。 示例 2：\n1 2 3 输入：nums = [2,-1,1] 输出：1 解释：1 和 -1 都是距离 0 最近的数字，所以返回较大值 1 。 提示：\n1 \u0026lt;= n \u0026lt;= 1000 -105 \u0026lt;= nums[i] \u0026lt;= 10^5 解题思路 找绝对值最小的，若相同则选正数\n代码 1 2 3 4 5 6 7 8 9 10 11 class Solution { public: int findClosestNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int res = nums[0]; for(auto x: nums){ if(abs(x) \u0026lt; abs(res)) res = x; else if(abs(x) == abs(res)) res = max(res, x); } return res; } }; 【枚举】买钢笔和铅笔的方案数 题目 给你一个整数 total ，表示你拥有的总钱数。同时给你两个整数 cost1 和 cost2 ，分别表示一支钢笔和一支铅笔的价格。你可以花费你部分或者全部的钱，去买任意数目的两种笔。\n请你返回购买钢笔和铅笔的 不同方案数目 。\n示例 1：\n1 2 3 4 5 6 7 输入：total = 20, cost1 = 10, cost2 = 5 输出：9 解释：一支钢笔的价格为 10 ，一支铅笔的价格为 5 。 - 如果你买 0 支钢笔，那么你可以买 0 ，1 ，2 ，3 或者 4 支铅笔。 - 如果你买 1 支钢笔，那么你可以买 0 ，1 或者 2 支铅笔。 - 如果你买 2 支钢笔，那么你没法买任何铅笔。 所以买钢笔和铅笔的总方案数为 5 + 3 + 1 = 9 种。 示例 2：\n1 2 3 输入：total = 5, cost1 = 10, cost2 = 10 输出：1 解释：钢笔和铅笔的价格都为 10 ，都比拥有的钱数多，所以你没法购买任何文具。所以只有 1 种方案：买 0 支钢笔和 0 支铅笔。 提示：\n1 \u0026lt;= total, cost1, cost2 \u0026lt;= 10^6 解题思路 先算出最多买钢笔的数量max1，那么钢笔可买范围为[0,max1]\n然后再算出铅笔可买数量范围\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: long long waysToBuyPensPencils(int total, int cost1, int cost2) { long long max1 = total/cost1; long long res = 0; for(int i=0;i\u0026lt;=max1;i++){//钢笔 long long rest = (long long)total - i*cost1; long long max2 = rest/cost2; res += (max2-0+1); } return res; } }; 【模拟】设计一个 ATM 机器 题目 一个 ATM 机器，存有 5 种面值的钞票：20 ，50 ，100 ，200 和 500 美元。初始时，ATM 机是空的。用户可以用它存或者取任意数目的钱。\n取款时，机器会优先取 较大 数额的钱。\n比方说，你想取 $300 ，并且机器里有 2 张 $50 的钞票，1 张 $100 的钞票和1 张 $200 的钞票，那么机器会取出 $100 和 $200 的钞票。 但是，如果你想取 $600 ，机器里有 3 张 $200 的钞票和1 张 $500 的钞票，那么取款请求会被拒绝，因为机器会先取出 $500 的钞票，然后无法取出剩余的 $100 。注意，因为有 $500 钞票的存在，机器 不能 取 $200 的钞票。 请你实现 ATM 类：\nATM() 初始化 ATM 对象。 void deposit(int[] banknotesCount) 分别存入 $20 ，$50，$100，$200 和 $500 钞票的数目。 int[] withdraw(int amount) 返回一个长度为 5 的数组，分别表示 $20 ，$50，$100 ，$200 和 $500 钞票的数目，并且更新 ATM 机里取款后钞票的剩余数量。如果无法取出指定数额的钱，请返回 [-1] （这种情况下 不 取出任何钞票）。 示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 输入： [\u0026#34;ATM\u0026#34;, \u0026#34;deposit\u0026#34;, \u0026#34;withdraw\u0026#34;, \u0026#34;deposit\u0026#34;, \u0026#34;withdraw\u0026#34;, \u0026#34;withdraw\u0026#34;] [[], [[0,0,1,2,1]], [600], [[0,1,0,1,1]], [600], [550]] 输出： [null, null, [0,0,1,0,1], null, [-1], [0,1,0,0,1]] 解释： ATM atm = new ATM(); atm.deposit([0,0,1,2,1]); // 存入 1 张 $100 ，2 张 $200 和 1 张 $500 的钞票。 atm.withdraw(600); // 返回 [0,0,1,0,1] 。机器返回 1 张 $100 和 1 张 $500 的钞票。机器里剩余钞票的数量为 [0,0,0,2,0] 。 atm.deposit([0,1,0,1,1]); // 存入 1 张 $50 ，1 张 $200 和 1 张 $500 的钞票。 // 机器中剩余钞票数量为 [0,1,0,3,1] 。 atm.withdraw(600); // 返回 [-1] 。机器会尝试取出 $500 的钞票，然后无法得到剩余的 $100 ，所以取款请求会被拒绝。 // 由于请求被拒绝，机器中钞票的数量不会发生改变。 atm.withdraw(550); // 返回 [0,1,0,0,1] ，机器会返回 1 张 $50 的钞票和 1 张 $500 的钞票。 提示：\nbanknotesCount.length == 5 0 \u0026lt;= banknotesCount[i] \u0026lt;= 10^9 1 \u0026lt;= amount \u0026lt;= 10^9 总共 最多有 5000 次 withdraw 和 deposit 的调用。 函数 withdraw 和 deposit 至少各有 一次 调用。 解题思路 模拟即可\n但这题的数据范围很搞啊\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class ATM { private: vector\u0026lt;long long\u0026gt; money;//每种钞票的数量 public: ATM() { money.assign(5,0);//20 50 100 200 500 } void deposit(vector\u0026lt;int\u0026gt; banknotesCount) { for(int i=0;i\u0026lt;5;i++){ money[i] += banknotesCount[i]; // cout\u0026lt;\u0026lt;money[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } } vector\u0026lt;int\u0026gt; withdraw(int amount) { vector\u0026lt;long long\u0026gt; res(5,0); int val[5] = {20,50,100,200,500}; for(int i=4;i\u0026gt;=0;i--){ long long need = amount/val[i]; need = min(need, money[i]); amount -= need*val[i]; res[i] = need; } if(amount) return {-1}; else { for(int i=0;i\u0026lt;5;i++) money[i]-=res[i]; return vector\u0026lt;int\u0026gt;(res.begin(),res.end()); } } }; /** * Your ATM object will be instantiated and called as such: * ATM* obj = new ATM(); * obj-\u0026gt;deposit(banknotesCount); * vector\u0026lt;int\u0026gt; param_2 = obj-\u0026gt;withdraw(amount); */ 【枚举】节点序列的最大得分 题目 给你一个 n 个节点的 无向图 ，节点编号为 0 到 n - 1 。\n给你一个下标从 0 开始的整数数组 scores ，其中 scores[i] 是第 i 个节点的分数。同时给你一个二维整数数组 edges ，其中 edges[i] = [ai, bi] ，表示节点 ai 和 bi 之间有一条 无向 边。\n一个合法的节点序列如果满足以下条件，我们称它是 合法的 ：\n序列中每 相邻 节点之间有边相连。 序列中没有节点出现超过一次。 节点序列的分数定义为序列中节点分数之 和 。\n请你返回一个长度为 4 的合法节点序列的最大分数。如果不存在这样的序列，请你返回 -1 。\n示例 1：\n1 2 3 4 5 6 7 输入：scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]] 输出：24 解释：上图为输入的图，节点序列为 [0,1,2,3] 。 节点序列的分数为 5 + 2 + 9 + 8 = 24 。 观察可知，没有其他节点序列得分和超过 24 。 注意节点序列 [3,1,2,0] 和 [1,0,2,3] 也是合法的，且分数为 24 。 序列 [0,3,2,4] 不是合法的，因为没有边连接节点 0 和 3 。 示例 2：\n1 2 3 4 输入：scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]] 输出：-1 解释：上图为输入的图。 没有长度为 4 的合法序列，所以我们返回 -1 。 提示：\nn == scores.length 4 \u0026lt;= n \u0026lt;= 5 * 10^4 1 \u0026lt;= scores[i] \u0026lt;= 10^8 0 \u0026lt;= edges.length \u0026lt;= 5 * 10^4 edges[i].length == 2 0 \u0026lt;= ai, bi \u0026lt;= n - 1 ai != bi 不会有重边。 解题思路 思路很有意思\n要找一个长度为4的链，可以先枚举中间的2个节点u和v（链中间的那条边）。为了让链的点权值之和最大，那么剩下的两个点应该选择与u相邻的，排除v以外权值最大的点a , 以及与v相邻的，排除u以外权值最大的点b。\n注意特殊情况：点a和点b不能是同一个点，所以需要找出与u相邻的最大的3个点。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #define P pair\u0026lt;int,int\u0026gt; class Solution { public: vector\u0026lt;vector\u0026lt;P\u0026gt;\u0026gt; G; int maximumScore(vector\u0026lt;int\u0026gt;\u0026amp; scores, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { int n = scores.size(); G.resize(n); for(auto x: edges){ int u = x[0],v=x[1]; G[u].push_back(P(v,scores[v])); G[v].push_back(P(u,scores[u])); } for(int i=0;i\u0026lt;n;i++){ sort(G[i].begin(),G[i].end(),[\u0026amp;](P a, P b){ return a.second\u0026gt;b.second; }); }//邻接表，按权值从大到小排列 int res = -1; for(auto x: edges){ int u=x[0],v=x[1];//枚举中间的两个点 for(int i=0;i\u0026lt;3 \u0026amp;\u0026amp; i\u0026lt;G[u].size();i++){//和点u连接的最大权值的3个点 int a = G[u][i].first; for(int j=0;j\u0026lt;3 \u0026amp;\u0026amp; j\u0026lt;G[v].size();j++){//和点v连接的最大权值的3个点 int b = G[v][j].first; if(a!=b \u0026amp;\u0026amp; a!=v \u0026amp;\u0026amp; b!=u){//互不相等时更新答案 res = max(res, scores[u]+scores[v]+scores[a]+scores[b]); } } } } return res; } }; ","date":"2022-04-23T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC76%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220423_hu744854846967412773.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC76%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第76场双周赛总结"},{"content":"引言 树型DP求树的直径——CSDN\n树的直径——CSDN\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 //树形dp解树的直径的两种写法： //第一种写法 int vis[N]; int res=INT_MIN; //初始为一个很小的值 int d[N],f[N];//d[u]为节点u到其子孙节点的最长路径 f[u]为u为根节点时最长路径和（u的最长+u的次长） void dfs(int u){ vis[u]=1; //遍历u的出边 for(int i=head[u];i\u0026gt;=0;i=e[i].next){ int v=e[i].v; int w=e[i].w; if(!vis[v]){ //如果是u的子节点 dfs(v);//计算子节点的信息 /*一定是先计算f[u]再计算d[u]的 如果先计算d[u]的话，f[u]就会计算 最长路径+最长路径，也就是说会重复计算最长路径 边权可能为负的情况*/ f[u]=max(max(f[u],d[u]),max(d[v]+w,d[u]+d[v]+w)); d[u]=max(max(d[u],w),d[v]+w); } } } dfs(1); for(int i=1;i\u0026lt;=n;i++) res=max(res,f[i]); printf(\u0026#34;%d\\n\u0026#34;,res); //第二种写法： int vis[N]; int res=INT_MIN; int dfs(int u){//dfs(u) 计算d[u]的值 vis[u]=1; int ud=0; for(int i=head[u];i\u0026gt;=0;i=e[i].next){ int v=e[i].v; int w=e[i].w; if(!vis[v]){ int vd=dfs(v);//计算d[v] //原res值 //ud\u0026gt;=0 ，最长路径 ， 避免次长路径为负 //vd+w， 次长路径，避免ud未赋值时情况 //ud+vd+w，最长路径+次长路径 res=max(max(res,ud),max(vd+w,ud+vd+w)); //原ud值 //w，避免子孙为负 //vd+w，vd\u0026gt;=0，加上w ud=max(max(ud,w),vd+w); } } return ud; } 二叉树的直径 题目 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。\n示例 : 给定二叉树\n1 / \\ 2 3 / \\ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。\n注意：两结点之间的路径长度是以它们之间边的数目表示。\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/diameter-of-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 路径长度改成路径上边的数目\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int res; int dfs(TreeNode* root){//root到其子孙节点最大路径节点个数 if(root == nullptr) return 0; int t1 = 0, t2 = 0;//最长，次长 t1 = dfs(root-\u0026gt;left); t2 = dfs(root-\u0026gt;right); if(t1\u0026lt;t2) swap(t1,t2);//确保t1\u0026gt;t2 res = max(res,t1+t2+1);// return t1+1;//一条边的权值为1 } int diameterOfBinaryTree(TreeNode* root) { dfs(root); return res-1;//节点个数-1为路径长度 } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { private: int res=INT_MIN; public: int dfs(TreeNode* root){ if(root==nullptr) return 0; int d=0; int l=dfs(root-\u0026gt;left); int r=dfs(root-\u0026gt;right); d=max(l+1,r+1); res=max(res,l+r); return d; } int diameterOfBinaryTree(TreeNode* root) { dfs(root); return res; } }; 二叉树的最大路径和 题目 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。\n路径和 是路径中各节点值的总和。\n给你一个二叉树的根节点 root ，返回其 最大路径和 。\n示例 1：\n输入：root = [1,2,3] 输出：6 解释：最优路径是 2 -\u0026gt; 1 -\u0026gt; 3 ，路径和为 2 + 1 + 3 = 6 示例 2：\n输入：root = [-10,9,20,null,null,15,7] 输出：42 解释：最优路径是 15 -\u0026gt; 20 -\u0026gt; 7 ，路径和为 15 + 20 + 7 = 42\n提示：\n树中节点数目范围是 [1, 3 * 10^4]\n-1000 \u0026lt;= Node.val \u0026lt;= 1000\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-maximum-path-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 模板题中的路径和是路径上边的权值，而此处是路径上点的权值。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int res=-3e7; int dfs(TreeNode* root){//root到其子孙节点的最大路径和 if(root == nullptr) return 0; int maxd = -3e7;//当前root到子孙节点的最大路径和 int dL = dfs(root-\u0026gt;left); //原res，最大路径，次大路径，最大+次大 res = max(max(res,maxd),max(dL+root-\u0026gt;val,maxd+dL)); maxd = max(maxd,max(root-\u0026gt;val,dL+root-\u0026gt;val)); int dR = dfs(root-\u0026gt;right); res = max(max(res,maxd),max(dR+root-\u0026gt;val,maxd+dR)); maxd = max(maxd,max(root-\u0026gt;val,dR+root-\u0026gt;val)); return maxd; } int maxPathSum(TreeNode* root) { dfs(root); return res; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private: int res=INT_MIN; public: int dfs(TreeNode *root){ if(root==nullptr) return 0; int d=root-\u0026gt;val; int l=dfs(root-\u0026gt;left); int r=dfs(root-\u0026gt;right); res=max(max(res,d+l+r),max(d,max(d+r,d+l))); d=max(d,max(d+l,d+r)); return d; //返回 以当前节点为根的到达子孙节点的最长路径和 } int maxPathSum(TreeNode* root) { dfs(root); return res; } }; 如果不用上述思想：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { private: int maxSum = INT_MIN; public: int maxGain(TreeNode* node) { if (node == nullptr) { return 0; } // 递归计算左右子节点的最大贡献值 // 只有在最大贡献值大于 0 时，才会选取对应子节点 int leftGain = max(maxGain(node-\u0026gt;left), 0); int rightGain = max(maxGain(node-\u0026gt;right), 0); // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值 int priceNewpath = node-\u0026gt;val + leftGain + rightGain; // 更新答案 maxSum = max(maxSum, priceNewpath); // 返回节点的最大贡献值 return node-\u0026gt;val + max(leftGain, rightGain); } int maxPathSum(TreeNode* root) { maxGain(root); return maxSum; } }; 最长同值路径 题目 给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。\n两个节点之间的路径长度 由它们之间的边数表示。\n示例 1:\n输入：root = [5,4,5,1,1,5] 输出：2 示例 2:\n输入：root = [1,4,5,4,4,5] 输出：2\n提示:\n树的节点数的范围是 [0, 10^4]\n-1000 \u0026lt;= Node.val \u0026lt;= 1000\n树的深度将不超过 1000\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-univalue-path 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 最长路径长度加了个同值的条件\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int res = 1; int dfs(TreeNode* u){//u到子孙节点的最长同值路径节点个数 int t1 = 0, t2 = 0;//最长 次长 if(u-\u0026gt;left){ if(u-\u0026gt;left-\u0026gt;val == u-\u0026gt;val){//同值情况，更新答案 int dv = dfs(u-\u0026gt;left); if(dv\u0026gt;t1) t2=t1,t1=dv; else if(dv\u0026gt;t2) t2=dv; res = max(res,t1+t2+1); }else{ dfs(u-\u0026gt;left); } } if(u-\u0026gt;right){ if(u-\u0026gt;right-\u0026gt;val == u-\u0026gt;val){ int dv = dfs(u-\u0026gt;right); if(dv\u0026gt;t1) t2=t1,t1=dv; else if(dv\u0026gt;t2) t2=dv; res = max(res,t1+t2+1); }else{ dfs(u-\u0026gt;right); } } return t1+1; } int longestUnivaluePath(TreeNode* root) { if(root == nullptr) return 0; dfs(root); return res-1;//节点个数-1为路径长度 } }; 相邻字符不同的最长路径 题目 给你一棵 树（即一个连通、无向、无环图），根节点是节点 0 ，这棵树由编号从 0 到 n - 1 的 n 个节点组成。用下标从 0 开始、长度为 n 的数组 parent 来表示这棵树，其中 parent[i] 是节点 i 的父节点，由于节点 0 是根节点，所以 parent[0] == -1 。\n另给你一个字符串 s ，长度也是 n ，其中 s[i] 表示分配给节点 i 的字符。\n请你找出路径上任意一对相邻节点都没有分配到相同字符的 最长路径 ，并返回该路径的长度。\n示例 1：\n1 2 3 4 输入：parent = [-1,0,0,1,1,2], s = \u0026#34;abacbe\u0026#34; 输出：3 解释：任意一对相邻节点字符都不同的最长路径是：0 -\u0026gt; 1 -\u0026gt; 3 。该路径的长度是 3 ，所以返回 3 。 可以证明不存在满足上述条件且比 3 更长的路径。 示例 2：\n1 2 3 输入：parent = [-1,0,0,0], s = \u0026#34;aabc\u0026#34; 输出：3 解释：任意一对相邻节点字符都不同的最长路径是：2 -\u0026gt; 0 -\u0026gt; 3 。该路径的长度为 3 ，所以返回 3 。 提示：\nn == parent.length == s.length 1 \u0026lt;= n \u0026lt;= 105 对所有 i \u0026gt;= 1 ，0 \u0026lt;= parent[i] \u0026lt;= n - 1 均成立 parent[0] == -1 parent 表示一棵有效的树 s 仅由小写英文字母组成 解题思路 289场周赛第4题\n求最长路径，但相邻两节点字符不同\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G;//邻接矩阵 string s; int res; int dfs(int u){//节点u到其子孙节点合法的最长距离 int t1=0,t2=0;//子节点到其子孙节点合法的最长距离、子节点到其子孙节点合法的次长距离 for(auto v:G[u]){//遍历子节点 if(s[v] == s[u]){//相邻字符相同 即子节点与父亲节点字符相同 dfs(v);//求子节点到其子孙节点合法的最长距离 }else{ int cur = dfs(v); if(cur\u0026gt;t1) t2 = t1, t1 = cur;//更新最大值 else if(cur\u0026gt;t2) t2 = cur;//更新次大值 } } res = max(res,t1+t2+1);//以u为根节点的最长路径：最长+次长+1 return t1+1;//加上本身的1 } int longestPath(vector\u0026lt;int\u0026gt;\u0026amp; parent, string s) { G.resize(parent.size()); this-\u0026gt;s = s; for(int i=1;i\u0026lt;parent.size();i++) G[parent[i]].push_back(i);//建图 dfs(0);//从根节点出发 return res; } }; ","date":"2022-04-21T00:00:00Z","image":"https://tetsuou.github.io/p/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/post-bg-20220421_hu17694566491219905023.png","permalink":"https://tetsuou.github.io/p/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/","title":"树的直径"},{"content":"\n第3题都快做晕了~\n【模拟】计算字符串的数字和 题目 给你一个由若干数字（0 - 9）组成的字符串 s ，和一个整数。\n如果 s 的长度大于 k ，则可以执行一轮操作。在一轮操作中，需要完成以下工作：\n将 s 拆分 成长度为 k 的若干 连续数字组 ，使得前 k 个字符都分在第一组，接下来的 k 个字符都分在第二组，依此类推。注意，最后一个数字组的长度可以小于 k 。 用表示每个数字组中所有数字之和的字符串来 替换 对应的数字组。例如，\u0026quot;346\u0026quot; 会替换为 \u0026quot;13\u0026quot; ，因为 3 + 4 + 6 = 13 。 合并 所有组以形成一个新字符串。如果新字符串的长度大于 k 则重复第一步。 返回在完成所有轮操作后的 s 。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 输入：s = \u0026#34;11111222223\u0026#34;, k = 3 输出：\u0026#34;135\u0026#34; 解释： - 第一轮，将 s 分成：\u0026#34;111\u0026#34;、\u0026#34;112\u0026#34;、\u0026#34;222\u0026#34; 和 \u0026#34;23\u0026#34; 。 接着，计算每一组的数字和：1 + 1 + 1 = 3、1 + 1 + 2 = 4、2 + 2 + 2 = 6 和 2 + 3 = 5 。 这样，s 在第一轮之后变成 \u0026#34;3\u0026#34; + \u0026#34;4\u0026#34; + \u0026#34;6\u0026#34; + \u0026#34;5\u0026#34; = \u0026#34;3465\u0026#34; 。 - 第二轮，将 s 分成：\u0026#34;346\u0026#34; 和 \u0026#34;5\u0026#34; 。 接着，计算每一组的数字和：3 + 4 + 6 = 13 、5 = 5 。 这样，s 在第二轮之后变成 \u0026#34;13\u0026#34; + \u0026#34;5\u0026#34; = \u0026#34;135\u0026#34; 。 现在，s.length \u0026lt;= k ，所以返回 \u0026#34;135\u0026#34; 作为答案。 示例 2：\n1 2 3 4 5 6 输入：s = \u0026#34;00000000\u0026#34;, k = 3 输出：\u0026#34;000\u0026#34; 解释： 将 \u0026#34;000\u0026#34;, \u0026#34;000\u0026#34;, and \u0026#34;00\u0026#34;. 接着，计算每一组的数字和：0 + 0 + 0 = 0 、0 + 0 + 0 = 0 和 0 + 0 = 0 。 s 变为 \u0026#34;0\u0026#34; + \u0026#34;0\u0026#34; + \u0026#34;0\u0026#34; = \u0026#34;000\u0026#34; ，其长度等于 k ，所以返回 \u0026#34;000\u0026#34; 。 提示：\n1 \u0026lt;= s.length \u0026lt;= 100 2 \u0026lt;= k \u0026lt;= 100 s 仅由数字（0 - 9）组成。 解题思路 简单模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: string digitSum(string s, int k) { int res = 0; while(s.size()\u0026gt;k){ int len = s.size(); string news; int loop =0,cur = 0; for(int i=0;i\u0026lt;len;i++){ cur += s[i]-\u0026#39;0\u0026#39;; loop++; if(loop==k){ loop = 0; news = news + to_string(cur); cur = 0; } } if(loop) { news = news + to_string(cur); } s = news; // cout\u0026lt;\u0026lt;news\u0026lt;\u0026lt;endl; } return s; } }; 【找规律】完成所有任务需要的最少轮数 题目 给你一个下标从 0 开始的整数数组 tasks ，其中 tasks[i] 表示任务的难度级别。在每一轮中，你可以完成 2 个或者 3 个 相同难度级别 的任务。\n返回完成所有任务需要的 最少 轮数，如果无法完成所有任务，返回 -1 。\n示例 1：\n1 2 3 4 5 6 7 8 输入：tasks = [2,2,3,3,2,4,4,4,4,4] 输出：4 解释：要想完成所有任务，一个可能的计划是： - 第一轮，完成难度级别为 2 的 3 个任务。 - 第二轮，完成难度级别为 3 的 2 个任务。 - 第三轮，完成难度级别为 4 的 3 个任务。 - 第四轮，完成难度级别为 4 的 2 个任务。 可以证明，无法在少于 4 轮的情况下完成所有任务，所以答案为 4 。 示例 2：\n1 2 3 输入：tasks = [2,3,3] 输出：-1 解释：难度级别为 2 的任务只有 1 个，但每一轮执行中，只能选择完成 2 个或者 3 个相同难度级别的任务。因此，无法完成所有任务，答案为 -1 。 提示：\n1 \u0026lt;= tasks.length \u0026lt;= 10^5 1 \u0026lt;= tasks[i] \u0026lt;= 10^9 解题思路 若这种任务只有 1个，则无法完成； 若这种任务只有 2 个，可以一次完成； 若这种任务数量是 3 的倍数，显然每次完成 3 个是最快的； 若这种任务数量除 3 余 1，需要每次完成 3 个，最后 4 个分两次完成； 若这种任务数量除 3 余 2，需要每次完成 3 个，最后完成 2 个。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: int minimumRounds(vector\u0026lt;int\u0026gt;\u0026amp; tasks) { unordered_map\u0026lt;int,int\u0026gt; table; for(auto x:tasks){ if(table.count(x)) table[x]++; else table[x]=1; } int res = 0; for(auto [level,num]:table){ // cout\u0026lt;\u0026lt;level\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;num\u0026lt;\u0026lt;endl; int cnt = num/3; int mod = num%3; if(mod == 0){ res += cnt; }else if(mod == 1){ if(num == 1) return -1; cnt = (num - 2) /3; res += 1; res += cnt; res += 1;//必定剩余2 }else if(mod == 2){ res += cnt; res += 1; } } return res; } }; 【前缀和、枚举】转角路径的乘积中最多能有几个尾随零 题目 给你一个二维整数数组 grid ，大小为 m x n，其中每个单元格都含一个正整数。\n转角路径 定义为：包含至多一个弯的一组相邻单元。具体而言，路径应该完全 向水平方向 或者 向竖直方向 移动过弯（如果存在弯），而不能访问之前访问过的单元格。在过弯之后，路径应当完全朝 另一个 方向行进：如果之前是向水平方向，那么就应该变为向竖直方向；反之亦然。当然，同样不能访问之前已经访问过的单元格。\n一条路径的 乘积 定义为：路径上所有值的乘积。\n请你从 grid 中找出一条乘积中尾随零数目最多的转角路径，并返回该路径中尾随零的数目。\n注意：\n水平 移动是指向左或右移动。 竖直 移动是指向上或下移动。 示例 1：\n1 2 3 4 5 6 7 8 输入：grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]] 输出：3 解释：左侧的图展示了一条有效的转角路径。 其乘积为 15 * 20 * 6 * 1 * 10 = 18000 ，共计 3 个尾随零。 可以证明在这条转角路径的乘积中尾随零数目最多。 中间的图不是一条有效的转角路径，因为它有不止一个弯。 右侧的图也不是一条有效的转角路径，因为它需要重复访问已经访问过的单元格。 示例 2：\n1 2 3 4 输入：grid = [[4,3,2],[7,6,1],[8,8,8]] 输出：0 解释：网格如上图所示。 不存在乘积含尾随零的转角路径。 提示：\nm == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 10^5 1 \u0026lt;= m * n \u0026lt;= 10^5 1 \u0026lt;= grid[i][j] \u0026lt;= 1000 解题思路 最多有几个尾随零：取决于因子中2和5的最小个数\n那么重点就是找转角路径，使得路径中有最大的2和5因子的最小个数\n一开始还想深搜，但显然不可能。\n想了会确定好了思路：每次找的转角路径，要使其最长，如上面例1中的绿色路径，明显还可以把6加进去。\n那么就可以从边角出发，可以找先右后下的路径，或者是先下后右的路径，当然，还有先右后上和先上后右（我这里只算了前两种情况，后两种我将原矩阵进行行翻转后，再执行一次前两种情况一样可以达到效果）\n下图中每一对元素如（0，1），表示grid[0][0]中5的因子个数为0，2的因子个数为1。\n整体思路为：\n1）预处理原数据，转换为数据中包含的5因子个数和2因子个数\n2）计算行上前缀和 和 列上前缀和\n3）枚举拐点（或起点）计算4个方向（右下，右上，左下，左上）的情况，取最大值\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; int m,n;//m行n列 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; five,two,visit; int getnum5(int num){ int res = 0; while(num/5){ if(num%5==0) res++,num/=5; else break; } return res; } int getnum2(int num){ int res = 0; while(num/2){ if(num%2==0) res++,num/=2; else break; } return res; } //计算原矩阵的2因子个数和5因子个数 void init(){ for(int i=0;i\u0026lt;m;i++){ for(int j=0;j\u0026lt;n;j++){ five[i][j] = getnum5(G[i][j]); two[i][j] = getnum2(G[i][j]); } } } int work(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;a, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;b){//a:5 b:2 int res = 0; int pre5row[m][n],pre2row[m][n],pre5col[m][n],pre2col[m][n]; memset(pre5row,0,sizeof(pre5row)); memset(pre2row,0,sizeof(pre2row)); memset(pre5col,0,sizeof(pre5col)); memset(pre2col,0,sizeof(pre2col)); //计算前缀和 for(int i=0;i\u0026lt;m;i++){ pre5row[i][0] = a[i][0]; pre2row[i][0] = b[i][0]; for(int j=1;j\u0026lt;n;j++){ pre5row[i][j] = pre5row[i][j-1]+a[i][j]; pre2row[i][j] = pre2row[i][j-1]+b[i][j]; } } for(int j=0;j\u0026lt;n;j++){ pre5col[0][j] = a[0][j]; pre2col[0][j] = b[0][j]; for(int i=1;i\u0026lt;m;i++){ pre5col[i][j] = pre5col[i-1][j]+a[i][j]; pre2col[i][j] = pre2col[i-1][j]+b[i][j]; } } //右下 for(int i=0;i\u0026lt;m;i++){ for(int j=0;j\u0026lt;n;j++){ int numof5 = pre5row[i][j] + pre5col[m-1][j] - a[i][j]; if(i\u0026gt;0) numof5 -= pre5col[i-1][j]; int numof2 = pre2row[i][j] + pre2col[m-1][j] - b[i][j]; if(i\u0026gt;0) numof2 -= pre2col[i-1][j]; res = max(res, min(numof5,numof2)); } } //下右 for(int j=0;j\u0026lt;n;j++){ for(int i=0;i\u0026lt;m;i++){ int numof5 = pre5col[i][j] + pre5row[i][n-1] - a[i][j]; if(j\u0026gt;0) numof5 -= pre5row[i][j-1]; int numof2 = pre2col[i][j] + pre2row[i][n-1] - b[i][j]; if(j\u0026gt;0) numof2 -= pre2row[i][j-1]; res = max(res, min(numof5,numof2)); } } return res; } int maxTrailingZeros(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { G = grid; m = grid.size(); n = grid[0].size(); five.resize(m); for(auto \u0026amp;x:five) x.resize(n,0); two.resize(m); for(auto \u0026amp;x:two) x.resize(n,0); init(); int res = work(five,two); //行翻转后再调用一次 reverse(five.begin(),five.end()); reverse(two.begin(),two.end()); res = max(res, work(five,two) ); return res; } }; 偷学代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: int maxTrailingZeros(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(), m = grid[0].size();//n行m列 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f2(n + 1), g2(n + 1), f5(n + 1), g5(n + 1); for (int i = 0; i \u0026lt;= n; i++) f2[i] = g2[i] = f5[i] = g5[i] = vector\u0026lt;int\u0026gt;(m + 1); for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) { int x = grid[i - 1][j - 1]; int two = 0, five = 0; while (x % 2 == 0) two++, x /= 2; while (x % 5 == 0) five++, x /= 5; f2[i][j] = f2[i][j - 1] + two;//f2[i][j] 第i行第j列的行上前缀和 （2的总个数） g2[i][j] = g2[i - 1][j] + two;//g2[i][j] 第i行第j列的列上前缀和 （2的总个数） f5[i][j] = f5[i][j - 1] + five; g5[i][j] = g5[i - 1][j] + five; } int ans = 0; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) { // 从左边出发，到上边结束 ans = max(ans, min(f2[i][j] + g2[i - 1][j], f5[i][j] + g5[i - 1][j])); // 从左边出发，到下边结束 ans = max(ans, min(f2[i][j] + g2[n][j] - g2[i][j], f5[i][j] + g5[n][j] - g5[i][j])); // 从右边出发，到上边结束 ans = max(ans, min(f2[i][m] - f2[i][j] + g2[i][j], f5[i][m] - f5[i][j] + g5[i][j])); // 从右边出发，到下边结束 ans = max(ans, min(f2[i][m] - f2[i][j] + g2[n][j] - g2[i - 1][j], f5[i][m] - f5[i][j] + g5[n][j] - g5[i - 1][j])); } return ans; } }; tips 以后求前缀和，计算出来的前缀和数组还是用1开头计数吧。还是用0开始计数的话，不好写遍历，在=0的时候要加特判，而用1开始计数的话，就不用特判 （注意保证此时第0个元素为0）。\n还有，注意看全题目，一开始只注意到了n和m的范围是10^5，想着O(nm)的时间复杂度过不了。后来经人提醒发现，nm的乘积是小于10^5的。\n【DFS】相邻字符不同的最长路径 题目 给你一棵 树（即一个连通、无向、无环图），根节点是节点 0 ，这棵树由编号从 0 到 n - 1 的 n 个节点组成。用下标从 0 开始、长度为 n 的数组 parent 来表示这棵树，其中 parent[i] 是节点 i 的父节点，由于节点 0 是根节点，所以 parent[0] == -1 。\n另给你一个字符串 s ，长度也是 n ，其中 s[i] 表示分配给节点 i 的字符。\n请你找出路径上任意一对相邻节点都没有分配到相同字符的 最长路径 ，并返回该路径的长度。\n示例 1：\n1 2 3 4 输入：parent = [-1,0,0,1,1,2], s = \u0026#34;abacbe\u0026#34; 输出：3 解释：任意一对相邻节点字符都不同的最长路径是：0 -\u0026gt; 1 -\u0026gt; 3 。该路径的长度是 3 ，所以返回 3 。 可以证明不存在满足上述条件且比 3 更长的路径。 示例 2：\n1 2 3 输入：parent = [-1,0,0,0], s = \u0026#34;aabc\u0026#34; 输出：3 解释：任意一对相邻节点字符都不同的最长路径是：2 -\u0026gt; 0 -\u0026gt; 3 。该路径的长度为 3 ，所以返回 3 。 提示：\nn == parent.length == s.length 1 \u0026lt;= n \u0026lt;= 10^5 对所有 i \u0026gt;= 1 ，0 \u0026lt;= parent[i] \u0026lt;= n - 1 均成立 parent[0] == -1 parent 表示一棵有效的树 s 仅由小写英文字母组成 解题思路 这是道有关 树的直径 的问题，可以用树型DP解决，过几天再研究下这个专题\n具体回到这道题，没有那么复杂，首先明确：这里的最长路径长度，即一个根节点，加上两条（最长和次长）的子节点的路径（再加1）即可。\n然后需要判断是否有相邻节点分配到相同字符。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G;//邻接矩阵 string s; int res; int dfs(int u){//节点u到其子孙节点合法的最长距离 int t1=0,t2=0;//子节点到其子孙节点合法的最长距离、子节点到其子孙节点合法的次长距离 for(auto v:G[u]){//遍历子节点 if(s[v] == s[u]){//相邻字符相同 即子节点与父亲节点字符相同 dfs(v);//求子节点到其子孙节点合法的最长距离 }else{ int cur = dfs(v); if(cur\u0026gt;t1) t2 = t1, t1 = cur;//更新最大值 else if(cur\u0026gt;t2) t2 = cur;//更新次大值 } } res = max(res,t1+t2+1);//以u为根节点的最长路径：最长+次长+1 return t1+1;//加上本身的1 } int longestPath(vector\u0026lt;int\u0026gt;\u0026amp; parent, string s) { G.resize(parent.size()); this-\u0026gt;s = s; for(int i=1;i\u0026lt;parent.size();i++) G[parent[i]].push_back(i);//建图 dfs(0);//从根节点出发 return res; } }; ","date":"2022-04-18T00:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC289%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220418_hu5892671283996116272.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC289%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第289场周赛总结"},{"content":"前言 二叉搜索树「中序遍历」得到的值构成的序列一定是升序的\n验证二叉搜索树 题目 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\n有效 二叉搜索树定义如下：\n节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。\n示例 1：\n输入：root = [2,1,3] 输出：true 示例 2：\n输入：root = [5,1,4,null,null,3,6] 输出：false 解释：根节点的值是 5 ，但是右子节点的值是 4 。\n提示：\n树中节点数目范围在[1, 10^4] 内 -2^31 \u0026lt;= Node.val \u0026lt;= 2^31 - 1\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/validate-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n暴力递归 如果不利用BST的性质的话，根据BST的定义可以有：\n当前节点的值要比其左子树节点所有的值都要大，即大于左子树中最大的值\n当前节点的值要比其右子树节点所有的值都要小，即小于右子树中最小的值\n左右子树也要是BST\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: unordered_map\u0026lt;TreeNode*,int\u0026gt; maxValue,minValue; int getMaxvalue(TreeNode* root){ if(maxValue.count(root)) return maxValue[root]; if(!root-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;right) { maxValue.emplace(root,root-\u0026gt;val); return root-\u0026gt;val; } int res=root-\u0026gt;val; if(root-\u0026gt;left) res = max(res,getMaxvalue(root-\u0026gt;left)); if(root-\u0026gt;right) res = max(res,getMaxvalue(root-\u0026gt;right)); maxValue.emplace(root,res); return res; } int getMinvalue(TreeNode* root){ if(minValue.count(root)) return minValue[root]; if(!root-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;right) { minValue.emplace(root,root-\u0026gt;val); return root-\u0026gt;val; } int res=root-\u0026gt;val; if(root-\u0026gt;left) res = min(res,getMinvalue(root-\u0026gt;left)); if(root-\u0026gt;right) res = min(res,getMinvalue(root-\u0026gt;right)); minValue.emplace(root,root-\u0026gt;val); return res; } bool isValidBST(TreeNode* root) { if(!root) return true; bool res = true; if(root-\u0026gt;left) res = res \u0026amp;\u0026amp; root-\u0026gt;val\u0026gt;getMaxvalue(root-\u0026gt;left) \u0026amp;\u0026amp;isValidBST(root-\u0026gt;left); if(root-\u0026gt;right) res = res \u0026amp;\u0026amp; root-\u0026gt;val\u0026lt;getMinvalue(root-\u0026gt;right) \u0026amp;\u0026amp; isValidBST(root-\u0026gt;right); return res; } }; 更聪明的递归 设计递归函数helper(root,lower,upper)表示根节点为root的子树中，所有的节点值的范围是否在(lower, upper)范围内\n根据二叉搜索树的性质，在递归调用左子树时，上界需改为root-\u0026gt;val；在递归调用右子树时，下界需改为root-\u0026gt;val。\n注意最开始时的初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: bool helper(TreeNode* root, long long lower, long long upper) { if (root == nullptr) { return true; } if (root -\u0026gt; val \u0026lt;= lower || root -\u0026gt; val \u0026gt;= upper) { return false; } return helper(root -\u0026gt; left, lower, root -\u0026gt; val) \u0026amp;\u0026amp; helper(root -\u0026gt; right, root -\u0026gt; val, upper); } bool isValidBST(TreeNode* root) { return helper(root, LONG_MIN, LONG_MAX); } }; 中序遍历 知道二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。\n迭代 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isValidBST(TreeNode* root) { stack\u0026lt;TreeNode*\u0026gt; stk; long long pre = (long long)INT_MIN-1; TreeNode* cur = root; while(stk.size()||cur!=nullptr){ while(cur!=nullptr){ stk.push(cur); cur = cur-\u0026gt;left; } cur = stk.top(); stk.pop(); if(cur-\u0026gt;val \u0026lt;= pre) return false; else pre = cur-\u0026gt;val; cur = cur-\u0026gt;right; } return true; } }; 递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: long long pre = (long long)INT_MIN-1; bool isValidBST(TreeNode* root) { if(!root) return true; if(!isValidBST(root-\u0026gt;left)) return false; if(root-\u0026gt;val \u0026lt;= pre) return false; else pre = root-\u0026gt;val; return isValidBST(root-\u0026gt;right); } }; 二叉树的最近公共祖先 题目 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n示例 1：\n输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 示例 2：\n输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 示例 3：\n输入：root = [1,2], p = 1, q = 2 输出：1\n提示：\n树中节点数目在范围 [2, 10^5] 内。 -10^9 \u0026lt;= Node.val \u0026lt;= 10^9 所有 Node.val 互不相同 。 p != q p 和 q 均存在于给定的二叉树中。\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n递归 如果root是p,q的最近公共祖先，则有以下几种情况：\n1）p和q在root的子树中，且分列root的异侧（分别在左、右子树中）\n2）p=root，且q在root的左或右子树中\n3）q=root，且p在root的左或右子树中\n明白lowestCommonAncestor(root,p,q)的作用：返回以root为根的子树中，节点p和q的最近公共祖先。\n相信它能完成，那么\n考虑边界，当root为空时，返回nullptr；当p或q就为root时，返回root。\n考虑下一层，L=左子树中节点p和q的最近公共祖先，R=右子树中节点p和q的最近公共祖先。如果!L即左子树中没找到p和q的最近公共祖先，那就返回在右子树中找到的结果，如果!R即在右子树中没找到p和q的最近公共祖先，那就返回在左子树中找到的结果，如果!L \u0026amp;\u0026amp; !R即左右子树中都没找到，说明没有（题目给定p和q均在给定的二叉树中），如果L \u0026amp;\u0026amp; R即左右子树中都找到了，说明p、q在root的异侧，返回root。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root==NULL || p==root || q==root) return root; TreeNode* L = lowestCommonAncestor(root-\u0026gt;left,p,q); TreeNode* R = lowestCommonAncestor(root-\u0026gt;right,p,q); if(!L) return R; else if(!R) return L; else return root; } }; 存储父节点 用哈希表存储所有节点的父节点，利用父节点的节点信息从p节点不断往上跳，并记录，再从q节点不断往上跳，如果碰到了已经访问过的节点，则该节点就是最近公共祖先。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: unordered_map\u0026lt;int, TreeNode*\u0026gt; fa; unordered_map\u0026lt;int, bool\u0026gt; vis; void dfs(TreeNode* root){ if (root-\u0026gt;left != nullptr) { fa[root-\u0026gt;left-\u0026gt;val] = root; dfs(root-\u0026gt;left); } if (root-\u0026gt;right != nullptr) { fa[root-\u0026gt;right-\u0026gt;val] = root; dfs(root-\u0026gt;right); } } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { fa[root-\u0026gt;val] = nullptr; dfs(root); while (p != nullptr) { vis[p-\u0026gt;val] = true; p = fa[p-\u0026gt;val]; } while (q != nullptr) { if (vis[q-\u0026gt;val]) return q; q = fa[q-\u0026gt;val]; } return nullptr; } }; 二叉搜索树的最近公共祖先 题目 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]\n示例 1:\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2:\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n说明:\n所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n递归 这题完全可以复制上一题的代码。\n如果利用二叉搜索树的性质的话：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root==NULL || p==root || q==root) return root; if(p-\u0026gt;val \u0026lt; root-\u0026gt;val \u0026amp;\u0026amp; q-\u0026gt;val \u0026lt; root-\u0026gt;val) return lowestCommonAncestor(root-\u0026gt;left,p,q); else if(p-\u0026gt;val \u0026gt; root-\u0026gt;val \u0026amp;\u0026amp; q-\u0026gt;val \u0026gt; root-\u0026gt;val) return lowestCommonAncestor(root-\u0026gt;right,p,q); else return root; } }; 迭代 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { TreeNode* ancestor = root; while (true) { if (p-\u0026gt;val \u0026lt; ancestor-\u0026gt;val \u0026amp;\u0026amp; q-\u0026gt;val \u0026lt; ancestor-\u0026gt;val) { ancestor = ancestor-\u0026gt;left; } else if (p-\u0026gt;val \u0026gt; ancestor-\u0026gt;val \u0026amp;\u0026amp; q-\u0026gt;val \u0026gt; ancestor-\u0026gt;val) { ancestor = ancestor-\u0026gt;right; } else { break; } } return ancestor; } }; 二叉搜索树的插入操作 题目 给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。\n注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。\n示例 1：\n输入：root = [4,2,7,1,3], val = 5 输出：[4,2,7,1,3,5] 解释：另一个满足题目要求可以通过的树是：\n示例 2：\n输入：root = [40,20,60,10,30,50,70], val = 25 输出：[40,20,60,10,30,50,70,null,null,25] 示例 3：\n输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5 输出：[4,2,7,1,3,5]\n提示：\n树中的节点数将在 [0, 10^4]的范围内。 -10^8 \u0026lt;= Node.val \u0026lt;= 10^8 所有值 Node.val 是 独一无二 的。 -10^8 \u0026lt;= val \u0026lt;= 10^8 保证 val 在原始BST中不存在。\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/insert-into-a-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* insertIntoBST(TreeNode* root, int val) { if(root==nullptr) root = new TreeNode(val); if(val \u0026lt; root-\u0026gt;val) root-\u0026gt;left = insertIntoBST(root-\u0026gt;left,val); else if(val \u0026gt; root-\u0026gt;val) root-\u0026gt;right = insertIntoBST(root-\u0026gt;right,val); return root; } }; 迭代 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* insertIntoBST(TreeNode* root, int val) { if(root==nullptr) return new TreeNode(val); TreeNode* res = root; while(root){ if(val \u0026gt; root-\u0026gt;val){ if(root-\u0026gt;right) root = root-\u0026gt;right; else { root-\u0026gt;right = new TreeNode(val); break; } }else if(val \u0026lt; root-\u0026gt;val){ if(root-\u0026gt;left) root = root-\u0026gt;left; else{ root-\u0026gt;left = new TreeNode(val); break; } } } return res; } }; 删除二叉搜索树中的节点 题目 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n一般来说，删除节点可分为两个步骤：\n首先找到需要删除的节点； 如果找到了，删除它。\n示例 1:\n输入：root = [5,3,6,2,4,null,7], key = 3 输出：[5,4,6,2,null,null,7] 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。 一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。 另一个正确答案是 [5,2,6,null,4,null,7]。\n示例 2:\n输入: root = [5,3,6,2,4,null,7], key = 0 输出: [5,3,6,2,4,null,7] 解释: 二叉树不包含值为 0 的节点 示例 3:\n输入: root = [], key = 0 输出: []\n提示:\n节点数的范围 [0, 10^4]. -10^5 \u0026lt;= Node.val \u0026lt;= 10^5 节点值唯一 root 是合法的二叉搜索树 -10^5 \u0026lt;= key \u0026lt;= 10^5\n进阶： 要求算法时间复杂度为 O(h)，h 为树的高度。\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/delete-node-in-a-bst 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n递归1.0 有以下五种情况：\n第一种情况：没找到删除的节点，遍历到空节点直接返回了 找到删除的节点 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* deleteNode(TreeNode* root, int key) { if(!root) return nullptr; if(root-\u0026gt;val == key){ if(root-\u0026gt;left==nullptr \u0026amp;\u0026amp; root-\u0026gt;right==nullptr){ return nullptr; }else if(root-\u0026gt;left==nullptr \u0026amp;\u0026amp; root-\u0026gt;right!=nullptr){ return root-\u0026gt;right; }else if(root-\u0026gt;right==nullptr \u0026amp;\u0026amp; root-\u0026gt;left!=nullptr){ return root-\u0026gt;left; }else{ TreeNode* cur = root-\u0026gt;right; while(cur-\u0026gt;left) cur = cur-\u0026gt;left; cur-\u0026gt;left = root-\u0026gt;left; return root-\u0026gt;right; } } else if(key \u0026gt; root-\u0026gt;val) root-\u0026gt;right = deleteNode(root-\u0026gt;right, key); else if(key \u0026lt; root-\u0026gt;val) root-\u0026gt;left = deleteNode(root-\u0026gt;left, key); return root; } }; 这种方法虽然能过，但是树的高度一直在增加\n递归2.0 官方题解，通过替换删除节点和前驱节点或后继节点的值，然后一直递归删除来达到目的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { /* One step right and then always left */ public int successor(TreeNode root) { root = root.right; while (root.left != null) root = root.left; return root.val; } /* One step left and then always right */ public int predecessor(TreeNode root) { root = root.left; while (root.right != null) root = root.right; return root.val; } public TreeNode deleteNode(TreeNode root, int key) { if (root == null) return null; // delete from the right subtree if (key \u0026gt; root.val) root.right = deleteNode(root.right, key); // delete from the left subtree else if (key \u0026lt; root.val) root.left = deleteNode(root.left, key); // delete the current node else { // the node is a leaf if (root.left == null \u0026amp;\u0026amp; root.right == null) root = null; // the node is not a leaf and has a right child else if (root.right != null) { root.val = successor(root); root.right = deleteNode(root.right, root.val); } // the node is not a leaf, has no right child, and has a left child else { root.val = predecessor(root); root.left = deleteNode(root.left, root.val); } } return root; } } 删除节点再创建 这种解法也行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode *creat(vector\u0026lt;TreeNode*\u0026gt; \u0026amp;mid,int l,int r) { if(l\u0026gt;r) return nullptr; int m=l+((r-l)\u0026gt;\u0026gt;1); TreeNode *root=mid[m]; root-\u0026gt;left=creat(mid,l,m-1); root-\u0026gt;right=creat(mid,m+1,r); return root; } TreeNode* deleteNode(TreeNode* root, int key) { vector\u0026lt;TreeNode*\u0026gt; mid; stack\u0026lt;TreeNode*\u0026gt; s; while(!s.empty()||root) { while(root) { s.push(root); root=root-\u0026gt;left; } root=s.top(); s.pop(); if(root-\u0026gt;val!=key) { mid.push_back(root); } root=root-\u0026gt;right; } root=creat(mid,0,mid.size()-1); return root; } }; 普通二叉树的删除 和递归2.0中思路类似，找到删除节点后，如果没右子节点了，返回左子节点即可。如果有右子节点，则和右子树最左节点交换值，再递归删除。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: TreeNode* deleteNode(TreeNode* root, int key) { if (root == nullptr) return root; if (root-\u0026gt;val == key) { if (root-\u0026gt;right == nullptr) { // 这里第二次操作目标值：最终删除的作用 return root-\u0026gt;left; } TreeNode *cur = root-\u0026gt;right; while (cur-\u0026gt;left) { cur = cur-\u0026gt;left; } swap(root-\u0026gt;val, cur-\u0026gt;val); // 这里第一次操作目标值：交换目标值其右子树最左面节点。 } root-\u0026gt;left = deleteNode(root-\u0026gt;left, key); root-\u0026gt;right = deleteNode(root-\u0026gt;right, key); return root; } }; 修剪二叉搜索树 题目 给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。\n所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。\n示例 1：\n输入：root = [1,0,2], low = 1, high = 2 输出：[1,null,2] 示例 2：\n输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3 输出：[3,2,null,1]\n提示：\n树中节点数在范围 [1, 10^4] 内 0 \u0026lt;= Node.val \u0026lt;= 10^4 树中每个节点的值都是 唯一 的 题目数据保证输入是一棵有效的二叉搜索树 0 \u0026lt;= low \u0026lt;= high \u0026lt;= 10^4\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/trim-a-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n递归 利用好二叉搜索树的性质，明白递归函数的作用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* trimBST(TreeNode* root, int low, int high) { if(root == nullptr) return root; if(root-\u0026gt;val \u0026gt;= low \u0026amp;\u0026amp; root-\u0026gt;val \u0026lt;= high){ root -\u0026gt; left = trimBST(root-\u0026gt;left, low, high); root -\u0026gt; right = trimBST(root-\u0026gt;right, low, high); } else if(root-\u0026gt;val \u0026lt; low ) return trimBST(root-\u0026gt;right,low,high); else if(root-\u0026gt;val \u0026gt; high) return trimBST(root-\u0026gt;left,low,high); return root; } }; 迭代 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: TreeNode* trimBST(TreeNode* root, int L, int R) { if (!root) return nullptr; // 处理头结点，让root移动到[L, R] 范围内，注意是左闭右闭 while (root != nullptr \u0026amp;\u0026amp; (root-\u0026gt;val \u0026lt; L || root-\u0026gt;val \u0026gt; R)) { if (root-\u0026gt;val \u0026lt; L) root = root-\u0026gt;right; // 小于L往右走 else root = root-\u0026gt;left; // 大于R往左走 } TreeNode *cur = root; // 此时root已经在[L, R] 范围内，处理左孩子元素小于L的情况 while (cur != nullptr) { while (cur-\u0026gt;left \u0026amp;\u0026amp; cur-\u0026gt;left-\u0026gt;val \u0026lt; L) { cur-\u0026gt;left = cur-\u0026gt;left-\u0026gt;right; } cur = cur-\u0026gt;left; } cur = root; // 此时root已经在[L, R] 范围内，处理右孩子大于R的情况 while (cur != nullptr) { while (cur-\u0026gt;right \u0026amp;\u0026amp; cur-\u0026gt;right-\u0026gt;val \u0026gt; R) { cur-\u0026gt;right = cur-\u0026gt;right-\u0026gt;left; } cur = cur-\u0026gt;right; } return root; } }; 将有序数组转换为二叉搜索树 题目 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。\n高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。\n示例 1：\n输入：nums = [-10,-3,0,5,9] 输出：[0,-3,9,-10,null,5] 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：\n示例 2：\n输入：nums = [1,3] 输出：[3,1] 解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^4 -10^4 \u0026lt;= nums[i] \u0026lt;= 10^4 nums 按 严格递增 顺序排列\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n递归 想象一下线段树\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* build(vector\u0026lt;int\u0026gt;\u0026amp; nums,int l, int r){ if(l\u0026gt;r) return nullptr; int mid = (l+r)/2; TreeNode* root = new TreeNode(nums[mid]); root-\u0026gt;left = build(nums,l,mid-1); root-\u0026gt;right = build(nums,mid+1,r); return root; } TreeNode* sortedArrayToBST(vector\u0026lt;int\u0026gt;\u0026amp; nums) { return build(nums,0,nums.size()-1); } }; 把二叉搜索树转换为累加树 题目 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。\n提醒一下，二叉搜索树满足下列约束条件：\n节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 注意：本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同\n示例 1：\n输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] 示例 2：\n输入：root = [0,null,1] 输出：[1,null,1] 示例 3：\n输入：root = [1,0,2] 输出：[3,3,2] 示例 4：\n输入：root = [3,2,4,1] 输出：[7,9,4,10]\n提示：\n树中的节点数介于 0 和 10^4 之间。 每个节点的值介于 -10^4 和 10^4 之间。 树中的所有值 互不相同 。 给定的树为二叉搜索树。\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/convert-bst-to-greater-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n递归 倒中序遍历后求前缀和\n中序遍历是 左-根-右\n所以这里要 右-根-左\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int cur = 0; TreeNode* convertBST(TreeNode* root) { if(root==nullptr) return root; convertBST(root-\u0026gt;right); cur = cur + root-\u0026gt;val; root-\u0026gt;val = cur; convertBST(root-\u0026gt;left); return root; } }; ","date":"2022-04-15T00:00:00Z","image":"https://tetsuou.github.io/p/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/post-bg-20220415_hu7207017690617373637.png","permalink":"https://tetsuou.github.io/p/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","title":"二叉搜索树"},{"content":"前言 再啰嗦一下，明白递归函数的作用并相信它能完成。\n由前序遍历和中序遍历能确定一棵二叉树\n由后序遍历和中序遍历能确定一棵二叉树\n但由前序遍历和后序遍历不能确定一棵二叉树\n从中序与后序遍历序列构造二叉树 题目 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。\n示例 1:\n输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] 输出：[3,9,20,null,null,15,7] 示例 2:\n输入：inorder = [-1], postorder = [-1] 输出：[-1]\n提示:\n1 \u0026lt;= inorder.length \u0026lt;= 3000 postorder.length == inorder.length -3000 \u0026lt;= inorder[i], postorder[i] \u0026lt;= 3000 inorder 和 postorder 都由 不同 的值组成 postorder 中每一个值都在 inorder 中 inorder 保证是树的中序遍历 postorder 保证是树的后序遍历\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n递归V1.0 根据中序与后序遍历序列构造二叉树，首先根据后序遍历序列可以确定根节点，根据这个根节点可以在中序遍历序列中分成左右子树，反过来可以在后序遍历序列中分割左右子树，\u0026hellip;，递归的做这件事\n1）如果两个序列都为空，说明是空节点；（如果两个序列大小都为1，将该节点作为根节点返回即可）\n2.1）如果两个序列不为空，取后序序列最后一个元素rootval作为根节点\n2.2）找到rootval在中序序列中的索引，作为切割点\n2.3）将中序序列切割成左中序序列（左子树）和右中序序列（右子树）\n2.4）得到上述左右子树的信息后，将后序序列切割成左后序序列（左子树）和右后序序列（右子树）\n3）递归处理左右区间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; inorder, vector\u0026lt;int\u0026gt;\u0026amp; postorder) { // if(inorder.size()==1 \u0026amp;\u0026amp; postorder.size()==1) return new TreeNode(inorder[0]); if(inorder.size()==0 \u0026amp;\u0026amp; postorder.size()==0) return nullptr; int rootval = postorder.back(); TreeNode* root = new TreeNode(rootval); postorder.pop_back();//删除最后一个根节点 auto idx = find(inorder.begin(),inorder.end(),rootval);//找到分割点 vector\u0026lt;int\u0026gt; leftInorder(inorder.begin(),idx); vector\u0026lt;int\u0026gt; rightInorder(idx+1,inorder.end()); vector\u0026lt;int\u0026gt; leftPostorder(postorder.begin(),postorder.begin()+leftInorder.size()); vector\u0026lt;int\u0026gt; rightPostorder(postorder.begin()+leftInorder.size(),postorder.end()); root-\u0026gt;left = buildTree(leftInorder,leftPostorder); root-\u0026gt;right = buildTree(rightInorder,rightPostorder); return root; } }; 递归V2.0 上述版本每层递归都定义了新的vector，耗时耗力，可以考虑增添索引作为参数，就不用每次都创建新的vector\n下面区间采取了左闭右闭，其他方式也一样\n这个遍历找分割点，可以先用一个哈希表存储[值，索引]，就可以O(1)查询了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: TreeNode* build(vector\u0026lt;int\u0026gt;\u0026amp; inorder,int lin,int rin,vector\u0026lt;int\u0026gt;\u0026amp; postorder,int lpo,int rpo){//[] if(lin\u0026gt;rin || lpo\u0026gt;rpo) return nullptr; TreeNode* root; int rootval = postorder[rpo]; root = new TreeNode(rootval); rpo--; int idx = -1; for(int i=lin;i\u0026lt;=rin;i++){ if(inorder[i]==rootval){ idx = i; break; } } root-\u0026gt;left=build(inorder,lin,idx-1,postorder,lpo,lpo+idx-1-lin); root-\u0026gt;right=build(inorder,idx+1,rin,postorder,lpo+idx-lin,rpo); return root; } TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; inorder, vector\u0026lt;int\u0026gt;\u0026amp; postorder) { return build(inorder,0,inorder.size()-1,postorder,0,postorder.size()-1); } }; 从前序与中序遍历序列构造二叉树 题目 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。\n示例 1:\n输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] 输出: [3,9,20,null,null,15,7] 示例 2:\n输入: preorder = [-1], inorder = [-1] 输出: [-1]\n提示:\n1 \u0026lt;= preorder.length \u0026lt;= 3000 inorder.length == preorder.length -3000 \u0026lt;= preorder[i], inorder[i] \u0026lt;= 3000 preorder 和 inorder 均 无重复 元素 inorder 均出现在 preorder preorder 保证 为二叉树的前序遍历序列 inorder 保证 为二叉树的中序遍历序列\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n递归题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: unordered_map\u0026lt;int,int\u0026gt; table; TreeNode* build(vector\u0026lt;int\u0026gt;\u0026amp; preorder,int Lpre,int Rpre,int Lin,int Rin){ if(Lpre\u0026gt;Rpre || Lin\u0026gt;Rin) return nullptr; int rootval = preorder[Lpre]; TreeNode* root = new TreeNode(rootval); int idx = table[rootval]; root-\u0026gt;left = build(preorder,Lpre+1,Lpre+idx-Lin,Lin, idx-1); root-\u0026gt;right = build(preorder,Lpre+idx-Lin+1,Rpre,idx+1,Rin); return root; } TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder) { int count=0; for(auto x:inorder){ table[x] = count++; } return build(preorder,0,count-1,0,count-1); } }; 合并二叉树 题目 给你两棵二叉树： root1 和 root2 。\n想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。\n返回合并后的二叉树。\n注意: 合并过程必须从两个树的根节点开始。\n示例 1：\n输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7] 输出：[3,4,5,5,4,null,7] 示例 2：\n输入：root1 = [1], root2 = [1,2] 输出：[2,2]\n提示：\n两棵树中的节点数目在范围 [0, 2000] 内 -10^4 \u0026lt;= Node.val \u0026lt;= 10^4\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-two-binary-trees 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n递归题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) { if(!root1) return root2; if(!root2) return root1; TreeNode* root = new TreeNode(root1-\u0026gt;val+root2-\u0026gt;val); root-\u0026gt;left = mergeTrees(root1-\u0026gt;left,root2-\u0026gt;left); root-\u0026gt;right = mergeTrees(root1-\u0026gt;right,root2-\u0026gt;right); return root; } }; ","date":"2022-04-13T00:00:00Z","image":"https://tetsuou.github.io/p/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BA%8C/post-bg-20220413_hu1377524393256610824.png","permalink":"https://tetsuou.github.io/p/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BA%8C/","title":"二叉树（二）"},{"content":"\n【贪心】按奇偶性交换后的最大数字 题目 给你一个正整数 num 。你可以交换 num 中 奇偶性 相同的任意两位数字（即，都是奇数或者偶数）。\n返回交换 任意 次之后 num 的 最大 可能值*。*\n示例 1：\n1 2 3 4 5 6 输入：num = 1234 输出：3412 解释：交换数字 3 和数字 1 ，结果得到 3214 。 交换数字 2 和数字 4 ，结果得到 3412 。 注意，可能存在其他交换序列，但是可以证明 3412 是最大可能值。 注意，不能交换数字 4 和数字 1 ，因为它们奇偶性不同。 示例 2：\n1 2 3 4 5 输入：num = 65875 输出：87655 解释：交换数字 8 和数字 6 ，结果得到 85675 。 交换数字 5 和数字 7 ，结果得到 87655 。 注意，可能存在其他交换序列，但是可以证明 87655 是最大可能值。 提示：\n1 \u0026lt;= num \u0026lt;= 10^9 解题思路 贪心。奇偶性相同的位置从大到小排序。\n打比赛的时候写的太繁琐了。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class Solution { public: int largestInteger(int num) { vector\u0026lt;int\u0026gt; nums; while(num){ nums.push_back(num%10); num/=10; } reverse(nums.begin(),nums.end()); int len = nums.size(); vector\u0026lt;int\u0026gt; iseven(len); vector\u0026lt;int\u0026gt; even; for(int i=0;i\u0026lt;len;i++){ if(nums[i]%2==0) { iseven[i] = 1; even.push_back(nums[i]); } } sort(even.begin(),even.end()); for(int i=0;i\u0026lt;len;i++){ if(iseven[i]) { nums[i]=even.back(),even.pop_back(); } } vector\u0026lt;int\u0026gt; isodd(len); vector\u0026lt;int\u0026gt; odd; for(int i=0;i\u0026lt;len;i++){ if(nums[i]%2==1) { isodd[i] = 1; odd.push_back(nums[i]); } } sort(odd.begin(),odd.end()); for(int i=0;i\u0026lt;len;i++){ if(isodd[i]) { nums[i]=odd.back(),odd.pop_back(); } } int res = 0; for(auto x:nums){ res = res*10+x; } return res; } }; 偷学代码 我前面花了一定代码量处理int转string以及string转int\n直接使用\u0026lt;string\u0026gt;里的to_string函数方便的多\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int largestInteger(int num) { auto s = std::to_string(num); for (int i = 0; i \u0026lt; int(s.length()); i++) { for (int j = 0; j \u0026lt; int(s.length()); j++) { if (s[i] % 2 == s[j] % 2 \u0026amp;\u0026amp; s[i] \u0026gt; s[j]) { std::swap(s[i], s[j]); } } } return std::atoi(s.c_str()); } }; 1 2 3 4 5 6 7 8 9 10 11 class Solution { public: int largestInteger(int num) { string str = to_string(num); for(int i=0; i\u0026lt;(int)str.size(); i++) for(int j=i+1; j\u0026lt;(int)str.size(); j++) if((str[i] ^ str[j]) % 2 == 0 \u0026amp;\u0026amp; str[i] \u0026lt; str[j]) swap(str[i], str[j]); return stoi(str); } }; atoi和stoi函数的区别 都是C++的字符处理函数，把数字字符串转换成int输出\n头文件都是#include\u0026lt;cstring\u0026gt;\natoi()的参数是 const char* ,因此对于一个字符串str我们必须调用 c_str()的方法把这个string转换成 const char类型的,而stoi()的参数是const string,不需要转化为 const char*；\nstoi()会做范围检查，默认范围是在int的范围内的，如果超出范围的话则会runtime error！而atoi()不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界；\n当输入的字符串不是整型，且前半部分都是数字时，stoi()与atoi()都会取前面为整型的部分。如string testFloat = \u0026ldquo;12.34\u0026rdquo;;时，两者输出值为12。\n当输入的字符串不是整型，且前半部分不是数字时，stoi()会报错，但atoi()会输出0。\n【暴力】向表达式添加括号后的最小结果 题目 给你一个下标从 0 开始的字符串 expression ，格式为 \u0026quot;\u0026lt;num1\u0026gt;+\u0026lt;num2\u0026gt;\u0026quot; ，其中 \u0026lt;num1\u0026gt; 和 \u0026lt;num2\u0026gt; 表示正整数。\n请你向 expression 中添加一对括号，使得在添加之后， expression 仍然是一个有效的数学表达式，并且计算后可以得到 最小 可能值。左括号 必须 添加在 '+' 的左侧，而右括号必须添加在 '+' 的右侧。\n返回添加一对括号后形成的表达式 expression ，且满足 expression 计算得到 最小 可能值*。*如果存在多个答案都能产生相同结果，返回任意一个答案。\n生成的输入满足：expression 的原始值和添加满足要求的任一对括号之后 expression 的值，都符合 32-bit 带符号整数范围。\n示例 1：\n1 2 3 4 5 输入：expression = \u0026#34;247+38\u0026#34; 输出：\u0026#34;2(47+38)\u0026#34; 解释：表达式计算得到 2 * (47 + 38) = 2 * 85 = 170 。 注意 \u0026#34;2(4)7+38\u0026#34; 不是有效的结果，因为右括号必须添加在 \u0026#39;+\u0026#39; 的右侧。 可以证明 170 是最小可能值。 示例 2：\n1 2 3 输入：expression = \u0026#34;12+34\u0026#34; 输出：\u0026#34;1(2+3)4\u0026#34; 解释：表达式计算得到 1 * (2 + 3) * 4 = 1 * 5 * 4 = 20 。 示例 3：\n1 2 3 输入：expression = \u0026#34;999+999\u0026#34; 输出：\u0026#34;(999+999)\u0026#34; 解释：表达式计算得到 999 + 999 = 1998 。 提示：\n3 \u0026lt;= expression.length \u0026lt;= 10 expression 仅由数字 '1' 到 '9' 和 '+' 组成 expression 由数字开始和结束 expression 恰好仅含有一个 '+'. expression 的原始值和添加满足要求的任一对括号之后 expression 的值，都符合 32-bit 带符号整数范围 解题思路 一开始看到表达式的题以为是要用动态规划，想run的，后来看数据范围，这么小，暴力就好\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Solution { public: string minimizeResult(string expression) { vector\u0026lt;int\u0026gt; left,right; bool flag = true; for(auto x: expression){ if(x==\u0026#39;+\u0026#39;) flag=false; else{ if(flag) left.push_back(x-\u0026#39;0\u0026#39;); else right.push_back(x-\u0026#39;0\u0026#39;); } } int lenL = left.size(),lenR=right.size(); right.push_back(0); int res = 1\u0026lt;\u0026lt;30; int idxL,idxR; for(int i=0;i\u0026lt;lenL;i++){ int leftL = 0,leftR=0; for(int p=0;p\u0026lt;i;p++){ leftL = leftL*10 + left[p]; } for(int q=i;q\u0026lt;lenL;q++){ leftR = leftR*10 + left[q]; } // cout\u0026lt;\u0026lt;leftL\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;leftR\u0026lt;\u0026lt;endl; for(int j=1;j\u0026lt;=lenR;j++){ int rightL=0,rightR=0; for(int p=0;p\u0026lt;j;p++) rightL = rightL*10 + right[p]; for(int q=j;q\u0026lt;lenR;q++) rightR = rightR*10 + right[q]; // cout\u0026lt;\u0026lt;rightL\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;rightR\u0026lt;\u0026lt;endl; if(leftL == 0) leftL =1; if(rightR == 0) rightR = 1; int tmp = leftL*(leftR+rightL); tmp*=rightR; if(tmp\u0026lt;res){ res = tmp; idxL = i; idxR = j; } } } // for(auto x:left){ // cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;; // }cout\u0026lt;\u0026lt;endl; // for(auto x:right){ // cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;; // } // cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;idxL\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;idxR\u0026lt;\u0026lt;endl; expression.insert(idxL,\u0026#34;(\u0026#34;); idxR = idxR+lenL+2; expression.insert(idxR,\u0026#34;)\u0026#34;); return expression; } }; 偷学代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: string minimizeResult(string s) { int ans = std::numeric_limits\u0026lt;int\u0026gt;::max(); int x = s.find(\u0026#39;+\u0026#39;); int n = s.length(); int I = 0, J = 0; for (int i = 0; i \u0026lt; x; i++) { for (int j = x + 2; j \u0026lt;= n; j++) { int v = (i == 0 ? 1 : std::atoi(s.substr(0, i).c_str())) * (std::atoi(s.substr(i, x - i).c_str()) + std::atoi(s.substr(x + 1, j - x - 1).c_str())) * (j == n ? 1 : std::atoi(s.substr(j, n - j).c_str())); if (v \u0026lt; ans) { ans = v; I = i; J = j; } } } s.insert(s.begin() + J, \u0026#39;)\u0026#39;); s.insert(s.begin() + I, \u0026#39;(\u0026#39;); return s; } }; 【贪心】K 次增加后的最大乘积 题目 给你一个非负整数数组 nums 和一个整数 k 。每次操作，你可以选择 nums 中 任一 元素并将它 增加 1 。\n请你返回 至多 k 次操作后，能得到的 nums的 最大乘积 。由于答案可能很大，请你将答案对 10^9 + 7 取余后返回。\n示例 1：\n1 2 3 4 5 6 输入：nums = [0,4], k = 5 输出：20 解释：将第一个数增加 5 次。 得到 nums = [5, 4] ，乘积为 5 * 4 = 20 。 可以证明 20 是能得到的最大乘积，所以我们返回 20 。 存在其他增加 nums 的方法，也能得到最大乘积。 示例 2：\n1 2 3 4 5 6 输入：nums = [6,3,3,2], k = 2 输出：216 解释：将第二个数增加 1 次，将第四个数增加 1 次。 得到 nums = [6, 4, 3, 3] ，乘积为 6 * 4 * 3 * 3 = 216 。 可以证明 216 是能得到的最大乘积，所以我们返回 216 。 存在其他增加 nums 的方法，也能得到最大乘积。 提示：\n1 \u0026lt;= nums.length, k \u0026lt;= 10^5 0 \u0026lt;= nums[i] \u0026lt;= 10^6 解题思路 一开始也以为要用动态规划，其实细想一下没那么难\n考虑$a*b*c*d$，各个数加1后分别为：\n$(a+1)*b*c*d=abcd+bcd$，\n$a*(b+1)*c*d=abcd+acd$，\n$a*b*(c+1)*d=abcd+abd$，\n$a*b*c*(d+1)=abcd+abc$。\n很明显，这个1加在最小的数上收益最大（这里的数都为非负数\n那么，维护一个最小堆即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int maximumProduct(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { if(nums.size()==1) return nums[0]+k; priority_queue\u0026lt;int,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt;\u0026gt; q; for(auto x:nums) q.push(x); int sum =0; while(1){ if(sum==k) break; int cur = q.top();q.pop(); int diff = q.top()-cur; if(diff+sum+1\u0026lt;=k) cur = cur + diff +1, sum += diff+1; else cur += k-sum, sum = k; q.push(cur); } long long res = 1; long long mod = 1e9+7; while(q.size()){ res = res*q.top()%mod; q.pop(); } return res; return 0; } }; 【枚举+二分】花园的最大总美丽值 题目 Alice 是 n 个花园的园丁，她想通过种花，最大化她所有花园的总美丽值。\n给你一个下标从 0 开始大小为 n 的整数数组 flowers ，其中 flowers[i] 是第 i 个花园里已经种的花的数目。已经种了的花 不能 移走。同时给你 newFlowers ，表示 Alice 额外可以种花的 最大数目 。同时给你的还有整数 target ，full 和 partial 。\n如果一个花园有 至少 target 朵花，那么这个花园称为 完善的 ，花园的 总美丽值 为以下分数之 和 ：\n完善 花园数目乘以 full. 剩余 不完善 花园里，花的 最少数目 乘以 partial 。如果没有不完善花园，那么这一部分的值为 0 。 请你返回 Alice 种最多 newFlowers 朵花以后，能得到的 最大 总美丽值。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 输入：flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1 输出：14 解释：Alice 可以按以下方案种花 - 在第 0 个花园种 2 朵花 - 在第 1 个花园种 3 朵花 - 在第 2 个花园种 1 朵花 - 在第 3 个花园种 1 朵花 花园里花的数目为 [3,6,2,2] 。总共种了 2 + 3 + 1 + 1 = 7 朵花。 只有 1 个花园是完善的。 不完善花园里花的最少数目是 2 。 所以总美丽值为 1 * 12 + 2 * 1 = 12 + 2 = 14 。 没有其他方案可以让花园总美丽值超过 14 。 示例 2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 输入：flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6 输出：30 解释：Alice 可以按以下方案种花 - 在第 0 个花园种 3 朵花 - 在第 1 个花园种 0 朵花 - 在第 2 个花园种 0 朵花 - 在第 3 个花园种 2 朵花 花园里花的数目为 [5,4,5,5] 。总共种了 3 + 0 + 0 + 2 = 5 朵花。 有 3 个花园是完善的。 不完善花园里花的最少数目为 4 。 所以总美丽值为 3 * 2 + 4 * 6 = 6 + 24 = 30 。 没有其他方案可以让花园总美丽值超过 30 。 注意，Alice可以让所有花园都变成完善的，但这样她的总美丽值反而更小。 提示：\n1 \u0026lt;= flowers.length \u0026lt;= 10^5 1 \u0026lt;= flowers[i], target \u0026lt;= 10^5 1 \u0026lt;= newFlowers \u0026lt;= 10^10 1 \u0026lt;= full, partial \u0026lt;= 10^5 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-total-beauty-of-the-gardens 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 一开始看题目是求最大值，再看数据范围，有想到用二分，但是想到可能有多种情况，比较麻烦。所以当时没做。\n令能得到的最大总美丽值为res，完善花园数目为fullcount，剩下不完善花园中花的最少数目为leastnum，那么有\n$$ res = fullcount*full+least*partial $$\n其中共有两个未知变量，考虑固定一个值后，从而更方便得到另一个值。\n设开始的完善花园个数为count。\n这里固定完善花园数目，即枚举完善花园数目（可知范围为[count, length]，然后要最大化least值，即剩下newFlowers数目下不完善花园中最大的最少花数目（经典的最大化最小值问题，可用二分）。\n在所有的情况中，选出最大值即可。\n最大化最小值 总体思路是这样的，但实现起来有蛮多细节的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool isok(int C, vector\u0026lt;int\u0026gt;\u0026amp; flowers, long long newFlowers,int target){ for(auto x:flowers){ if(x\u0026gt;=target) continue;; if(x\u0026gt;=C) continue; int need = C-x; newFlowers -= need; if(newFlowers\u0026lt;0) return false; } return true; } long long L = flowers.back(), R = target-1;//[] while(L\u0026lt;=R){ int mid = (L+R)\u0026gt;\u0026gt;1; if(isok(mid,flowers,newFlowers,target)) L = mid+1; else R = mid-1; } //R 一开始实现的二分里的判定函数如上，isok(C,flowers,newFlowers,target)表示额外可以种花数量为newFlowers时，所有不完善花园的最少花数目为C时是否可行。\n正确性应该没错，后面执行时发现了问题——超时，在isok函数里对flowers数组进行了一组遍历，消耗了O(n)时间。所以判定函数需要更换思路。\n——利用前缀和。\n判定思路其实也就是将不完善花园中少于C的花园中花的数目全部补充到C时，需要额外增添花的数目是否小于newFlowers\n所以先将flowers排序后，计算好前缀和，以方便计算。\n1 2 3 4 5 6 7 8 9 bool isok(int C,vector\u0026lt;int\u0026gt;\u0026amp; flowers,long long newFlowers){ int idx = upper_bound(flowers.begin(),flowers.end(),C,greater\u0026lt;int\u0026gt;())-flowers.begin();//first less pos if(idx==presum.size()) return true; long long cur = presum.back(); if(idx\u0026gt;0) cur-=presum[idx-1]; long long need = C*(flowers.size()-idx); if(cur+newFlowers\u0026gt;=need) return true; else return false; } 上述代码中presum数组为flowers数组非递增排序后的前缀和数组。\n首先在flowers数组中找到第一个小于C的位置idx（upper_bound默认是找第一个大于的值，所以需要增添第4个参数），如果没找到这样的位置，即flowers数组中的值都大于C，所以满足条件，返回true；\n否则的话需要计算额外补充的花的数目是否足够，即cur+newFlowers是否大于等于need。\n注意数据范围！ 注意数据范围，int的最大值约为$2*10^9$，而题中的数据范围最大值达到了$10^5$，两项相乘是可能溢出的，所以将需要的地方都定义成long long。\n特别注意：\n1 2 3 4 long long a; int b,c; a = b*c;//No!! may overflow a = 1LL*b*c;//Yes! 代码 修修改改，写的挺繁琐的。\n主要代码逻辑是：\n1）将flowers非递增排序并计算其前缀和数组presum，以方便二分判定。\n2）计算未额为补充花时，已经完善花园的数目，并且特判，计算当全部为完善花园数目时的答案（此时就不用再枚举未完善花园中的最少花的数目）\n3）接下来需要枚举新增完善花园的数目，我在这里也特判了一下，即当新增完善花园数目为0时；其余就在for循环里枚举。还有个特判是枚举到将所有花园都完善后，未完善部分就是0。\n4）固定完善花园数目后，就开始二分得到未完善花园中最少花数目的最大值\n5）所有情况中取最大的res\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class Solution { public: vector\u0026lt;long long\u0026gt; presum; bool isok(int C,vector\u0026lt;int\u0026gt;\u0026amp; flowers,long long newFlowers){ int idx = upper_bound(flowers.begin(),flowers.end(),C,greater\u0026lt;int\u0026gt;())-flowers.begin();//first less pos if(idx==presum.size()) return true; long long cur = presum.back(); if(idx\u0026gt;0) cur-=presum[idx-1]; long long need = C*(flowers.size()-idx); if(cur+newFlowers\u0026gt;=need) return true; else return false; } long long maximumBeauty(vector\u0026lt;int\u0026gt;\u0026amp; flowers, long long newFlowers, int target, int full, int partial) { int length = flowers.size(); sort(flowers.begin(),flowers.end(),greater\u0026lt;int\u0026gt;());//descend int count = 0; for(int i=0;i\u0026lt;length;i++){ if(flowers[i]\u0026gt;=target) count++; } presum.push_back(flowers[0]); for(int i=1;i\u0026lt;length;i++) presum.push_back(flowers[i]+presum.back()); long long res; if(count==length) { res = 1LL*length*full;//all full initially return res; } res = count*full; long long L = flowers.back(), R = target-1;//[] while(L\u0026lt;=R){ int mid = (L+R)\u0026gt;\u0026gt;1; if(isok(mid,flowers,newFlowers)) L=mid+1; else R=mid-1; } res += R*partial; for(int i=1;i\u0026lt;=length-count;i++){//add new full garden //enumerate the count of full garden int fullcount = count+i; int need = target-flowers[count+i-1]; newFlowers -= need; flowers[count+i-1] = target; if(newFlowers\u0026lt;0) break; if(i==length-count){ res=res\u0026lt;1LL*length*full?1LL*length*full:res; break; } long long left=flowers.back(),right=target-1; while(left\u0026lt;=right){ int mid=(left+right)\u0026gt;\u0026gt;1; if(isok(mid,flowers,newFlowers)) left=mid+1; else right=mid-1; } long long cur = 1LL*fullcount*full+right*partial; res = max(res,cur); } return res; } }; 偷学代码 该场比赛第1的代码，短小精炼\n一开始有个预处理，即flowers数组中大于target的部分零其等于target。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 using i64 = long long; class Solution { public: long long maximumBeauty(vector\u0026lt;int\u0026gt;\u0026amp; a, long long k, int T, int F, int P) { int n = a.size(); std::sort(a.begin(), a.end()); for (int i = 0; i \u0026lt; n; i++) { a[i] = std::min(a[i], T); } i64 ans = 0; std::vector\u0026lt;i64\u0026gt; sum(n + 1); for (int i = 0; i \u0026lt; n; i++) { sum[i + 1] = sum[i] + a[i]; } for (int i = 0, j = 0; i \u0026lt;= n; i++) { i64 K = k - (1LL * T * (n - i) - (sum[n] - sum[i])); if (K \u0026gt;= 0) { while (j \u0026lt; i \u0026amp;\u0026amp; K \u0026gt;= 1LL * a[j] * j - sum[j]) { j++; } ans = std::max(ans, 1LL * F * (n - i) + (j == 0 ? 0LL : 1LL * P * std::min(T - 1LL, (K + sum[j]) / j))); } if (i \u0026lt; n \u0026amp;\u0026amp; a[i] == T) { break; } } return ans; } }; ","date":"2022-04-11T13:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC288%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220411_2_hu5036242427883099477.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC288%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第288场周赛总结"},{"content":"\n【贪心】转化时间需要的最少操作数 题目 给你两个字符串 current 和 correct ，表示两个 24 小时制时间 。\n24 小时制时间 按 \u0026quot;HH:MM\u0026quot; 进行格式化，其中 HH 在 00 和 23 之间，而 MM 在 00 和 59 之间。最早的 24 小时制时间为 00:00 ，最晚的是 23:59 。\n在一步操作中，你可以将 current 这个时间增加 1、5、15 或 60 分钟。你可以执行这一操作 任意 次数。\n返回将 current 转化为 correct 需要的 最少操作数 。\n示例 1：\n1 2 3 4 5 6 7 8 输入：current = \u0026#34;02:30\u0026#34;, correct = \u0026#34;04:35\u0026#34; 输出：3 解释： 可以按下述 3 步操作将 current 转换为 correct ： - 为 current 加 60 分钟，current 变为 \u0026#34;03:30\u0026#34; 。 - 为 current 加 60 分钟，current 变为 \u0026#34;04:30\u0026#34; 。 - 为 current 加 5 分钟，current 变为 \u0026#34;04:35\u0026#34; 。 可以证明，无法用少于 3 步操作将 current 转化为 correct 。 示例 2：\n1 2 3 输入：current = \u0026#34;11:00\u0026#34;, correct = \u0026#34;11:01\u0026#34; 输出：1 解释：只需要为 current 加一分钟，所以最小操作数是 1 。 提示：\ncurrent 和 correct 都符合 \u0026quot;HH:MM\u0026quot; 格式 current \u0026lt;= correct 解题思路 先加60的，加不了再加15，加不了再加5，加不了再加1\n没想到可以先直接都转为分钟\n代码 写的很繁琐\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Solution { public: vector\u0026lt;int\u0026gt; covert(string time){ int i=0; int a=0,b=0; for(i=0;i\u0026lt;time.size();i++){ if(time[i]==\u0026#39;:\u0026#39;) break; a = a*10+(time[i]-\u0026#39;0\u0026#39;); } for(i++;i\u0026lt;time.size();i++){ b = b*10+(time[i]-\u0026#39;0\u0026#39;); } return {a,b}; } int convertTime(string current, string correct) { int cura = covert(current)[0], curb=covert(current)[1]; int fina = covert(correct)[0], finb=covert(correct)[1]; int step=0; while(1){ if(cura==fina \u0026amp;\u0026amp; curb==finb) break; if(cura==fina){ int tmp = finb - curb; if(tmp\u0026gt;=15) curb+=15; else if(tmp\u0026gt;=5) curb+=5; else curb+=1; step++; } if(cura\u0026lt;fina \u0026amp;\u0026amp; curb\u0026lt;=finb){ step+=fina-cura; cura = fina; } if(cura\u0026lt;fina \u0026amp;\u0026amp; curb\u0026gt;finb){ int tmp = finb+60-curb; if(tmp\u0026gt;=15){ curb+=15; if(curb\u0026gt;=60) curb-=60,cura++; } else if(tmp\u0026gt;=5){ curb+=5; if(curb\u0026gt;=60) curb-=60,cura++; } else { curb+=1; if(curb\u0026gt;=60) curb-=60,cura++; } step++; } } return step; } }; 偷学代码 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int convertTime(string current, string correct) { int a = stoi(current.substr(0, 2)) * 60 + stoi(current.substr(3, 2)); int b = stoi(correct.substr(0, 2)) * 60 + stoi(correct.substr(3, 2)); if (b \u0026lt; a) b += 24 * 60; int ans = 0; while (b - a \u0026gt;= 60) a += 60, ans++; while (b - a \u0026gt;= 15) a += 15, ans++; while (b - a \u0026gt;= 5) a += 5, ans++; return ans + b - a; } }; 【模拟】找出输掉零场或一场比赛的玩家 题目 给你一个整数数组 matches 其中 matches[i] = [winneri, loseri] 表示在一场比赛中 winneri 击败了 loseri 。\n返回一个长度为 2 的列表 answer ：\nanswer[0] 是所有 没有 输掉任何比赛的玩家列表。 answer[1] 是所有恰好输掉 一场 比赛的玩家列表。 两个列表中的值都应该按 递增 顺序返回。\n注意：\n只考虑那些参与 至少一场 比赛的玩家。 生成的测试用例保证 不存在 两场比赛结果 相同 。 示例 1：\n1 2 3 4 5 6 7 输入：matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]] 输出：[[1,2,10],[4,5,7,8]] 解释： 玩家 1、2 和 10 都没有输掉任何比赛。 玩家 4、5、7 和 8 每个都输掉一场比赛。 玩家 3、6 和 9 每个都输掉两场比赛。 因此，answer[0] = [1,2,10] 和 answer[1] = [4,5,7,8] 。 示例 2：\n1 2 3 4 5 6 输入：matches = [[2,3],[1,3],[5,4],[6,4]] 输出：[[1,2,5,6],[]] 解释： 玩家 1、2、5 和 6 都没有输掉任何比赛。 玩家 3 和 4 每个都输掉两场比赛。 因此，answer[0] = [1,2,5,6] 和 answer[1] = [] 。 提示：\n1 \u0026lt;= matches.length \u0026lt;= 105 matches[i].length == 2 1 \u0026lt;= winneri, loseri \u0026lt;= 105 winneri != loseri 所有 matches[i] 互不相同 解题思路 模拟即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; findWinners(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matches) { vector\u0026lt;int\u0026gt; a,b; unordered_map\u0026lt;int,int\u0026gt; mapa,mapb; for(auto v: matches){ int winnum = v[0]; int losenum = v[1]; mapa[winnum]++; mapb[losenum]++; } for(auto x: mapa){ if(!mapb.count(x.first)) a.push_back(x.first); } for(auto x:mapb){ if(x.second == 1) b.push_back(x.first); } sort(a.begin(),a.end()); sort(b.begin(),b.end()); return {a,b}; } }; 【二分】每个小孩最多能分到多少糖果 题目 给你一个 下标从 0 开始 的整数数组 candies 。数组中的每个元素表示大小为 candies[i] 的一堆糖果。你可以将每堆糖果分成任意数量的 子堆 ，但 无法 再将两堆合并到一起。\n另给你一个整数 k 。你需要将这些糖果分配给 k 个小孩，使每个小孩分到 相同 数量的糖果。每个小孩可以拿走 至多一堆 糖果，有些糖果可能会不被分配。\n返回每个小孩可以拿走的 最大糖果数目 。\n示例 1：\n1 2 3 输入：candies = [5,8,6], k = 3 输出：5 解释：可以将 candies[1] 分成大小分别为 5 和 3 的两堆，然后把 candies[2] 分成大小分别为 5 和 1 的两堆。现在就有五堆大小分别为 5、5、3、5 和 1 的糖果。可以把 3 堆大小为 5 的糖果分给 3 个小孩。可以证明无法让每个小孩得到超过 5 颗糖果。 示例 2：\n1 2 3 输入：candies = [2,5], k = 11 输出：0 解释：总共有 11 个小孩，但只有 7 颗糖果，但如果要分配糖果的话，必须保证每个小孩至少能得到 1 颗糖果。因此，最后每个小孩都没有得到糖果，答案是 0 。 提示：\n1 \u0026lt;= candies.length \u0026lt;= 105 1 \u0026lt;= candies[i] \u0026lt;= 107 1 \u0026lt;= k \u0026lt;= 1012 解题思路 如果每个小孩都能分到至少 x 个糖果，那么也能分到至少 (x - 1)个糖果。因此满足二分性。\n经典二分了\n一开始二分判定函数里有个变量写错了，WA了一发\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public: long long num;//孩子个数 vector\u0026lt;int\u0026gt; candie; long long len,sum;//糖果堆数 糖果总数 bool isok(long long c){//每人c颗是否可行 if(c*num\u0026gt;sum) return false; long long total = 0; for(auto x:candie){ total+=x/c; // cout\u0026lt;\u0026lt;total\u0026lt;\u0026lt;endl; } return total\u0026gt;=num; } int maximumCandies(vector\u0026lt;int\u0026gt;\u0026amp; candies, long long k) { num = k; candie = candies; len = candies.size(); sum=0; int maxc = -1; for(auto x:candies){ sum+=x; maxc=max(maxc,x); } if(sum\u0026lt;k) return 0; if(k==1) return maxc; // cout\u0026lt;\u0026lt;isok(6)\u0026lt;\u0026lt;endl; long long l = 0, r = 1e7+5;//左开右开 while(l+1!=r){ long long mid = (l+r)/2; if(isok(mid)) l=mid; else r = mid; } // cout\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;r\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;endl; return l; } }; 【模拟+逆向思考】加密解密字符串 题目 给你一个字符数组 keys ，由若干 互不相同 的字符组成。还有一个字符串数组 values ，内含若干长度为 2 的字符串。另给你一个字符串数组 dictionary ，包含解密后所有允许的原字符串。请你设计并实现一个支持加密及解密下标从 0 开始字符串的数据结构。\n字符串 加密 按下述步骤进行：\n对字符串中的每个字符 c ，先从 keys 中找出满足 keys[i] == c 的下标 i 。 在字符串中，用 values[i] 替换字符 c 。 字符串 解密 按下述步骤进行：\n将字符串每相邻 2 个字符划分为一个子字符串，对于每个子字符串 s ，找出满足 values[i] == s 的一个下标 i 。如果存在多个有效的 i ，从中选择 任意 一个。这意味着一个字符串解密可能得到多个解密字符串。 在字符串中，用 keys[i] 替换 s 。 实现 Encrypter 类：\nEncrypter(char[] keys, String[] values, String[] dictionary) 用 keys、values 和 dictionary 初始化 Encrypter 类。 String encrypt(String word1) 按上述加密过程完成对 word1 的加密，并返回加密后的字符串。 int decrypt(String word2) 统计并返回可以由 word2 解密得到且出现在 dictionary 中的字符串数目。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 输入： [\u0026#34;Encrypter\u0026#34;, \u0026#34;encrypt\u0026#34;, \u0026#34;decrypt\u0026#34;] [[[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;], [\u0026#34;ei\u0026#34;, \u0026#34;zf\u0026#34;, \u0026#34;ei\u0026#34;, \u0026#34;am\u0026#34;], [\u0026#34;abcd\u0026#34;, \u0026#34;acbd\u0026#34;, \u0026#34;adbc\u0026#34;, \u0026#34;badc\u0026#34;, \u0026#34;dacb\u0026#34;, \u0026#34;cadb\u0026#34;, \u0026#34;cbda\u0026#34;, \u0026#34;abad\u0026#34;]], [\u0026#34;abcd\u0026#34;], [\u0026#34;eizfeiam\u0026#34;]] 输出： [null, \u0026#34;eizfeiam\u0026#34;, 2] 解释： Encrypter encrypter = new Encrypter([[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;], [\u0026#34;ei\u0026#34;, \u0026#34;zf\u0026#34;, \u0026#34;ei\u0026#34;, \u0026#34;am\u0026#34;], [\u0026#34;abcd\u0026#34;, \u0026#34;acbd\u0026#34;, \u0026#34;adbc\u0026#34;, \u0026#34;badc\u0026#34;, \u0026#34;dacb\u0026#34;, \u0026#34;cadb\u0026#34;, \u0026#34;cbda\u0026#34;, \u0026#34;abad\u0026#34;]); encrypter.encrypt(\u0026#34;abcd\u0026#34;); // 返回 \u0026#34;eizfeiam\u0026#34;。 // \u0026#39;a\u0026#39; 映射为 \u0026#34;ei\u0026#34;，\u0026#39;b\u0026#39; 映射为 \u0026#34;zf\u0026#34;，\u0026#39;c\u0026#39; 映射为 \u0026#34;ei\u0026#34;，\u0026#39;d\u0026#39; 映射为 \u0026#34;am\u0026#34;。 encrypter.decrypt(\u0026#34;eizfeiam\u0026#34;); // return 2. // \u0026#34;ei\u0026#34; 可以映射为 \u0026#39;a\u0026#39; 或 \u0026#39;c\u0026#39;，\u0026#34;zf\u0026#34; 映射为 \u0026#39;b\u0026#39;，\u0026#34;am\u0026#34; 映射为 \u0026#39;d\u0026#39;。 // 因此，解密后可以得到的字符串是 \u0026#34;abad\u0026#34;，\u0026#34;cbad\u0026#34;，\u0026#34;abcd\u0026#34; 和 \u0026#34;cbcd\u0026#34;。 // 其中 2 个字符串，\u0026#34;abad\u0026#34; 和 \u0026#34;abcd\u0026#34;，在 dictionary 中出现，所以答案是 2 。 提示：\n1 \u0026lt;= keys.length == values.length \u0026lt;= 26 values[i].length == 2 1 \u0026lt;= dictionary.length \u0026lt;= 100 1 \u0026lt;= dictionary[i].length \u0026lt;= 100 所有 keys[i] 和 dictionary[i] 互不相同 1 \u0026lt;= word1.length \u0026lt;= 2000 1 \u0026lt;= word2.length \u0026lt;= 200 所有 word1[i] 都出现在 keys 中 word2.length 是偶数 keys、values[i]、dictionary[i]、word1 和 word2 只含小写英文字母 至多调用 encrypt 和 decrypt 总计 200 次 解题思路 这种类型题目，对于力扣的输入都有点搞不懂，所以当时就没写了\n加密，按题意模拟即可\n解密，倒过来思考，利用前面实现的加密即可\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Encrypter { public: vector\u0026lt;char\u0026gt; key; vector\u0026lt;string\u0026gt; value; vector\u0026lt;string\u0026gt; dic; Encrypter(vector\u0026lt;char\u0026gt;\u0026amp; keys, vector\u0026lt;string\u0026gt;\u0026amp; values, vector\u0026lt;string\u0026gt;\u0026amp; dictionary) { key = keys; value = values; dic = dictionary; } string encrypt(string word1) { string res; for(auto c:word1){ int idx = find(key.begin(),key.end(),c)-key.begin(); if(idx\u0026lt;key.size()) res += value[idx]; else res += \u0026#39;?\u0026#39;; } // cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return res; } int decrypt(string word2) { int res=0; for(auto x:dic){ if(encrypt(x)==word2) res++; } return res; } }; /** * Your Encrypter object will be instantiated and called as such: * Encrypter* obj = new Encrypter(keys, values, dictionary); * string param_1 = obj-\u0026gt;encrypt(word1); * int param_2 = obj-\u0026gt;decrypt(word2); */ ","date":"2022-04-11T12:00:00Z","image":"https://tetsuou.github.io/p/leetcode%E7%AC%AC287%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/post-bg-20220411_1_hu13328474491407171423.png","permalink":"https://tetsuou.github.io/p/leetcode%E7%AC%AC287%E5%9C%BA%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"LeetCode第287场周赛总结"},{"content":"前言 树的递归思维 这儿贴一下树，自顶向下和自底向上递归思维的差别。\n树的自顶向下递归其实就是前序遍历，自底向上递归是后续遍历。\n自顶向下（前序遍历）：确定一些参数，从该节点自身解决出发寻找答案；使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数\n自底向上（后序遍历）：对于树中的任意一个节点，如果知道它子节点的答案，计算该节点的答案\n二叉树的前序遍历 题目 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。\n示例 1：\n输入：root = [1,null,2,3] 输出：[1,2,3]\n示例 2：\n输入：root = [] 输出：[]\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n提示：\n树中节点数目在范围 [0, 100] 内 -100 \u0026lt;= Node.val \u0026lt;= 100 递归解法 根节点——左子树——右子树\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void traversal(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; vec){ if(root==nullptr) return; vec.push_back(root-\u0026gt;val); traversal(root-\u0026gt;left,vec); traversal(root-\u0026gt;right,vec); } vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; traversal(root,res); return res; } }; 迭代解法 显式地利用栈来模拟递归，栈是先进先出的，为了先左后右，应该先加右节点再加左节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { stack\u0026lt;TreeNode*\u0026gt; stk; vector\u0026lt;int\u0026gt; res; if(!root) return res; stk.push(root); while(!stk.empty()){ TreeNode* cur = stk.top(); stk.pop(); res.push_back(cur-\u0026gt;val); if(cur-\u0026gt;right) stk.push(cur-\u0026gt;right); if(cur-\u0026gt;left) stk.push(cur-\u0026gt;left); } return res; } }; 在迭代的过程中，有两个操作，一个是处理操作即将元素放进result数组，另一个操作是访问操作，也就是遍历节点。\n上面的的代码中处理和访问的顺序都是根左右\n牢记前序遍历：先根节点，再左子树的根节点，再左左子树的根节点，\u0026hellip;，再最左子节点的右子树..\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if(root==nullptr) return res; stack\u0026lt;TreeNode*\u0026gt; stk; TreeNode* node = root; while(stk.size() || node!=nullptr){ while(node!=nullptr){ res.push_back(node-\u0026gt;val); stk.push(node); node = node-\u0026gt;left; } node = stk.top(); stk.pop(); node = node-\u0026gt;right; } return res; } }; 二叉树的中序遍历 题目 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\n示例 1：\n输入：root = [1,null,2,3] 输出：[1,3,2] 示例 2：\n输入：root = [] 输出：[] 示例 3：\n输入：root = [1] 输出：[1]\n提示：\n树中节点数目在范围 [0, 100] 内 -100 \u0026lt;= Node.val \u0026lt;= 100\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n递归解法 左子树——根节点——右子树\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void inorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res){ if(!root) return; inorder(root-\u0026gt;left,res); res.push_back(root-\u0026gt;val); inorder(root-\u0026gt;right,res); } vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; ans; inorder(root,ans); return ans; } }; 迭代解法 中序遍历是左根右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。\n下面这种写法和前序遍历的区别就是访问的顺序一样，处理的顺序不一样\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if(root==nullptr) return res; stack\u0026lt;TreeNode*\u0026gt; stk; TreeNode* node = root; while(!stk.empty() || node!=nullptr){ while(node!=nullptr){ stk.push(node); node = node-\u0026gt;left; } node = stk.top(); stk.pop(); res.push_back(node-\u0026gt;val);//先左 再根 node = node-\u0026gt;right;//最后右 } return res; } }; 二叉树的后序遍历 题目 给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。\n示例 1：\n输入：root = [1,null,2,3] 输出：[3,2,1] 示例 2：\n输入：root = [] 输出：[] 示例 3：\n输入：root = [1] 输出：[1]\n提示：\n树中节点的数目在范围 [0, 100] 内 -100 \u0026lt;= Node.val \u0026lt;= 100\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n递归解法 左子树——右子树——根节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: void postorder(TreeNode *root, vector\u0026lt;int\u0026gt; \u0026amp;res) { if (root == nullptr) { return; } postorder(root-\u0026gt;left, res); postorder(root-\u0026gt;right, res); res.push_back(root-\u0026gt;val); } vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode *root) { vector\u0026lt;int\u0026gt; ans; postorder(root, ans); return ans; } }; 迭代解法 与中序的不同之处在于：\n中序遍历中，从栈中弹出的节点，其左子树是访问完了，可以直接访问该节点，然后接下来访问右子树。 后序遍历中，从栈中弹出的节点，我们只能确定其左子树肯定访问完了，但是无法确定右子树是否访问过。 因此，我们在后序遍历中，引入了一个prev来记录历史访问记录。\n当访问完一棵子树的时候，我们用prev指向该节点。 这样，在回溯到父节点的时候，我们可以依据prev是指向左子节点，还是右子节点，来判断父节点的访问情况。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; if(root==nullptr) return res; stack\u0026lt;TreeNode*\u0026gt; stk; TreeNode *node = root, *prev = nullptr; while(!stk.empty() || node!=nullptr){ while(node!=nullptr){ stk.push(node); node = node-\u0026gt;left; } node = stk.top(); stk.pop(); if(node-\u0026gt;right == nullptr || node-\u0026gt;right == prev){//无右子树 或 右子树访问完 res.push_back(node-\u0026gt;val); prev = node; node = nullptr; }else{ //否则将其重新压栈，开始访问右子树 stk.push(node); node = node-\u0026gt;right; } } return res; } }; 还有一种解法是根据前序遍历的迭代解法修改得来的：\n前序：根左右 后序：左右根\n在前序遍历的第一种迭代解法中，改变一下左右的顺序，可以得到 根右左 的遍历，此时将这个遍历翻转一下便可得到 左右根\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { stack\u0026lt;TreeNode*\u0026gt; st; vector\u0026lt;int\u0026gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); st.pop(); result.push_back(node-\u0026gt;val); if (node-\u0026gt;left) st.push(node-\u0026gt;left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈） if (node-\u0026gt;right) st.push(node-\u0026gt;right); // 空节点不入栈 } reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了 return result; } }; 二叉树的层次遍历 题目 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。\n示例 1：\n输入：root = [3,9,20,null,null,15,7] 输出：[[3],[9,20],[15,7]] 示例 2：\n输入：root = [1] 输出：[[1]] 示例 3：\n输入：root = [] 输出：[]\n提示：\n树中节点数目在范围 [0, 2000] 内 -1000 \u0026lt;= Node.val \u0026lt;= 1000\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n迭代解法（BFS） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { queue\u0026lt;TreeNode*\u0026gt; que; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if(!root) return res; que.push(root); while(!que.empty()){ vector\u0026lt;int\u0026gt; level; int q = que.size(); while(q--){//一次将队列中的所有元素都取出来 TreeNode* node = que.front(); que.pop(); level.push_back(node-\u0026gt;val); if(node-\u0026gt;left) que.push(node-\u0026gt;left); if(node-\u0026gt;right) que.push(node-\u0026gt;right); } res.push_back(level); } return res; } }; 递归解法 在递归函数多加一个表示层级的参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;int\u0026gt; empty; void dfs(TreeNode* root, int level){ if(!root) return; if(level\u0026gt;=res.size()){ res.push_back(empty); } res[level].push_back(root-\u0026gt;val); dfs(root-\u0026gt;left,level+1); dfs(root-\u0026gt;right,level+1); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { if(!root) return res; res.push_back(empty); dfs(root, 0); return res; } }; 判断是否为平衡二叉树 题目 给定一个二叉树，判断它是否是高度平衡的二叉树。\n本题中，一棵高度平衡二叉树定义为：\n一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。\n示例 1：\n输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2：\n输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3：\n输入：root = [] 输出：true\n提示：\n树中的节点数在范围 [0, 5000] 内 -104 \u0026lt;= Node.val \u0026lt;= 104\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/balanced-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n自顶向下的递归 先定义一个计算高度的函数，用于计算二叉树中的任一节点的高度。然后即可判断二叉树是否平衡。\n具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int getHeight(TreeNode* root){ if(root==nullptr) return 0; int res = 1+max(getHeight(root-\u0026gt;left),getHeight(root-\u0026gt;right)); return res; } bool isBalanced(TreeNode* root) { if(root==nullptr) return true; int heightdiff = abs(getHeight(root-\u0026gt;left)-getHeight(root-\u0026gt;right)); return heightdiff\u0026lt;=1 \u0026amp;\u0026amp; isBalanced(root-\u0026gt;left) \u0026amp;\u0026amp; isBalanced(root-\u0026gt;right); } }; 注意到上面这种方法有大量的重复计算，越下层节点调用getHeight次数越多。\n可以加上备忘录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: unordered_map\u0026lt;TreeNode*, int\u0026gt; height;//记忆化 int getHeight(TreeNode* root){ if(root==nullptr) return 0; if(height.count(root)) return height[root]; int res = 1+max(getHeight(root-\u0026gt;left),getHeight(root-\u0026gt;right)); height.emplace(root,res); return res; } bool isBalanced(TreeNode* root) { if(root==nullptr) return true; int heightdiff = abs(getHeight(root-\u0026gt;left)-getHeight(root-\u0026gt;right)); return heightdiff\u0026lt;=1 \u0026amp;\u0026amp; isBalanced(root-\u0026gt;left) \u0026amp;\u0026amp; isBalanced(root-\u0026gt;right); } }; 自底向上的递归 自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int height(TreeNode* root) { if (root == NULL) { return 0; } int leftHeight = height(root-\u0026gt;left); int rightHeight = height(root-\u0026gt;right); if (leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) \u0026gt; 1) { return -1; } else { return max(leftHeight, rightHeight) + 1; } } bool isBalanced(TreeNode* root) { return height(root) \u0026gt;= 0; } }; 二叉树上的路径总和 题目 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。\n叶子节点 是指没有子节点的节点。\n示例 1：\n输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 输出：true 解释：等于目标和的根节点到叶节点路径如上图所示。 示例 2：\n输入：root = [1,2,3], targetSum = 5 输出：false 解释：树中存在两条根节点到叶子节点的路径： (1 \u0026ndash;\u0026gt; 2): 和为 3 (1 \u0026ndash;\u0026gt; 3): 和为 4 不存在 sum = 5 的根节点到叶子节点的路径。 示例 3：\n输入：root = [], targetSum = 0 输出：false 解释：由于树是空的，所以不存在根节点到叶子节点的路径。\n提示：\n树中节点的数目在范围 [0, 5000] 内 -1000 \u0026lt;= Node.val \u0026lt;= 1000 -1000 \u0026lt;= targetSum \u0026lt;= 1000\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/path-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路及代码 dfs(node,sum)：是否存在从节点node到某个叶子节点的路径和为sum\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool dfs(TreeNode *node , int sum){ if(node == nullptr) return false; if(node-\u0026gt;left==nullptr \u0026amp;\u0026amp; node-\u0026gt;right==nullptr \u0026amp;\u0026amp; sum - node-\u0026gt;val == 0) return true; int restsum = sum - node-\u0026gt;val; // cout\u0026lt;\u0026lt;\u0026#34;val: \u0026#34;\u0026lt;\u0026lt;node-\u0026gt;val\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;\u0026#34;sum: \u0026#34;\u0026lt;\u0026lt;restsum\u0026lt;\u0026lt;endl; if(dfs(node-\u0026gt;left, restsum)) return true; if(dfs(node-\u0026gt;right, restsum)) return true; return false; } bool hasPathSum(TreeNode* root, int targetSum) { return dfs(root,targetSum); } }; 二叉树上的路径总和II 题目 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。\n叶子节点 是指没有子节点的节点。\n示例 1：\n输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 输出：[[5,4,11,2],[5,8,4,5]] 示例 2：\n输入：root = [1,2,3], targetSum = 5 输出：[] 示例 3：\n输入：root = [1,2], targetSum = 0 输出：[]\n提示：\n树中节点总数在范围 [0, 5000] 内 -1000 \u0026lt;= Node.val \u0026lt;= 1000 -1000 \u0026lt;= targetSum \u0026lt;= 1000\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/path-sum-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路及代码 采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ret; vector\u0026lt;int\u0026gt; path; void dfs(TreeNode* root, int targetSum) { if (root == nullptr) { return; } path.emplace_back(root-\u0026gt;val); targetSum -= root-\u0026gt;val; if (root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr \u0026amp;\u0026amp; targetSum == 0) { ret.emplace_back(path); } dfs(root-\u0026gt;left, targetSum); // path.pop_back(); // path.push_back(root-\u0026gt;val); //这两步相当于啥都没干，所以可以省略 dfs(root-\u0026gt;right, targetSum); path.pop_back(); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pathSum(TreeNode* root, int targetSum) { dfs(root, targetSum); return ret; } }; 二叉树上的路径总和III 题目 给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。\n路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\n示例 1：\n输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8 输出：3 解释：和等于 8 的路径有 3 条，如图所示。 示例 2：\n输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 输出：3\n提示:\n二叉树的节点个数的范围是 [0,1000] -109 \u0026lt;= Node.val \u0026lt;= 109 -1000 \u0026lt;= targetSum \u0026lt;= 1000\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/path-sum-iii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n嵌套DFS 和前两题不同的是，这里的路径不要求是根节点到叶子节点。\n函数rootSum(root,targetSum)求以root节点为根的路径总和为targetSum的路径数\n函数pathSum(root,targetSum)求根节点是root的树中路径总和为targetSum的路径数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int rootSum(TreeNode* root, int targetSum) { if (!root) { return 0; } int ret = 0; if (root-\u0026gt;val == targetSum) { ret++; } ret += rootSum(root-\u0026gt;left, targetSum - root-\u0026gt;val); ret += rootSum(root-\u0026gt;right, targetSum - root-\u0026gt;val); return ret; } int pathSum(TreeNode* root, int targetSum) { if (!root) { return 0; } int ret = rootSum(root, targetSum); ret += pathSum(root-\u0026gt;left, targetSum); ret += pathSum(root-\u0026gt;right, targetSum); return ret; } }; 前缀和 记当前节点为cur，那么前缀和为当前节点到根节点路径的路径和\n如果下一节点next的前缀和 减去 当前节点cur的前缀和 等于 target，那么就说明cur-\u0026gt;val = target\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: unordered_map\u0026lt;int, int\u0026gt; table;//table[i][j] -\u0026gt; 前缀和为i的有j个 int ans = 0; void dfs(TreeNode* node, int curPrefix, int targetSum){ if(node == nullptr) return; curPrefix = curPrefix + node-\u0026gt;val; if(table.count(curPrefix-targetSum)) ans+=table[curPrefix-targetSum]; table[curPrefix]++; dfs(node-\u0026gt;left,curPrefix,targetSum); //想象一下平常循环里的回溯 dfs(node-\u0026gt;right,curPrefix,targetSum); table[curPrefix]--;//回溯，这个是全局变量，退出当前层必须要回溯即清空当前层对该全局变量的影响 } int pathSum(TreeNode* root, int targetSum) { table[0] = 1; if(root == nullptr) return 0; dfs(root,0,targetSum); return ans; } }; ","date":"2022-04-10T00:00:00Z","image":"https://tetsuou.github.io/p/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%80/20220410_hu13671893879501559703.png","permalink":"https://tetsuou.github.io/p/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%80/","title":"二叉树（一）"},{"content":"引言 链表的定义具有递归的性质，因此链表题目常可以用递归的方法求解。\n链表给的通常是头节点，迭代通常是从头到尾，而递归则是从尾到头。\n明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节， 否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。\n写递归感觉和归纳法类似，注意边界，以及第n层到第n+1层间的传递关系。\n移除链表元素 题目 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\n示例 1：\n输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]\n示例 2：\n输入：head = [], val = 1 输出：[]\n示例 3：\n输入：head = [7,7,7,7], val = 7 输出：[]\n提示：\n列表中的节点数目在范围 [0, 104] 内 1 \u0026lt;= Node.val \u0026lt;= 50 0 \u0026lt;= val \u0026lt;= 50\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-linked-list-elements 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路及代码 递归 考虑边界，当头节点为空时，直接返回空；\n考虑当前层和下一层的关系，这时需要明确该递归函数的作用，并且相信它能完成：返回移除完val值后链表的头节点。所以关系为当前层的头节点的next指针要指向下一层的头节点。\n当前层要干什么呢，移除元素，当前层的值为val时，需要移除元素，所以返回下一个元素即head-\u0026gt;next；否则不需要移除，返回原节点head。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeElements(ListNode* head, int val) { if(head==nullptr) return head; head-\u0026gt;next = removeElements(head-\u0026gt;next, val); if(head-\u0026gt;val == val) return head-\u0026gt;next; else return head; } }; 迭代 新增一个哑节点，以避免对头节点的分类讨论\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: ListNode* removeElements(ListNode* head, int val) { struct ListNode* dummyHead = new ListNode(0, head); struct ListNode* temp = dummyHead; while (temp-\u0026gt;next != NULL) { if (temp-\u0026gt;next-\u0026gt;val == val) { temp-\u0026gt;next = temp-\u0026gt;next-\u0026gt;next; } else { temp = temp-\u0026gt;next; } } return dummyHead-\u0026gt;next; } }; 反转链表 题目 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例 1：\n输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2：\n输入：head = [1,2] 输出：[2,1] 示例 3：\n输入：head = [] 输出：[]\n提示：\n链表中节点的数目范围是 [0, 5000] -5000 \u0026lt;= Node.val \u0026lt;= 5000\n进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路及代码 递归 考虑边界，和上一题不同的是，也要判断一下head-\u0026gt;next是否为空。可以这样想，后面出现了head-\u0026gt;next-\u0026gt;next，如果head\u0026gt;next为空的话，会报错。\n考虑当前层和下一层的关系，需要将当前头节点和头节点下一节点的指向倒转过来，注意要将head-\u0026gt;next置为NULL（考虑边界，如果不置为NULL，则会形成环）。\n返回的是倒转后的新头节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { if(head==nullptr|| head-\u0026gt;next==nullptr) return head; ListNode* newHead = reverseList(head-\u0026gt;next); head-\u0026gt;next-\u0026gt;next = head; head-\u0026gt;next = nullptr; return newHead; } }; 迭代 此时头节点并没有特殊情况，所以不需要加哑节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* prev = nullptr; ListNode* curr = head; while (curr) { ListNode* next = curr-\u0026gt;next; curr-\u0026gt;next = prev; prev = curr; curr = next; } return prev; } }; 两两交换链表中的节点 题目 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n示例 1：\n输入：head = [1,2,3,4] 输出：[2,1,4,3] 示例 2：\n输入：head = [] 输出：[] 示例 3：\n输入：head = [1] 输出：[1]\n提示：\n链表中节点的数目在范围 [0, 100] 内 0 \u0026lt;= Node.val \u0026lt;= 100\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路及代码 递归 考虑边界，0个节点或1个节点，原地返回。\n考虑当前层和下一层的关系，由于要交换两个节点，所以先存下当前节点的下一个节点rev，倒转指针朝向，返回rev。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { if(head==nullptr||head-\u0026gt;next==nullptr) return head; ListNode* rev = head-\u0026gt;next; head-\u0026gt;next = swapPairs(rev-\u0026gt;next); rev-\u0026gt;next = head; return rev; } }; 迭代 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(0,head); ListNode* temp = dummyHead; while (temp-\u0026gt;next != nullptr \u0026amp;\u0026amp; temp-\u0026gt;next-\u0026gt;next != nullptr) { ListNode* node1 = temp-\u0026gt;next; ListNode* node2 = temp-\u0026gt;next-\u0026gt;next; temp-\u0026gt;next = node2; node1-\u0026gt;next = node2-\u0026gt;next; node2-\u0026gt;next = node1; temp = node1; } return dummyHead-\u0026gt;next; } }; 删除链表的倒数第N个节点 题目 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n示例 1：\n输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2：\n输入：head = [1], n = 1 输出：[] 示例 3：\n输入：head = [1,2], n = 1 输出：[1]\n提示：\n链表中结点的数目为 sz 1 \u0026lt;= sz \u0026lt;= 30 0 \u0026lt;= Node.val \u0026lt;= 100 1 \u0026lt;= n \u0026lt;= sz\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路及代码 可以计算链表长度，以方便找出倒数第N个节点。\n可以使用栈，先进先出，以方便找出倒数第N个节点。\n可以使用双指针，一个指针先走N个节点，及它们间的距离为N，然后两个指针同时移动，当第一个指针到末尾的时候，说明第二个指针到了倒数第N个节点。\n迭代（双指针） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummy = new ListNode(-1, head); ListNode *p = dummy, *q = dummy; for(int i=0;i\u0026lt;n;i++) { q = q-\u0026gt;next; } while(q -\u0026gt;next!=nullptr){ p = p-\u0026gt;next; q = q-\u0026gt;next; } p-\u0026gt;next = p-\u0026gt;next-\u0026gt;next ; return dummy-\u0026gt;next; } }; 递归（全局变量） 还可以使用递归，不过与前面几题不同的是，需要一个全局变量，以表示倒数第几个节点。\n当记录反向深度的变量re_dl为n时，返回head-\u0026gt;next，说明删去了倒数第N个节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: int re_dl = 0;//记录反向深度 ListNode* removeNthFromEnd(ListNode* head, int n) { if(head==nullptr) return head; head-\u0026gt;next = removeNthFromEnd(head-\u0026gt;next,n); re_dl++;//在递归调用后累加，这样才是反向记录 if(re_dl==n) return head-\u0026gt;next; else return head; } }; 回文链表 题目 编写一个函数，检查输入的链表是否是回文的。\n示例 1：\n输入： 1-\u0026gt;2 输出： false 示例 2：\n输入： 1-\u0026gt;2-\u0026gt;2-\u0026gt;1 输出： true\n进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/palindrome-linked-list-lcci 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路及代码 可以将值复制到数组中后用双指针法；\n可以利用队列和栈进行比较；\n递归 递归反向迭代节点，同时使用递归函数外的变量向前迭代，就可以判断链表是否为回文\n（为了更方便的初始化，可以另设一个递归函数）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* front=nullptr; bool isPalindrome(ListNode* head) { if(!front) front = head; if(head==nullptr) return true; bool nxt = isPalindrome(head-\u0026gt;next); if(front-\u0026gt;val==head-\u0026gt;val) { front = front-\u0026gt;next; return nxt \u0026amp;\u0026amp; true; } else return false; } }; 再看看官方的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { ListNode* frontPointer; public: bool recursivelyCheck(ListNode* currentNode) { if (currentNode != nullptr) { if (!recursivelyCheck(currentNode-\u0026gt;next)) { return false; } if (currentNode-\u0026gt;val != frontPointer-\u0026gt;val) { return false; } frontPointer = frontPointer-\u0026gt;next; } return true; } bool isPalindrome(ListNode* head) { frontPointer = head; return recursivelyCheck(head); } }; 快慢指针 避免使用 O(n)O(n) 额外空间的方法就是改变输入。\n我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。\n整个流程可以分为以下五个步骤：\n找到前半部分链表的尾节点。 反转后半部分链表。 判断是否回文。 恢复链表。 返回结果。 执行步骤一，我们可以计算链表节点的数量，然后遍历链表找到前半部分的尾节点。\n我们也可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。\n若链表有奇数个节点，则中间的节点应该看作是前半部分。\n作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/palindrome-linked-list-lcci/solution/hui-wen-lian-biao-by-leetcode-solution-6cp3/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public: bool isPalindrome(ListNode* head) { if (head == nullptr) { return true; } // 找到前半部分链表的尾节点并反转后半部分链表 ListNode* firstHalfEnd = endOfFirstHalf(head); ListNode* secondHalfStart = reverseList(firstHalfEnd-\u0026gt;next); // 判断是否回文 ListNode* p1 = head; ListNode* p2 = secondHalfStart; bool result = true; while (result \u0026amp;\u0026amp; p2 != nullptr) { if (p1-\u0026gt;val != p2-\u0026gt;val) { result = false; } p1 = p1-\u0026gt;next; p2 = p2-\u0026gt;next; } // 还原链表并返回结果 firstHalfEnd-\u0026gt;next = reverseList(secondHalfStart); return result; } ListNode* reverseList(ListNode* head) { ListNode* prev = nullptr; ListNode* curr = head; while (curr != nullptr) { ListNode* nextTemp = curr-\u0026gt;next; curr-\u0026gt;next = prev; prev = curr; curr = nextTemp; } return prev; } ListNode* endOfFirstHalf(ListNode* head) { ListNode* fast = head; ListNode* slow = head; while (fast-\u0026gt;next != nullptr \u0026amp;\u0026amp; fast-\u0026gt;next-\u0026gt;next != nullptr) { fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; } return slow; } }; 反转链表II 题目 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left \u0026lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。\n示例 1：\n输入：head = [1,2,3,4,5], left = 2, right = 4 输出：[1,4,3,2,5] 示例 2：\n输入：head = [5], left = 1, right = 1 输出：[5]\n提示：\n链表中节点数目为 n 1 \u0026lt;= n \u0026lt;= 500 -500 \u0026lt;= Node.val \u0026lt;= 500 1 \u0026lt;= left \u0026lt;= right \u0026lt;= n\n进阶： 你可以使用一趟扫描完成反转吗？\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-linked-list-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路及代码 一个简单的思路是先遍历一遍，找出要反转的链表区间，然后再使用反转链表的方法反转。\n如果只遍历一遍的话，则需使用头插法\n头插法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode *reverseBetween(ListNode *head, int left, int right) { ListNode *dummyNode = new ListNode(-1,head); ListNode *pre = dummyNode; for (int i = 0; i \u0026lt; left - 1; i++) { pre = pre-\u0026gt;next; }//pre为待反转链表左区间的前驱节点，在后续头插法中保持不变 ListNode *first = pre-\u0026gt;next;//待反转链表的左区间 ListNode *second; for (int i = 0; i \u0026lt; right - left; i++) { second = first-\u0026gt;next; first-\u0026gt;next = second-\u0026gt;next; second-\u0026gt;next = pre-\u0026gt;next;//头插 pre-\u0026gt;next = second; } return dummyNode-\u0026gt;next; } }; 递归 如何递归反转链表-知乎\n反转前N个节点 首先考虑当头节点为左边界的情况，此时就是反转前N个节点。\n1 2 3 4 5 6 7 8 9 10 ListNode *reverseFN(ListNode *head, int n){ if(n==1){//此处为边界，剩余的链表部分不会遍历到 successor = head-\u0026gt;next;//右边界的后驱节点 return head; } ListNode* newHead = reverseFN(head-\u0026gt;next,n-1); head-\u0026gt;next-\u0026gt;next = head; head-\u0026gt;next = successor;//注意这里，递归是后向前迭代的，所以中间的赋值会被覆盖，只有最后会生效 return newHead; } 由前N个节点到[left,right] 首先，left=1时，即上面这种情况。\nleft!=1时：\n如果把head的索引视为1，从第left个元素开始反转； 如果把head.next的索引视为1，那么就是从第left-1个元素开始反转的。（此时，右边界也变为了right-1） 1 2 3 4 5 ListNode *reverseBetween(ListNode *head, int left, int right) { if(left==1) return reverseFN(head,right); head-\u0026gt;next = reverseBetween(head-\u0026gt;next,left-1,right-1); return head; } ","date":"2022-04-01T00:00:00Z","image":"https://tetsuou.github.io/p/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%80%92%E5%BD%92/20220401_hu16741131812698970064.jpg","permalink":"https://tetsuou.github.io/p/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%80%92%E5%BD%92/","title":"链表与递归"},{"content":"效果 https://TetsuOu.github.io/Bookmarks/\n官方地址 https://squidfunk.github.io/mkdocs-material/\n以下只做一下简单介绍，更多信息参考官方介绍。\n开始 MkDocs-material是MkDocs的一个第三方主题，界面优美。使用前应注意MkDocs是必需的。\n安装 可利用pip进行安装，除此之外，还可以使用docker、git进行安装，详见官网。\n1 pip install mkdocs-material 使用 在项目中的配置文件mkdocs.yml中进行配置：\n1 2 theme: name: material 更改网站图标 新的图标放在docs文件夹内的指定路径，如img/favicon.ico\n1 2 theme: favicon: img/favicon.ico 更改页面布局 参数配置如下，可以使最顶层的选项排序到上方\n1 2 3 theme: features: - navigation.tabs 如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 nav: - Introduction: \u0026#39;index.md\u0026#39; - SiteNavigation: \u0026#39;https://TetsuOu.github.io/SiteNavigation/\u0026#39; - Program: - Android: \u0026#39;Program/Android.md\u0026#39; - C/C++: \u0026#39;Program/C++.md\u0026#39; - Java: \u0026#39;Program/Java.md\u0026#39; - Python: \u0026#39;Program/Python.md\u0026#39; - Windows: \u0026#39;Program/Windows.md\u0026#39; - Study: - Language: \u0026#39;Study/Language.md\u0026#39; - Computer Science: \u0026#39;Study/ComputerScience.md\u0026#39; - Life: - Growing: \u0026#39;Life/Growing.md\u0026#39; 本地预览 即使用mkdocs serve\n部署 这里选择将其部署到Github Pages。\n除了之前介绍过的在本地使用MkDocs自带的gh-deploy命令进行部署外，还可以用Github Actions更为一劳永逸。\n在项目根目录新建文件夹.github，再在其中新建子文件夹workflows，再进入该子文件夹新建文件ci.yml，即该文件最终目录为/.github/workflows/ci.yml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 name: ci on: push: branches: - master - main jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - uses: actions/setup-python@v2 with: python-version: 3.x - run: pip install mkdocs-material - run: mkdocs gh-deploy --force 此后，只要向仓库提交更新，该Action就会对站点进行更新。\n更多 还可以设置许多其他的选项，比如字体、颜色、右侧“Table of contens”所支持的目录级数等等，详见官网。\n","date":"2021-01-08T00:00:00Z","image":"https://tetsuou.github.io/p/mkdocs-material%E7%9A%84%E5%BA%94%E7%94%A8/post-bg-210108_hu13780019541627156547.png","permalink":"https://tetsuou.github.io/p/mkdocs-material%E7%9A%84%E5%BA%94%E7%94%A8/","title":"MkDocs-material的应用"},{"content":"效果 https://TetsuOu.github.io/SiteNavigation/\n官方地址 https://github.com/WebStackPage/WebStackPage.github.io\n开始 官方地址给出了除静态托管方式以外的使用方式的链接。\n目前我只试用了静态托管方式，那就是选择clone或fork之后，主要对index.html文件进行增删改，然后部署到Github Pages上。\n可以用来熟悉前端语言。\n注意事项 锚点设置 1 2 3 4 5 6 \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#Recommended\u0026#34; class=\u0026#34;smooth\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;linecons-star\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span class=\u0026#34;title\u0026#34;\u0026gt;Recommended\u0026lt;/span\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;h4 class=\u0026#34;text-gray\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;linecons-tag\u0026#34; style=\u0026#34;margin-right: 7px;\u0026#34; id=\u0026#34;Recommended\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;Recommended\u0026lt;/h4\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-sm-3\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;xe-widget xe-conversations box2 label-info\u0026#34; onclick=\u0026#34;window.open(\u0026#39;https://www.wikipedia.org/\u0026#39;, \u0026#39;_blank\u0026#39;)\u0026#34; data-toggle=\u0026#34;tooltip\u0026#34; data-placement=\u0026#34;bottom\u0026#34; title=\u0026#34;\u0026#34; data-original-title=\u0026#34;https://dribbble.com/\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;xe-comment-entry\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;xe-user-img\u0026#34;\u0026gt; \u0026lt;img data-src=\u0026#34;../assets/images/logos/wekipedia.ico\u0026#34; class=\u0026#34;lozad img-circle\u0026#34; width=\u0026#34;40\u0026#34;\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;div class=\u0026#34;xe-comment\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; class=\u0026#34;xe-user-name overflowClip_1\u0026#34;\u0026gt; \u0026lt;strong\u0026gt;WikiPedia\u0026lt;/strong\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;p class=\u0026#34;overflowClip_2\u0026#34;\u0026gt;自由的百科全书\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 需要自己修改的就是 \u0026lt;i\u0026gt; 标签里的锚点、\u0026lt;img\u0026gt; 标签里的logo图片、onclick 属性里的网址、data-original-title 属性里的网址、\u0026lt;strong\u0026gt; 标签里的网站名称和 \u0026lt;p\u0026gt; 标签里的网站介绍。\n标签设置 注意一行的标签设置的是4个。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;h4 class=\u0026#34;text-gray\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;linecons-tag\u0026#34; style=\u0026#34;margin-right: 7px;\u0026#34; id=\u0026#34;Recommended\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;Recommended\u0026lt;/h4\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-sm-3\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-sm-3\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-sm-3\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-sm-3\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt;\t\u0026lt;!-- 注意有多余4个标签时，要多起一个\u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; --\u0026gt; \u0026lt;div class=\u0026#34;col-sm-3\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-sm-3\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-sm-3\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; linecons 这里左侧的图标可以在assets\\css\\fonts\\linecons\\css\\linecons-codes.css中查询支持的icon\n","date":"2020-12-18T00:00:00Z","image":"https://tetsuou.github.io/p/webstack%E6%A8%A1%E6%9D%BF/post-bg-201218_hu1607065387770803861.png","permalink":"https://tetsuou.github.io/p/webstack%E6%A8%A1%E6%9D%BF/","title":"Webstack模板"},{"content":"效果 官方地址 https://shields.io/\n以下只做一下简单介绍，更多信息参考官方介绍。\n静态徽章 格式如下：\n1 https://img.shields.io/badge/\u0026lt;LABEL\u0026gt;-\u0026lt;MESSAGE\u0026gt;-\u0026lt;COLOR\u0026gt; 如https://img.shields.io/badge/Main%20Language-C++-green，用图片格式引用，效果如下：\n1 ![](https://img.shields.io/badge/Main%20Language-C++-green) LABEL此处为\u0026quot;Main Language\u0026quot;，显示为徽章的左侧文字； MESSAGE此处为\u0026quot;C++\u0026quot;，显示为徽章的右侧文字； COLOR此处为\u0026quot;green\u0026quot;，为徽章的右侧颜色。徽章左侧默认为黑色。\n动态徽章 格式如下：（可以引用json、xml和yaml格式的文件，下面的是json）\n1 https://img.shields.io/badge/dynamic/json?url=\u0026lt;URL\u0026gt;\u0026amp;label=\u0026lt;LABEL\u0026gt;\u0026amp;query=\u0026lt;$.DATA.SUBDATA\u0026gt;\u0026amp;color=\u0026lt;COLOR\u0026gt;\u0026amp;prefix=\u0026lt;PREFIX\u0026gt;\u0026amp;suffix=\u0026lt;SUFFIX\u0026gt; 动态徽章可以实现更多的功能，比如要显示github的粉丝数，可以借由工具让其自动更新显示，不再需要手动更改数据。\n如：\n1 [![GitHub](https://img.shields.io/badge/dynamic/json?logo=github\u0026amp;label=GitHub\u0026amp;labelColor=495867\u0026amp;color=blue\u0026amp;query=%24.data.totalSubs\u0026amp;url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dgithub%26queryKey%3DTetsuOu\u0026amp;suffix=%20followers)](https://github.com/TetsuOu) 效果如下： logo参数可以在左侧增添一个logo，支持的logo在https://simpleicons.org/上。那要是该网站上没有所需要的logo呢？那就需要利用图片的base64编码了，后文再提。\nlabelColor参数设置徽章左侧颜色。\ncolor参数设置徽章右侧颜色。\nquery参数设置引用数据的相对路径。\nurl参数设置数据来源。\nsuffix参数设置数据后方的文字。\nSubstats 在解释上文中的url时需要先介绍个工具——Substats，官方地址：https://substats.spencerwoo.com/\n简单的说，这个工具能返回一个json文件，能得到一些需要的数据，比如github账户的followers数量等：\n1 https://api.spencerwoo.com/substats/?source=github\u0026amp;queryKey=TetsuOu 得到的数据格式为：\n1 2 3 4 5 6 7 8 9 10 { \u0026#34;status\u0026#34;: 200, \u0026#34;data\u0026#34;: { \u0026#34;totalSubs\u0026#34;: 8, \u0026#34;subsInEachSource\u0026#34;: { \u0026#34;github\u0026#34;: 8 }, \u0026#34;failedSources\u0026#34;: {} } } 因此，上面的shields中的query参数可以填，$.data.totalSubs，这里即为8。\n更多用法参考官网。\nCSDN徽章设置 可惜的是，上面的提到的logo网站没有CSDN的Logo，Substats也不支持CSDN的查询。只能用比较笨的方法了。\n效果如下：\n图标 首先是CSDN的图标制作。\n进入网址https://blog.csdn.net/favicon.ico，获取CSDN的图标文件，favicon.ico\n然后随便找一个可以将图片转base64的网站进行转换即可。\n我这里是将其图标文件先转成.svg格式再编码的：\n1 data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMnB4IiBoZWlnaHQ9IjMycHgiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMzIgMzIiIHhtbDpzcGFjZT0icHJlc2VydmUiPiAgPGltYWdlIGlkPSJpbWFnZTAiIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIgeD0iMCIgeT0iMCIKICAgIGhyZWY9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBZ0NBTUFBQUJFcElyR0FBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFDQmpTRkpOCkFBQjZKZ0FBZ0lRQUFQb0FBQUNBNkFBQWRUQUFBT3BnQUFBNm1BQUFGM0NjdWxFOEFBQUJNbEJNVkVYOFZUSDhkRmY5cFpMOXhMZisKMGNmK3pzUDl1YXI4a252OFhqejhnMm4rMjlQLy8vLys5dlg5cnB6OFd6ajhXamY5dnJEKy92Nys0dHo4WlVYOFhUdisxODcrNStMOQpzSi85d0xMKzdlcjl2Szc4VmpQOXpzVCs2K2Y4aUcvOFZ6VDltWVQrOWZQK3o4WDlwSkQrNGR2OFpFUDhiMUgrNitiOGpuYjhaa1grCitQZis5UEg4YVVyOFh6MzhjRkw5c3FMOW5Zais4dS8rNyt6OFdUYjhmMlQ5dGFYOGgyMzl2N0g4WjBmK3pzVCsvZjMrMHNuKysvdjkKeTcvOXRxYjhlVno5cTVyOFlVRCsrL3I4WTBMOGJFMzhpWEg4VmpMKzFzNzhZVC84Z0dYKzlQTDhaa2IrOC9EOW00YjhZa0Q4V0RYOQp3N2IrOXZUOGhHcisrdnIrNk9QKzJkSCsxTXYrNE5yKytmZis3K3Y4Zm1QOXNLRCs4L0grN3VyOXFwbjlxcGo5d3JiK3pNSDl1NjM5Cm9ZMzhlbDc4VnpPYi9QRHVBQUFBQVdKTFIwUUxIOWZFd0FBQUFBZDBTVTFGQitRTEhnb2ZCRUczcmRnQUFBRUFTVVJCVkRqTFkyQVkKZElDUmlabUZsWTJkQTRjMEp4YzNCUER3OG1HUjVoY1E1SVlESVdFTWVSRlJrSVNZZ0xpRUpJZ2hoUzR2TFFNVWxaVURNZVVWRkxtNQpsZEFWS0FQbFZWU2hIRFYxUVEwMGVVMHRibTV0SFRoWFZ3L2RBSDJnQVFaNC9DOXZ5TTF0Wkl4SGdRblFBRk44SWNnRVZHQ0dUNEU1ClVJRUZQZ1dXM054VzB2Z1VXSE56MitDVFo3QUZXaUdDVDRFZFVJRTlQZ1hzUUFVTytCUTRPbkZ6R3pvakNiaTR1cUdxRUFBYTRlNEIKNTNwNmNZdWpLdkQyQWNXMnJ4K0k3VzhTWU1YTkhZaG1TVkF3S0prSWhvU0doVWVBMDFRSXVqTThJN21SZ1ZFVWhrTTlvbVBnMHJGeAp1dGo4d2g4VW42QmtuWmlVbkpMS01KZ0FBSzlnRy9zSHMyZGFBQUFBSlhSRldIUmtZWFJsT21OeVpXRjBaUUF5TURJd0xURXhMVE13ClZERXdPak14T2pBMEt6QXdPakF3OHVOT01nQUFBQ1YwUlZoMFpHRjBaVHB0YjJScFpua0FNakF5TUMweE1TMHpNRlF4TURvek1Ub3cKTkNzd01Eb3dNSU8rOW80QUFBQUFTVVZPUks1Q1lJST0iIC8+Cjwvc3ZnPgo= 注意shields对图片有大小限制，不超过8192 bytes。\n数据获取 然后是数据的获取，我这里想使用CSDN账户上的粉丝数，因为目前没找到其他工具，自己也不会写，就只能自己将json文件保存在github上：\n点击Raw查看源文件地址：\n1 https://raw.githubusercontent.com/TetsuOu/TetsuOu/main/data.json 最终打造成了“伪 动态徽章”哈哈，每次只能自己手动更新。\n期待以后能有支持查询CSDN粉丝数的工具出现。\n其他 shields还支持一些预置的一些徽章生成，比如GitHub Workflow Status、License等\nGithub Workflow Status 1 ![](https://img.shields.io/github/actions/workflow/status/TetsuOu/TetsuOu.github.io/deploy.yml?branch=master) 1 ![Github License](https://img.shields.io/github/license/TetsuOu/TetsuOu.github.io) ","date":"2020-12-13T00:00:00Z","image":"https://tetsuou.github.io/p/shields%E5%BE%BD%E7%AB%A0%E7%9A%84%E5%BA%94%E7%94%A8/post-bg-201213_hu6420938211801195686.jpg","permalink":"https://tetsuou.github.io/p/shields%E5%BE%BD%E7%AB%A0%E7%9A%84%E5%BA%94%E7%94%A8/","title":"shields徽章的应用"}]